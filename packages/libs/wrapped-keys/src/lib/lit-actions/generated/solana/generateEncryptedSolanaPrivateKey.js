/**
 * DO NOT EDIT THIS FILE. IT IS GENERATED ON BUILD.
 * @type {string}
 */
const code = ";(()=>{try{const g=globalThis;const D=(g.Deno=g.Deno||{});const B=(D.build=D.build||{});if(B.os==null){B.os=\"linux\";}}catch{}})();\n\"use strict\";\n(() => {\n  var __create = Object.create;\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __getProtoOf = Object.getPrototypeOf;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __esm = (fn, res) => function __init() {\n    return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;\n  };\n  var __commonJS = (cb, mod2) => function __require() {\n    return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;\n  };\n  var __export = (target, all) => {\n    for (var name in all)\n      __defProp(target, name, { get: all[name], enumerable: true });\n  };\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n      for (let key of __getOwnPropNames(from))\n        if (!__hasOwnProp.call(to, key) && key !== except)\n          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });\n    }\n    return to;\n  };\n  var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(\n    // If the importer is in node compatibility mode or this is not an ESM\n    // file that has been converted to a CommonJS file using a Babel-\n    // compatible transform (i.e. \"__esModule\" has not been set), then set\n    // \"default\" to the CommonJS \"module.exports\" for node compatibility.\n    isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, \"default\", { value: mod2, enumerable: true }) : target,\n    mod2\n  ));\n  var __toCommonJS = (mod2) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod2);\n\n  // ../../../node_modules/.pnpm/@lit-protocol+esbuild-plugin-polyfill-node@0.3.0_esbuild@0.19.12/node_modules/@lit-protocol/esbuild-plugin-polyfill-node/polyfills/__dirname.js\n  var init_dirname = __esm({\n    \"../../../node_modules/.pnpm/@lit-protocol+esbuild-plugin-polyfill-node@0.3.0_esbuild@0.19.12/node_modules/@lit-protocol/esbuild-plugin-polyfill-node/polyfills/__dirname.js\"() {\n      \"use strict\";\n    }\n  });\n\n  // ../../../node_modules/.pnpm/@jspm+core@2.1.0/node_modules/@jspm/core/nodelibs/browser/process.js\n  function Item(fun, array2) {\n    this.fun = fun;\n    this.array = array2;\n  }\n  function hrtime(previousTimestamp) {\n    var baseNow = Math.floor((Date.now() - _performance.now()) * 1e-3);\n    var clocktime = _performance.now() * 1e-3;\n    var seconds = Math.floor(clocktime) + baseNow;\n    var nanoseconds = Math.floor(clocktime % 1 * 1e9);\n    if (previousTimestamp) {\n      seconds = seconds - previousTimestamp[0];\n      nanoseconds = nanoseconds - previousTimestamp[1];\n      if (nanoseconds < 0) {\n        seconds--;\n        nanoseconds += nanoPerSec;\n      }\n    }\n    return [seconds, nanoseconds];\n  }\n  var env, _performance, nowOffset, nanoPerSec;\n  var init_process = __esm({\n    \"../../../node_modules/.pnpm/@jspm+core@2.1.0/node_modules/@jspm/core/nodelibs/browser/process.js\"() {\n      \"use strict\";\n      init_dirname();\n      init_buffer2();\n      init_process2();\n      Item.prototype.run = function() {\n        this.fun.apply(null, this.array);\n      };\n      env = {\n        PATH: \"/usr/bin\",\n        LANG: typeof navigator !== \"undefined\" ? navigator.language + \".UTF-8\" : void 0,\n        PWD: \"/\",\n        HOME: \"/home\",\n        TMP: \"/tmp\"\n      };\n      _performance = {\n        now: typeof performance !== \"undefined\" ? performance.now.bind(performance) : void 0,\n        timing: typeof performance !== \"undefined\" ? performance.timing : void 0\n      };\n      if (_performance.now === void 0) {\n        nowOffset = Date.now();\n        if (_performance.timing && _performance.timing.navigationStart) {\n          nowOffset = _performance.timing.navigationStart;\n        }\n        _performance.now = () => Date.now() - nowOffset;\n      }\n      nanoPerSec = 1e9;\n      hrtime.bigint = function(time) {\n        var diff = hrtime(time);\n        if (typeof BigInt === \"undefined\") {\n          return diff[0] * nanoPerSec + diff[1];\n        }\n        return BigInt(diff[0] * nanoPerSec) + BigInt(diff[1]);\n      };\n    }\n  });\n\n  // ../../../node_modules/.pnpm/@lit-protocol+esbuild-plugin-polyfill-node@0.3.0_esbuild@0.19.12/node_modules/@lit-protocol/esbuild-plugin-polyfill-node/polyfills/process.js\n  var init_process2 = __esm({\n    \"../../../node_modules/.pnpm/@lit-protocol+esbuild-plugin-polyfill-node@0.3.0_esbuild@0.19.12/node_modules/@lit-protocol/esbuild-plugin-polyfill-node/polyfills/process.js\"() {\n      \"use strict\";\n      init_process();\n    }\n  });\n\n  // ../../../node_modules/.pnpm/@jspm+core@2.1.0/node_modules/@jspm/core/nodelibs/browser/chunk-DtuTasat.js\n  function dew$2() {\n    if (_dewExec$2)\n      return exports$2;\n    _dewExec$2 = true;\n    exports$2.byteLength = byteLength;\n    exports$2.toByteArray = toByteArray;\n    exports$2.fromByteArray = fromByteArray;\n    var lookup = [];\n    var revLookup = [];\n    var Arr = typeof Uint8Array !== \"undefined\" ? Uint8Array : Array;\n    var code = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n    for (var i = 0, len = code.length; i < len; ++i) {\n      lookup[i] = code[i];\n      revLookup[code.charCodeAt(i)] = i;\n    }\n    revLookup[\"-\".charCodeAt(0)] = 62;\n    revLookup[\"_\".charCodeAt(0)] = 63;\n    function getLens(b64) {\n      var len2 = b64.length;\n      if (len2 % 4 > 0) {\n        throw new Error(\"Invalid string. Length must be a multiple of 4\");\n      }\n      var validLen = b64.indexOf(\"=\");\n      if (validLen === -1)\n        validLen = len2;\n      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;\n      return [validLen, placeHoldersLen];\n    }\n    function byteLength(b64) {\n      var lens = getLens(b64);\n      var validLen = lens[0];\n      var placeHoldersLen = lens[1];\n      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n    }\n    function _byteLength(b64, validLen, placeHoldersLen) {\n      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;\n    }\n    function toByteArray(b64) {\n      var tmp;\n      var lens = getLens(b64);\n      var validLen = lens[0];\n      var placeHoldersLen = lens[1];\n      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));\n      var curByte = 0;\n      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;\n      var i2;\n      for (i2 = 0; i2 < len2; i2 += 4) {\n        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];\n        arr[curByte++] = tmp >> 16 & 255;\n        arr[curByte++] = tmp >> 8 & 255;\n        arr[curByte++] = tmp & 255;\n      }\n      if (placeHoldersLen === 2) {\n        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;\n        arr[curByte++] = tmp & 255;\n      }\n      if (placeHoldersLen === 1) {\n        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;\n        arr[curByte++] = tmp >> 8 & 255;\n        arr[curByte++] = tmp & 255;\n      }\n      return arr;\n    }\n    function tripletToBase64(num) {\n      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];\n    }\n    function encodeChunk(uint8, start, end) {\n      var tmp;\n      var output = [];\n      for (var i2 = start; i2 < end; i2 += 3) {\n        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);\n        output.push(tripletToBase64(tmp));\n      }\n      return output.join(\"\");\n    }\n    function fromByteArray(uint8) {\n      var tmp;\n      var len2 = uint8.length;\n      var extraBytes = len2 % 3;\n      var parts = [];\n      var maxChunkLength = 16383;\n      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {\n        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));\n      }\n      if (extraBytes === 1) {\n        tmp = uint8[len2 - 1];\n        parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + \"==\");\n      } else if (extraBytes === 2) {\n        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];\n        parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + \"=\");\n      }\n      return parts.join(\"\");\n    }\n    return exports$2;\n  }\n  function dew$1() {\n    if (_dewExec$1)\n      return exports$1;\n    _dewExec$1 = true;\n    exports$1.read = function(buffer, offset2, isLE2, mLen, nBytes) {\n      var e, m;\n      var eLen = nBytes * 8 - mLen - 1;\n      var eMax = (1 << eLen) - 1;\n      var eBias = eMax >> 1;\n      var nBits = -7;\n      var i = isLE2 ? nBytes - 1 : 0;\n      var d = isLE2 ? -1 : 1;\n      var s = buffer[offset2 + i];\n      i += d;\n      e = s & (1 << -nBits) - 1;\n      s >>= -nBits;\n      nBits += eLen;\n      for (; nBits > 0; e = e * 256 + buffer[offset2 + i], i += d, nBits -= 8) {\n      }\n      m = e & (1 << -nBits) - 1;\n      e >>= -nBits;\n      nBits += mLen;\n      for (; nBits > 0; m = m * 256 + buffer[offset2 + i], i += d, nBits -= 8) {\n      }\n      if (e === 0) {\n        e = 1 - eBias;\n      } else if (e === eMax) {\n        return m ? NaN : (s ? -1 : 1) * Infinity;\n      } else {\n        m = m + Math.pow(2, mLen);\n        e = e - eBias;\n      }\n      return (s ? -1 : 1) * m * Math.pow(2, e - mLen);\n    };\n    exports$1.write = function(buffer, value, offset2, isLE2, mLen, nBytes) {\n      var e, m, c;\n      var eLen = nBytes * 8 - mLen - 1;\n      var eMax = (1 << eLen) - 1;\n      var eBias = eMax >> 1;\n      var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;\n      var i = isLE2 ? 0 : nBytes - 1;\n      var d = isLE2 ? 1 : -1;\n      var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n      value = Math.abs(value);\n      if (isNaN(value) || value === Infinity) {\n        m = isNaN(value) ? 1 : 0;\n        e = eMax;\n      } else {\n        e = Math.floor(Math.log(value) / Math.LN2);\n        if (value * (c = Math.pow(2, -e)) < 1) {\n          e--;\n          c *= 2;\n        }\n        if (e + eBias >= 1) {\n          value += rt / c;\n        } else {\n          value += rt * Math.pow(2, 1 - eBias);\n        }\n        if (value * c >= 2) {\n          e++;\n          c /= 2;\n        }\n        if (e + eBias >= eMax) {\n          m = 0;\n          e = eMax;\n        } else if (e + eBias >= 1) {\n          m = (value * c - 1) * Math.pow(2, mLen);\n          e = e + eBias;\n        } else {\n          m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);\n          e = 0;\n        }\n      }\n      for (; mLen >= 8; buffer[offset2 + i] = m & 255, i += d, m /= 256, mLen -= 8) {\n      }\n      e = e << mLen | m;\n      eLen += mLen;\n      for (; eLen > 0; buffer[offset2 + i] = e & 255, i += d, e /= 256, eLen -= 8) {\n      }\n      buffer[offset2 + i - d] |= s * 128;\n    };\n    return exports$1;\n  }\n  function dew() {\n    if (_dewExec)\n      return exports;\n    _dewExec = true;\n    const base64 = dew$2();\n    const ieee754 = dew$1();\n    const customInspectSymbol = typeof Symbol === \"function\" && typeof Symbol[\"for\"] === \"function\" ? Symbol[\"for\"](\"nodejs.util.inspect.custom\") : null;\n    exports.Buffer = Buffer3;\n    exports.SlowBuffer = SlowBuffer;\n    exports.INSPECT_MAX_BYTES = 50;\n    const K_MAX_LENGTH = 2147483647;\n    exports.kMaxLength = K_MAX_LENGTH;\n    Buffer3.TYPED_ARRAY_SUPPORT = typedArraySupport();\n    if (!Buffer3.TYPED_ARRAY_SUPPORT && typeof console !== \"undefined\" && typeof console.error === \"function\") {\n      console.error(\"This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.\");\n    }\n    function typedArraySupport() {\n      try {\n        const arr = new Uint8Array(1);\n        const proto = {\n          foo: function() {\n            return 42;\n          }\n        };\n        Object.setPrototypeOf(proto, Uint8Array.prototype);\n        Object.setPrototypeOf(arr, proto);\n        return arr.foo() === 42;\n      } catch (e) {\n        return false;\n      }\n    }\n    Object.defineProperty(Buffer3.prototype, \"parent\", {\n      enumerable: true,\n      get: function() {\n        if (!Buffer3.isBuffer(this))\n          return void 0;\n        return this.buffer;\n      }\n    });\n    Object.defineProperty(Buffer3.prototype, \"offset\", {\n      enumerable: true,\n      get: function() {\n        if (!Buffer3.isBuffer(this))\n          return void 0;\n        return this.byteOffset;\n      }\n    });\n    function createBuffer(length) {\n      if (length > K_MAX_LENGTH) {\n        throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"');\n      }\n      const buf = new Uint8Array(length);\n      Object.setPrototypeOf(buf, Buffer3.prototype);\n      return buf;\n    }\n    function Buffer3(arg, encodingOrOffset, length) {\n      if (typeof arg === \"number\") {\n        if (typeof encodingOrOffset === \"string\") {\n          throw new TypeError('The \"string\" argument must be of type string. Received type number');\n        }\n        return allocUnsafe(arg);\n      }\n      return from(arg, encodingOrOffset, length);\n    }\n    Buffer3.poolSize = 8192;\n    function from(value, encodingOrOffset, length) {\n      if (typeof value === \"string\") {\n        return fromString(value, encodingOrOffset);\n      }\n      if (ArrayBuffer.isView(value)) {\n        return fromArrayView(value);\n      }\n      if (value == null) {\n        throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value);\n      }\n      if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {\n        return fromArrayBuffer(value, encodingOrOffset, length);\n      }\n      if (typeof SharedArrayBuffer !== \"undefined\" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {\n        return fromArrayBuffer(value, encodingOrOffset, length);\n      }\n      if (typeof value === \"number\") {\n        throw new TypeError('The \"value\" argument must not be of type number. Received type number');\n      }\n      const valueOf = value.valueOf && value.valueOf();\n      if (valueOf != null && valueOf !== value) {\n        return Buffer3.from(valueOf, encodingOrOffset, length);\n      }\n      const b = fromObject(value);\n      if (b)\n        return b;\n      if (typeof Symbol !== \"undefined\" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === \"function\") {\n        return Buffer3.from(value[Symbol.toPrimitive](\"string\"), encodingOrOffset, length);\n      }\n      throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type \" + typeof value);\n    }\n    Buffer3.from = function(value, encodingOrOffset, length) {\n      return from(value, encodingOrOffset, length);\n    };\n    Object.setPrototypeOf(Buffer3.prototype, Uint8Array.prototype);\n    Object.setPrototypeOf(Buffer3, Uint8Array);\n    function assertSize(size) {\n      if (typeof size !== \"number\") {\n        throw new TypeError('\"size\" argument must be of type number');\n      } else if (size < 0) {\n        throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"');\n      }\n    }\n    function alloc(size, fill, encoding) {\n      assertSize(size);\n      if (size <= 0) {\n        return createBuffer(size);\n      }\n      if (fill !== void 0) {\n        return typeof encoding === \"string\" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);\n      }\n      return createBuffer(size);\n    }\n    Buffer3.alloc = function(size, fill, encoding) {\n      return alloc(size, fill, encoding);\n    };\n    function allocUnsafe(size) {\n      assertSize(size);\n      return createBuffer(size < 0 ? 0 : checked(size) | 0);\n    }\n    Buffer3.allocUnsafe = function(size) {\n      return allocUnsafe(size);\n    };\n    Buffer3.allocUnsafeSlow = function(size) {\n      return allocUnsafe(size);\n    };\n    function fromString(string2, encoding) {\n      if (typeof encoding !== \"string\" || encoding === \"\") {\n        encoding = \"utf8\";\n      }\n      if (!Buffer3.isEncoding(encoding)) {\n        throw new TypeError(\"Unknown encoding: \" + encoding);\n      }\n      const length = byteLength(string2, encoding) | 0;\n      let buf = createBuffer(length);\n      const actual = buf.write(string2, encoding);\n      if (actual !== length) {\n        buf = buf.slice(0, actual);\n      }\n      return buf;\n    }\n    function fromArrayLike(array2) {\n      const length = array2.length < 0 ? 0 : checked(array2.length) | 0;\n      const buf = createBuffer(length);\n      for (let i = 0; i < length; i += 1) {\n        buf[i] = array2[i] & 255;\n      }\n      return buf;\n    }\n    function fromArrayView(arrayView) {\n      if (isInstance(arrayView, Uint8Array)) {\n        const copy = new Uint8Array(arrayView);\n        return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);\n      }\n      return fromArrayLike(arrayView);\n    }\n    function fromArrayBuffer(array2, byteOffset, length) {\n      if (byteOffset < 0 || array2.byteLength < byteOffset) {\n        throw new RangeError('\"offset\" is outside of buffer bounds');\n      }\n      if (array2.byteLength < byteOffset + (length || 0)) {\n        throw new RangeError('\"length\" is outside of buffer bounds');\n      }\n      let buf;\n      if (byteOffset === void 0 && length === void 0) {\n        buf = new Uint8Array(array2);\n      } else if (length === void 0) {\n        buf = new Uint8Array(array2, byteOffset);\n      } else {\n        buf = new Uint8Array(array2, byteOffset, length);\n      }\n      Object.setPrototypeOf(buf, Buffer3.prototype);\n      return buf;\n    }\n    function fromObject(obj) {\n      if (Buffer3.isBuffer(obj)) {\n        const len = checked(obj.length) | 0;\n        const buf = createBuffer(len);\n        if (buf.length === 0) {\n          return buf;\n        }\n        obj.copy(buf, 0, 0, len);\n        return buf;\n      }\n      if (obj.length !== void 0) {\n        if (typeof obj.length !== \"number\" || numberIsNaN(obj.length)) {\n          return createBuffer(0);\n        }\n        return fromArrayLike(obj);\n      }\n      if (obj.type === \"Buffer\" && Array.isArray(obj.data)) {\n        return fromArrayLike(obj.data);\n      }\n    }\n    function checked(length) {\n      if (length >= K_MAX_LENGTH) {\n        throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\" + K_MAX_LENGTH.toString(16) + \" bytes\");\n      }\n      return length | 0;\n    }\n    function SlowBuffer(length) {\n      if (+length != length) {\n        length = 0;\n      }\n      return Buffer3.alloc(+length);\n    }\n    Buffer3.isBuffer = function isBuffer(b) {\n      return b != null && b._isBuffer === true && b !== Buffer3.prototype;\n    };\n    Buffer3.compare = function compare(a, b) {\n      if (isInstance(a, Uint8Array))\n        a = Buffer3.from(a, a.offset, a.byteLength);\n      if (isInstance(b, Uint8Array))\n        b = Buffer3.from(b, b.offset, b.byteLength);\n      if (!Buffer3.isBuffer(a) || !Buffer3.isBuffer(b)) {\n        throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array');\n      }\n      if (a === b)\n        return 0;\n      let x = a.length;\n      let y = b.length;\n      for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n        if (a[i] !== b[i]) {\n          x = a[i];\n          y = b[i];\n          break;\n        }\n      }\n      if (x < y)\n        return -1;\n      if (y < x)\n        return 1;\n      return 0;\n    };\n    Buffer3.isEncoding = function isEncoding(encoding) {\n      switch (String(encoding).toLowerCase()) {\n        case \"hex\":\n        case \"utf8\":\n        case \"utf-8\":\n        case \"ascii\":\n        case \"latin1\":\n        case \"binary\":\n        case \"base64\":\n        case \"ucs2\":\n        case \"ucs-2\":\n        case \"utf16le\":\n        case \"utf-16le\":\n          return true;\n        default:\n          return false;\n      }\n    };\n    Buffer3.concat = function concat(list, length) {\n      if (!Array.isArray(list)) {\n        throw new TypeError('\"list\" argument must be an Array of Buffers');\n      }\n      if (list.length === 0) {\n        return Buffer3.alloc(0);\n      }\n      let i;\n      if (length === void 0) {\n        length = 0;\n        for (i = 0; i < list.length; ++i) {\n          length += list[i].length;\n        }\n      }\n      const buffer = Buffer3.allocUnsafe(length);\n      let pos = 0;\n      for (i = 0; i < list.length; ++i) {\n        let buf = list[i];\n        if (isInstance(buf, Uint8Array)) {\n          if (pos + buf.length > buffer.length) {\n            if (!Buffer3.isBuffer(buf))\n              buf = Buffer3.from(buf);\n            buf.copy(buffer, pos);\n          } else {\n            Uint8Array.prototype.set.call(buffer, buf, pos);\n          }\n        } else if (!Buffer3.isBuffer(buf)) {\n          throw new TypeError('\"list\" argument must be an Array of Buffers');\n        } else {\n          buf.copy(buffer, pos);\n        }\n        pos += buf.length;\n      }\n      return buffer;\n    };\n    function byteLength(string2, encoding) {\n      if (Buffer3.isBuffer(string2)) {\n        return string2.length;\n      }\n      if (ArrayBuffer.isView(string2) || isInstance(string2, ArrayBuffer)) {\n        return string2.byteLength;\n      }\n      if (typeof string2 !== \"string\") {\n        throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string2);\n      }\n      const len = string2.length;\n      const mustMatch = arguments.length > 2 && arguments[2] === true;\n      if (!mustMatch && len === 0)\n        return 0;\n      let loweredCase = false;\n      for (; ; ) {\n        switch (encoding) {\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n            return len;\n          case \"utf8\":\n          case \"utf-8\":\n            return utf8ToBytes2(string2).length;\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return len * 2;\n          case \"hex\":\n            return len >>> 1;\n          case \"base64\":\n            return base64ToBytes(string2).length;\n          default:\n            if (loweredCase) {\n              return mustMatch ? -1 : utf8ToBytes2(string2).length;\n            }\n            encoding = (\"\" + encoding).toLowerCase();\n            loweredCase = true;\n        }\n      }\n    }\n    Buffer3.byteLength = byteLength;\n    function slowToString(encoding, start, end) {\n      let loweredCase = false;\n      if (start === void 0 || start < 0) {\n        start = 0;\n      }\n      if (start > this.length) {\n        return \"\";\n      }\n      if (end === void 0 || end > this.length) {\n        end = this.length;\n      }\n      if (end <= 0) {\n        return \"\";\n      }\n      end >>>= 0;\n      start >>>= 0;\n      if (end <= start) {\n        return \"\";\n      }\n      if (!encoding)\n        encoding = \"utf8\";\n      while (true) {\n        switch (encoding) {\n          case \"hex\":\n            return hexSlice(this, start, end);\n          case \"utf8\":\n          case \"utf-8\":\n            return utf8Slice(this, start, end);\n          case \"ascii\":\n            return asciiSlice(this, start, end);\n          case \"latin1\":\n          case \"binary\":\n            return latin1Slice(this, start, end);\n          case \"base64\":\n            return base64Slice(this, start, end);\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return utf16leSlice(this, start, end);\n          default:\n            if (loweredCase)\n              throw new TypeError(\"Unknown encoding: \" + encoding);\n            encoding = (encoding + \"\").toLowerCase();\n            loweredCase = true;\n        }\n      }\n    }\n    Buffer3.prototype._isBuffer = true;\n    function swap(b, n, m) {\n      const i = b[n];\n      b[n] = b[m];\n      b[m] = i;\n    }\n    Buffer3.prototype.swap16 = function swap16() {\n      const len = this.length;\n      if (len % 2 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 16-bits\");\n      }\n      for (let i = 0; i < len; i += 2) {\n        swap(this, i, i + 1);\n      }\n      return this;\n    };\n    Buffer3.prototype.swap32 = function swap32() {\n      const len = this.length;\n      if (len % 4 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 32-bits\");\n      }\n      for (let i = 0; i < len; i += 4) {\n        swap(this, i, i + 3);\n        swap(this, i + 1, i + 2);\n      }\n      return this;\n    };\n    Buffer3.prototype.swap64 = function swap64() {\n      const len = this.length;\n      if (len % 8 !== 0) {\n        throw new RangeError(\"Buffer size must be a multiple of 64-bits\");\n      }\n      for (let i = 0; i < len; i += 8) {\n        swap(this, i, i + 7);\n        swap(this, i + 1, i + 6);\n        swap(this, i + 2, i + 5);\n        swap(this, i + 3, i + 4);\n      }\n      return this;\n    };\n    Buffer3.prototype.toString = function toString() {\n      const length = this.length;\n      if (length === 0)\n        return \"\";\n      if (arguments.length === 0)\n        return utf8Slice(this, 0, length);\n      return slowToString.apply(this, arguments);\n    };\n    Buffer3.prototype.toLocaleString = Buffer3.prototype.toString;\n    Buffer3.prototype.equals = function equals(b) {\n      if (!Buffer3.isBuffer(b))\n        throw new TypeError(\"Argument must be a Buffer\");\n      if (this === b)\n        return true;\n      return Buffer3.compare(this, b) === 0;\n    };\n    Buffer3.prototype.inspect = function inspect() {\n      let str = \"\";\n      const max = exports.INSPECT_MAX_BYTES;\n      str = this.toString(\"hex\", 0, max).replace(/(.{2})/g, \"$1 \").trim();\n      if (this.length > max)\n        str += \" ... \";\n      return \"<Buffer \" + str + \">\";\n    };\n    if (customInspectSymbol) {\n      Buffer3.prototype[customInspectSymbol] = Buffer3.prototype.inspect;\n    }\n    Buffer3.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {\n      if (isInstance(target, Uint8Array)) {\n        target = Buffer3.from(target, target.offset, target.byteLength);\n      }\n      if (!Buffer3.isBuffer(target)) {\n        throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);\n      }\n      if (start === void 0) {\n        start = 0;\n      }\n      if (end === void 0) {\n        end = target ? target.length : 0;\n      }\n      if (thisStart === void 0) {\n        thisStart = 0;\n      }\n      if (thisEnd === void 0) {\n        thisEnd = this.length;\n      }\n      if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n        throw new RangeError(\"out of range index\");\n      }\n      if (thisStart >= thisEnd && start >= end) {\n        return 0;\n      }\n      if (thisStart >= thisEnd) {\n        return -1;\n      }\n      if (start >= end) {\n        return 1;\n      }\n      start >>>= 0;\n      end >>>= 0;\n      thisStart >>>= 0;\n      thisEnd >>>= 0;\n      if (this === target)\n        return 0;\n      let x = thisEnd - thisStart;\n      let y = end - start;\n      const len = Math.min(x, y);\n      const thisCopy = this.slice(thisStart, thisEnd);\n      const targetCopy = target.slice(start, end);\n      for (let i = 0; i < len; ++i) {\n        if (thisCopy[i] !== targetCopy[i]) {\n          x = thisCopy[i];\n          y = targetCopy[i];\n          break;\n        }\n      }\n      if (x < y)\n        return -1;\n      if (y < x)\n        return 1;\n      return 0;\n    };\n    function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {\n      if (buffer.length === 0)\n        return -1;\n      if (typeof byteOffset === \"string\") {\n        encoding = byteOffset;\n        byteOffset = 0;\n      } else if (byteOffset > 2147483647) {\n        byteOffset = 2147483647;\n      } else if (byteOffset < -2147483648) {\n        byteOffset = -2147483648;\n      }\n      byteOffset = +byteOffset;\n      if (numberIsNaN(byteOffset)) {\n        byteOffset = dir ? 0 : buffer.length - 1;\n      }\n      if (byteOffset < 0)\n        byteOffset = buffer.length + byteOffset;\n      if (byteOffset >= buffer.length) {\n        if (dir)\n          return -1;\n        else\n          byteOffset = buffer.length - 1;\n      } else if (byteOffset < 0) {\n        if (dir)\n          byteOffset = 0;\n        else\n          return -1;\n      }\n      if (typeof val === \"string\") {\n        val = Buffer3.from(val, encoding);\n      }\n      if (Buffer3.isBuffer(val)) {\n        if (val.length === 0) {\n          return -1;\n        }\n        return arrayIndexOf(buffer, val, byteOffset, encoding, dir);\n      } else if (typeof val === \"number\") {\n        val = val & 255;\n        if (typeof Uint8Array.prototype.indexOf === \"function\") {\n          if (dir) {\n            return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);\n          } else {\n            return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);\n          }\n        }\n        return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);\n      }\n      throw new TypeError(\"val must be string, number or Buffer\");\n    }\n    function arrayIndexOf(arr, val, byteOffset, encoding, dir) {\n      let indexSize = 1;\n      let arrLength = arr.length;\n      let valLength = val.length;\n      if (encoding !== void 0) {\n        encoding = String(encoding).toLowerCase();\n        if (encoding === \"ucs2\" || encoding === \"ucs-2\" || encoding === \"utf16le\" || encoding === \"utf-16le\") {\n          if (arr.length < 2 || val.length < 2) {\n            return -1;\n          }\n          indexSize = 2;\n          arrLength /= 2;\n          valLength /= 2;\n          byteOffset /= 2;\n        }\n      }\n      function read(buf, i2) {\n        if (indexSize === 1) {\n          return buf[i2];\n        } else {\n          return buf.readUInt16BE(i2 * indexSize);\n        }\n      }\n      let i;\n      if (dir) {\n        let foundIndex = -1;\n        for (i = byteOffset; i < arrLength; i++) {\n          if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n            if (foundIndex === -1)\n              foundIndex = i;\n            if (i - foundIndex + 1 === valLength)\n              return foundIndex * indexSize;\n          } else {\n            if (foundIndex !== -1)\n              i -= i - foundIndex;\n            foundIndex = -1;\n          }\n        }\n      } else {\n        if (byteOffset + valLength > arrLength)\n          byteOffset = arrLength - valLength;\n        for (i = byteOffset; i >= 0; i--) {\n          let found = true;\n          for (let j = 0; j < valLength; j++) {\n            if (read(arr, i + j) !== read(val, j)) {\n              found = false;\n              break;\n            }\n          }\n          if (found)\n            return i;\n        }\n      }\n      return -1;\n    }\n    Buffer3.prototype.includes = function includes(val, byteOffset, encoding) {\n      return this.indexOf(val, byteOffset, encoding) !== -1;\n    };\n    Buffer3.prototype.indexOf = function indexOf(val, byteOffset, encoding) {\n      return bidirectionalIndexOf(this, val, byteOffset, encoding, true);\n    };\n    Buffer3.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {\n      return bidirectionalIndexOf(this, val, byteOffset, encoding, false);\n    };\n    function hexWrite(buf, string2, offset2, length) {\n      offset2 = Number(offset2) || 0;\n      const remaining = buf.length - offset2;\n      if (!length) {\n        length = remaining;\n      } else {\n        length = Number(length);\n        if (length > remaining) {\n          length = remaining;\n        }\n      }\n      const strLen = string2.length;\n      if (length > strLen / 2) {\n        length = strLen / 2;\n      }\n      let i;\n      for (i = 0; i < length; ++i) {\n        const parsed = parseInt(string2.substr(i * 2, 2), 16);\n        if (numberIsNaN(parsed))\n          return i;\n        buf[offset2 + i] = parsed;\n      }\n      return i;\n    }\n    function utf8Write(buf, string2, offset2, length) {\n      return blitBuffer(utf8ToBytes2(string2, buf.length - offset2), buf, offset2, length);\n    }\n    function asciiWrite(buf, string2, offset2, length) {\n      return blitBuffer(asciiToBytes(string2), buf, offset2, length);\n    }\n    function base64Write(buf, string2, offset2, length) {\n      return blitBuffer(base64ToBytes(string2), buf, offset2, length);\n    }\n    function ucs2Write(buf, string2, offset2, length) {\n      return blitBuffer(utf16leToBytes(string2, buf.length - offset2), buf, offset2, length);\n    }\n    Buffer3.prototype.write = function write(string2, offset2, length, encoding) {\n      if (offset2 === void 0) {\n        encoding = \"utf8\";\n        length = this.length;\n        offset2 = 0;\n      } else if (length === void 0 && typeof offset2 === \"string\") {\n        encoding = offset2;\n        length = this.length;\n        offset2 = 0;\n      } else if (isFinite(offset2)) {\n        offset2 = offset2 >>> 0;\n        if (isFinite(length)) {\n          length = length >>> 0;\n          if (encoding === void 0)\n            encoding = \"utf8\";\n        } else {\n          encoding = length;\n          length = void 0;\n        }\n      } else {\n        throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");\n      }\n      const remaining = this.length - offset2;\n      if (length === void 0 || length > remaining)\n        length = remaining;\n      if (string2.length > 0 && (length < 0 || offset2 < 0) || offset2 > this.length) {\n        throw new RangeError(\"Attempt to write outside buffer bounds\");\n      }\n      if (!encoding)\n        encoding = \"utf8\";\n      let loweredCase = false;\n      for (; ; ) {\n        switch (encoding) {\n          case \"hex\":\n            return hexWrite(this, string2, offset2, length);\n          case \"utf8\":\n          case \"utf-8\":\n            return utf8Write(this, string2, offset2, length);\n          case \"ascii\":\n          case \"latin1\":\n          case \"binary\":\n            return asciiWrite(this, string2, offset2, length);\n          case \"base64\":\n            return base64Write(this, string2, offset2, length);\n          case \"ucs2\":\n          case \"ucs-2\":\n          case \"utf16le\":\n          case \"utf-16le\":\n            return ucs2Write(this, string2, offset2, length);\n          default:\n            if (loweredCase)\n              throw new TypeError(\"Unknown encoding: \" + encoding);\n            encoding = (\"\" + encoding).toLowerCase();\n            loweredCase = true;\n        }\n      }\n    };\n    Buffer3.prototype.toJSON = function toJSON() {\n      return {\n        type: \"Buffer\",\n        data: Array.prototype.slice.call(this._arr || this, 0)\n      };\n    };\n    function base64Slice(buf, start, end) {\n      if (start === 0 && end === buf.length) {\n        return base64.fromByteArray(buf);\n      } else {\n        return base64.fromByteArray(buf.slice(start, end));\n      }\n    }\n    function utf8Slice(buf, start, end) {\n      end = Math.min(buf.length, end);\n      const res = [];\n      let i = start;\n      while (i < end) {\n        const firstByte = buf[i];\n        let codePoint = null;\n        let bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;\n        if (i + bytesPerSequence <= end) {\n          let secondByte, thirdByte, fourthByte, tempCodePoint;\n          switch (bytesPerSequence) {\n            case 1:\n              if (firstByte < 128) {\n                codePoint = firstByte;\n              }\n              break;\n            case 2:\n              secondByte = buf[i + 1];\n              if ((secondByte & 192) === 128) {\n                tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;\n                if (tempCodePoint > 127) {\n                  codePoint = tempCodePoint;\n                }\n              }\n              break;\n            case 3:\n              secondByte = buf[i + 1];\n              thirdByte = buf[i + 2];\n              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {\n                tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;\n                if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {\n                  codePoint = tempCodePoint;\n                }\n              }\n              break;\n            case 4:\n              secondByte = buf[i + 1];\n              thirdByte = buf[i + 2];\n              fourthByte = buf[i + 3];\n              if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {\n                tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;\n                if (tempCodePoint > 65535 && tempCodePoint < 1114112) {\n                  codePoint = tempCodePoint;\n                }\n              }\n          }\n        }\n        if (codePoint === null) {\n          codePoint = 65533;\n          bytesPerSequence = 1;\n        } else if (codePoint > 65535) {\n          codePoint -= 65536;\n          res.push(codePoint >>> 10 & 1023 | 55296);\n          codePoint = 56320 | codePoint & 1023;\n        }\n        res.push(codePoint);\n        i += bytesPerSequence;\n      }\n      return decodeCodePointsArray(res);\n    }\n    const MAX_ARGUMENTS_LENGTH = 4096;\n    function decodeCodePointsArray(codePoints) {\n      const len = codePoints.length;\n      if (len <= MAX_ARGUMENTS_LENGTH) {\n        return String.fromCharCode.apply(String, codePoints);\n      }\n      let res = \"\";\n      let i = 0;\n      while (i < len) {\n        res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));\n      }\n      return res;\n    }\n    function asciiSlice(buf, start, end) {\n      let ret = \"\";\n      end = Math.min(buf.length, end);\n      for (let i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i] & 127);\n      }\n      return ret;\n    }\n    function latin1Slice(buf, start, end) {\n      let ret = \"\";\n      end = Math.min(buf.length, end);\n      for (let i = start; i < end; ++i) {\n        ret += String.fromCharCode(buf[i]);\n      }\n      return ret;\n    }\n    function hexSlice(buf, start, end) {\n      const len = buf.length;\n      if (!start || start < 0)\n        start = 0;\n      if (!end || end < 0 || end > len)\n        end = len;\n      let out = \"\";\n      for (let i = start; i < end; ++i) {\n        out += hexSliceLookupTable[buf[i]];\n      }\n      return out;\n    }\n    function utf16leSlice(buf, start, end) {\n      const bytes = buf.slice(start, end);\n      let res = \"\";\n      for (let i = 0; i < bytes.length - 1; i += 2) {\n        res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);\n      }\n      return res;\n    }\n    Buffer3.prototype.slice = function slice(start, end) {\n      const len = this.length;\n      start = ~~start;\n      end = end === void 0 ? len : ~~end;\n      if (start < 0) {\n        start += len;\n        if (start < 0)\n          start = 0;\n      } else if (start > len) {\n        start = len;\n      }\n      if (end < 0) {\n        end += len;\n        if (end < 0)\n          end = 0;\n      } else if (end > len) {\n        end = len;\n      }\n      if (end < start)\n        end = start;\n      const newBuf = this.subarray(start, end);\n      Object.setPrototypeOf(newBuf, Buffer3.prototype);\n      return newBuf;\n    };\n    function checkOffset(offset2, ext, length) {\n      if (offset2 % 1 !== 0 || offset2 < 0)\n        throw new RangeError(\"offset is not uint\");\n      if (offset2 + ext > length)\n        throw new RangeError(\"Trying to access beyond buffer length\");\n    }\n    Buffer3.prototype.readUintLE = Buffer3.prototype.readUIntLE = function readUIntLE(offset2, byteLength2, noAssert) {\n      offset2 = offset2 >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert)\n        checkOffset(offset2, byteLength2, this.length);\n      let val = this[offset2];\n      let mul = 1;\n      let i = 0;\n      while (++i < byteLength2 && (mul *= 256)) {\n        val += this[offset2 + i] * mul;\n      }\n      return val;\n    };\n    Buffer3.prototype.readUintBE = Buffer3.prototype.readUIntBE = function readUIntBE(offset2, byteLength2, noAssert) {\n      offset2 = offset2 >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) {\n        checkOffset(offset2, byteLength2, this.length);\n      }\n      let val = this[offset2 + --byteLength2];\n      let mul = 1;\n      while (byteLength2 > 0 && (mul *= 256)) {\n        val += this[offset2 + --byteLength2] * mul;\n      }\n      return val;\n    };\n    Buffer3.prototype.readUint8 = Buffer3.prototype.readUInt8 = function readUInt8(offset2, noAssert) {\n      offset2 = offset2 >>> 0;\n      if (!noAssert)\n        checkOffset(offset2, 1, this.length);\n      return this[offset2];\n    };\n    Buffer3.prototype.readUint16LE = Buffer3.prototype.readUInt16LE = function readUInt16LE(offset2, noAssert) {\n      offset2 = offset2 >>> 0;\n      if (!noAssert)\n        checkOffset(offset2, 2, this.length);\n      return this[offset2] | this[offset2 + 1] << 8;\n    };\n    Buffer3.prototype.readUint16BE = Buffer3.prototype.readUInt16BE = function readUInt16BE(offset2, noAssert) {\n      offset2 = offset2 >>> 0;\n      if (!noAssert)\n        checkOffset(offset2, 2, this.length);\n      return this[offset2] << 8 | this[offset2 + 1];\n    };\n    Buffer3.prototype.readUint32LE = Buffer3.prototype.readUInt32LE = function readUInt32LE(offset2, noAssert) {\n      offset2 = offset2 >>> 0;\n      if (!noAssert)\n        checkOffset(offset2, 4, this.length);\n      return (this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16) + this[offset2 + 3] * 16777216;\n    };\n    Buffer3.prototype.readUint32BE = Buffer3.prototype.readUInt32BE = function readUInt32BE(offset2, noAssert) {\n      offset2 = offset2 >>> 0;\n      if (!noAssert)\n        checkOffset(offset2, 4, this.length);\n      return this[offset2] * 16777216 + (this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3]);\n    };\n    Buffer3.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset2) {\n      offset2 = offset2 >>> 0;\n      validateNumber(offset2, \"offset\");\n      const first = this[offset2];\n      const last = this[offset2 + 7];\n      if (first === void 0 || last === void 0) {\n        boundsError(offset2, this.length - 8);\n      }\n      const lo = first + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24;\n      const hi = this[++offset2] + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + last * 2 ** 24;\n      return BigInt(lo) + (BigInt(hi) << BigInt(32));\n    });\n    Buffer3.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset2) {\n      offset2 = offset2 >>> 0;\n      validateNumber(offset2, \"offset\");\n      const first = this[offset2];\n      const last = this[offset2 + 7];\n      if (first === void 0 || last === void 0) {\n        boundsError(offset2, this.length - 8);\n      }\n      const hi = first * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];\n      const lo = this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last;\n      return (BigInt(hi) << BigInt(32)) + BigInt(lo);\n    });\n    Buffer3.prototype.readIntLE = function readIntLE(offset2, byteLength2, noAssert) {\n      offset2 = offset2 >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert)\n        checkOffset(offset2, byteLength2, this.length);\n      let val = this[offset2];\n      let mul = 1;\n      let i = 0;\n      while (++i < byteLength2 && (mul *= 256)) {\n        val += this[offset2 + i] * mul;\n      }\n      mul *= 128;\n      if (val >= mul)\n        val -= Math.pow(2, 8 * byteLength2);\n      return val;\n    };\n    Buffer3.prototype.readIntBE = function readIntBE(offset2, byteLength2, noAssert) {\n      offset2 = offset2 >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert)\n        checkOffset(offset2, byteLength2, this.length);\n      let i = byteLength2;\n      let mul = 1;\n      let val = this[offset2 + --i];\n      while (i > 0 && (mul *= 256)) {\n        val += this[offset2 + --i] * mul;\n      }\n      mul *= 128;\n      if (val >= mul)\n        val -= Math.pow(2, 8 * byteLength2);\n      return val;\n    };\n    Buffer3.prototype.readInt8 = function readInt8(offset2, noAssert) {\n      offset2 = offset2 >>> 0;\n      if (!noAssert)\n        checkOffset(offset2, 1, this.length);\n      if (!(this[offset2] & 128))\n        return this[offset2];\n      return (255 - this[offset2] + 1) * -1;\n    };\n    Buffer3.prototype.readInt16LE = function readInt16LE(offset2, noAssert) {\n      offset2 = offset2 >>> 0;\n      if (!noAssert)\n        checkOffset(offset2, 2, this.length);\n      const val = this[offset2] | this[offset2 + 1] << 8;\n      return val & 32768 ? val | 4294901760 : val;\n    };\n    Buffer3.prototype.readInt16BE = function readInt16BE(offset2, noAssert) {\n      offset2 = offset2 >>> 0;\n      if (!noAssert)\n        checkOffset(offset2, 2, this.length);\n      const val = this[offset2 + 1] | this[offset2] << 8;\n      return val & 32768 ? val | 4294901760 : val;\n    };\n    Buffer3.prototype.readInt32LE = function readInt32LE(offset2, noAssert) {\n      offset2 = offset2 >>> 0;\n      if (!noAssert)\n        checkOffset(offset2, 4, this.length);\n      return this[offset2] | this[offset2 + 1] << 8 | this[offset2 + 2] << 16 | this[offset2 + 3] << 24;\n    };\n    Buffer3.prototype.readInt32BE = function readInt32BE(offset2, noAssert) {\n      offset2 = offset2 >>> 0;\n      if (!noAssert)\n        checkOffset(offset2, 4, this.length);\n      return this[offset2] << 24 | this[offset2 + 1] << 16 | this[offset2 + 2] << 8 | this[offset2 + 3];\n    };\n    Buffer3.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset2) {\n      offset2 = offset2 >>> 0;\n      validateNumber(offset2, \"offset\");\n      const first = this[offset2];\n      const last = this[offset2 + 7];\n      if (first === void 0 || last === void 0) {\n        boundsError(offset2, this.length - 8);\n      }\n      const val = this[offset2 + 4] + this[offset2 + 5] * 2 ** 8 + this[offset2 + 6] * 2 ** 16 + (last << 24);\n      return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset2] * 2 ** 8 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 24);\n    });\n    Buffer3.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset2) {\n      offset2 = offset2 >>> 0;\n      validateNumber(offset2, \"offset\");\n      const first = this[offset2];\n      const last = this[offset2 + 7];\n      if (first === void 0 || last === void 0) {\n        boundsError(offset2, this.length - 8);\n      }\n      const val = (first << 24) + // Overflow\n      this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + this[++offset2];\n      return (BigInt(val) << BigInt(32)) + BigInt(this[++offset2] * 2 ** 24 + this[++offset2] * 2 ** 16 + this[++offset2] * 2 ** 8 + last);\n    });\n    Buffer3.prototype.readFloatLE = function readFloatLE(offset2, noAssert) {\n      offset2 = offset2 >>> 0;\n      if (!noAssert)\n        checkOffset(offset2, 4, this.length);\n      return ieee754.read(this, offset2, true, 23, 4);\n    };\n    Buffer3.prototype.readFloatBE = function readFloatBE(offset2, noAssert) {\n      offset2 = offset2 >>> 0;\n      if (!noAssert)\n        checkOffset(offset2, 4, this.length);\n      return ieee754.read(this, offset2, false, 23, 4);\n    };\n    Buffer3.prototype.readDoubleLE = function readDoubleLE(offset2, noAssert) {\n      offset2 = offset2 >>> 0;\n      if (!noAssert)\n        checkOffset(offset2, 8, this.length);\n      return ieee754.read(this, offset2, true, 52, 8);\n    };\n    Buffer3.prototype.readDoubleBE = function readDoubleBE(offset2, noAssert) {\n      offset2 = offset2 >>> 0;\n      if (!noAssert)\n        checkOffset(offset2, 8, this.length);\n      return ieee754.read(this, offset2, false, 52, 8);\n    };\n    function checkInt(buf, value, offset2, ext, max, min) {\n      if (!Buffer3.isBuffer(buf))\n        throw new TypeError('\"buffer\" argument must be a Buffer instance');\n      if (value > max || value < min)\n        throw new RangeError('\"value\" argument is out of bounds');\n      if (offset2 + ext > buf.length)\n        throw new RangeError(\"Index out of range\");\n    }\n    Buffer3.prototype.writeUintLE = Buffer3.prototype.writeUIntLE = function writeUIntLE(value, offset2, byteLength2, noAssert) {\n      value = +value;\n      offset2 = offset2 >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) {\n        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n        checkInt(this, value, offset2, byteLength2, maxBytes, 0);\n      }\n      let mul = 1;\n      let i = 0;\n      this[offset2] = value & 255;\n      while (++i < byteLength2 && (mul *= 256)) {\n        this[offset2 + i] = value / mul & 255;\n      }\n      return offset2 + byteLength2;\n    };\n    Buffer3.prototype.writeUintBE = Buffer3.prototype.writeUIntBE = function writeUIntBE(value, offset2, byteLength2, noAssert) {\n      value = +value;\n      offset2 = offset2 >>> 0;\n      byteLength2 = byteLength2 >>> 0;\n      if (!noAssert) {\n        const maxBytes = Math.pow(2, 8 * byteLength2) - 1;\n        checkInt(this, value, offset2, byteLength2, maxBytes, 0);\n      }\n      let i = byteLength2 - 1;\n      let mul = 1;\n      this[offset2 + i] = value & 255;\n      while (--i >= 0 && (mul *= 256)) {\n        this[offset2 + i] = value / mul & 255;\n      }\n      return offset2 + byteLength2;\n    };\n    Buffer3.prototype.writeUint8 = Buffer3.prototype.writeUInt8 = function writeUInt8(value, offset2, noAssert) {\n      value = +value;\n      offset2 = offset2 >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset2, 1, 255, 0);\n      this[offset2] = value & 255;\n      return offset2 + 1;\n    };\n    Buffer3.prototype.writeUint16LE = Buffer3.prototype.writeUInt16LE = function writeUInt16LE(value, offset2, noAssert) {\n      value = +value;\n      offset2 = offset2 >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset2, 2, 65535, 0);\n      this[offset2] = value & 255;\n      this[offset2 + 1] = value >>> 8;\n      return offset2 + 2;\n    };\n    Buffer3.prototype.writeUint16BE = Buffer3.prototype.writeUInt16BE = function writeUInt16BE(value, offset2, noAssert) {\n      value = +value;\n      offset2 = offset2 >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset2, 2, 65535, 0);\n      this[offset2] = value >>> 8;\n      this[offset2 + 1] = value & 255;\n      return offset2 + 2;\n    };\n    Buffer3.prototype.writeUint32LE = Buffer3.prototype.writeUInt32LE = function writeUInt32LE(value, offset2, noAssert) {\n      value = +value;\n      offset2 = offset2 >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset2, 4, 4294967295, 0);\n      this[offset2 + 3] = value >>> 24;\n      this[offset2 + 2] = value >>> 16;\n      this[offset2 + 1] = value >>> 8;\n      this[offset2] = value & 255;\n      return offset2 + 4;\n    };\n    Buffer3.prototype.writeUint32BE = Buffer3.prototype.writeUInt32BE = function writeUInt32BE(value, offset2, noAssert) {\n      value = +value;\n      offset2 = offset2 >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset2, 4, 4294967295, 0);\n      this[offset2] = value >>> 24;\n      this[offset2 + 1] = value >>> 16;\n      this[offset2 + 2] = value >>> 8;\n      this[offset2 + 3] = value & 255;\n      return offset2 + 4;\n    };\n    function wrtBigUInt64LE(buf, value, offset2, min, max) {\n      checkIntBI(value, min, max, buf, offset2, 7);\n      let lo = Number(value & BigInt(4294967295));\n      buf[offset2++] = lo;\n      lo = lo >> 8;\n      buf[offset2++] = lo;\n      lo = lo >> 8;\n      buf[offset2++] = lo;\n      lo = lo >> 8;\n      buf[offset2++] = lo;\n      let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n      buf[offset2++] = hi;\n      hi = hi >> 8;\n      buf[offset2++] = hi;\n      hi = hi >> 8;\n      buf[offset2++] = hi;\n      hi = hi >> 8;\n      buf[offset2++] = hi;\n      return offset2;\n    }\n    function wrtBigUInt64BE(buf, value, offset2, min, max) {\n      checkIntBI(value, min, max, buf, offset2, 7);\n      let lo = Number(value & BigInt(4294967295));\n      buf[offset2 + 7] = lo;\n      lo = lo >> 8;\n      buf[offset2 + 6] = lo;\n      lo = lo >> 8;\n      buf[offset2 + 5] = lo;\n      lo = lo >> 8;\n      buf[offset2 + 4] = lo;\n      let hi = Number(value >> BigInt(32) & BigInt(4294967295));\n      buf[offset2 + 3] = hi;\n      hi = hi >> 8;\n      buf[offset2 + 2] = hi;\n      hi = hi >> 8;\n      buf[offset2 + 1] = hi;\n      hi = hi >> 8;\n      buf[offset2] = hi;\n      return offset2 + 8;\n    }\n    Buffer3.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value, offset2 = 0) {\n      return wrtBigUInt64LE(this, value, offset2, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n    });\n    Buffer3.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value, offset2 = 0) {\n      return wrtBigUInt64BE(this, value, offset2, BigInt(0), BigInt(\"0xffffffffffffffff\"));\n    });\n    Buffer3.prototype.writeIntLE = function writeIntLE(value, offset2, byteLength2, noAssert) {\n      value = +value;\n      offset2 = offset2 >>> 0;\n      if (!noAssert) {\n        const limit = Math.pow(2, 8 * byteLength2 - 1);\n        checkInt(this, value, offset2, byteLength2, limit - 1, -limit);\n      }\n      let i = 0;\n      let mul = 1;\n      let sub = 0;\n      this[offset2] = value & 255;\n      while (++i < byteLength2 && (mul *= 256)) {\n        if (value < 0 && sub === 0 && this[offset2 + i - 1] !== 0) {\n          sub = 1;\n        }\n        this[offset2 + i] = (value / mul >> 0) - sub & 255;\n      }\n      return offset2 + byteLength2;\n    };\n    Buffer3.prototype.writeIntBE = function writeIntBE(value, offset2, byteLength2, noAssert) {\n      value = +value;\n      offset2 = offset2 >>> 0;\n      if (!noAssert) {\n        const limit = Math.pow(2, 8 * byteLength2 - 1);\n        checkInt(this, value, offset2, byteLength2, limit - 1, -limit);\n      }\n      let i = byteLength2 - 1;\n      let mul = 1;\n      let sub = 0;\n      this[offset2 + i] = value & 255;\n      while (--i >= 0 && (mul *= 256)) {\n        if (value < 0 && sub === 0 && this[offset2 + i + 1] !== 0) {\n          sub = 1;\n        }\n        this[offset2 + i] = (value / mul >> 0) - sub & 255;\n      }\n      return offset2 + byteLength2;\n    };\n    Buffer3.prototype.writeInt8 = function writeInt8(value, offset2, noAssert) {\n      value = +value;\n      offset2 = offset2 >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset2, 1, 127, -128);\n      if (value < 0)\n        value = 255 + value + 1;\n      this[offset2] = value & 255;\n      return offset2 + 1;\n    };\n    Buffer3.prototype.writeInt16LE = function writeInt16LE(value, offset2, noAssert) {\n      value = +value;\n      offset2 = offset2 >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset2, 2, 32767, -32768);\n      this[offset2] = value & 255;\n      this[offset2 + 1] = value >>> 8;\n      return offset2 + 2;\n    };\n    Buffer3.prototype.writeInt16BE = function writeInt16BE(value, offset2, noAssert) {\n      value = +value;\n      offset2 = offset2 >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset2, 2, 32767, -32768);\n      this[offset2] = value >>> 8;\n      this[offset2 + 1] = value & 255;\n      return offset2 + 2;\n    };\n    Buffer3.prototype.writeInt32LE = function writeInt32LE(value, offset2, noAssert) {\n      value = +value;\n      offset2 = offset2 >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset2, 4, 2147483647, -2147483648);\n      this[offset2] = value & 255;\n      this[offset2 + 1] = value >>> 8;\n      this[offset2 + 2] = value >>> 16;\n      this[offset2 + 3] = value >>> 24;\n      return offset2 + 4;\n    };\n    Buffer3.prototype.writeInt32BE = function writeInt32BE(value, offset2, noAssert) {\n      value = +value;\n      offset2 = offset2 >>> 0;\n      if (!noAssert)\n        checkInt(this, value, offset2, 4, 2147483647, -2147483648);\n      if (value < 0)\n        value = 4294967295 + value + 1;\n      this[offset2] = value >>> 24;\n      this[offset2 + 1] = value >>> 16;\n      this[offset2 + 2] = value >>> 8;\n      this[offset2 + 3] = value & 255;\n      return offset2 + 4;\n    };\n    Buffer3.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value, offset2 = 0) {\n      return wrtBigUInt64LE(this, value, offset2, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n    });\n    Buffer3.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value, offset2 = 0) {\n      return wrtBigUInt64BE(this, value, offset2, -BigInt(\"0x8000000000000000\"), BigInt(\"0x7fffffffffffffff\"));\n    });\n    function checkIEEE754(buf, value, offset2, ext, max, min) {\n      if (offset2 + ext > buf.length)\n        throw new RangeError(\"Index out of range\");\n      if (offset2 < 0)\n        throw new RangeError(\"Index out of range\");\n    }\n    function writeFloat(buf, value, offset2, littleEndian, noAssert) {\n      value = +value;\n      offset2 = offset2 >>> 0;\n      if (!noAssert) {\n        checkIEEE754(buf, value, offset2, 4);\n      }\n      ieee754.write(buf, value, offset2, littleEndian, 23, 4);\n      return offset2 + 4;\n    }\n    Buffer3.prototype.writeFloatLE = function writeFloatLE(value, offset2, noAssert) {\n      return writeFloat(this, value, offset2, true, noAssert);\n    };\n    Buffer3.prototype.writeFloatBE = function writeFloatBE(value, offset2, noAssert) {\n      return writeFloat(this, value, offset2, false, noAssert);\n    };\n    function writeDouble(buf, value, offset2, littleEndian, noAssert) {\n      value = +value;\n      offset2 = offset2 >>> 0;\n      if (!noAssert) {\n        checkIEEE754(buf, value, offset2, 8);\n      }\n      ieee754.write(buf, value, offset2, littleEndian, 52, 8);\n      return offset2 + 8;\n    }\n    Buffer3.prototype.writeDoubleLE = function writeDoubleLE(value, offset2, noAssert) {\n      return writeDouble(this, value, offset2, true, noAssert);\n    };\n    Buffer3.prototype.writeDoubleBE = function writeDoubleBE(value, offset2, noAssert) {\n      return writeDouble(this, value, offset2, false, noAssert);\n    };\n    Buffer3.prototype.copy = function copy(target, targetStart, start, end) {\n      if (!Buffer3.isBuffer(target))\n        throw new TypeError(\"argument should be a Buffer\");\n      if (!start)\n        start = 0;\n      if (!end && end !== 0)\n        end = this.length;\n      if (targetStart >= target.length)\n        targetStart = target.length;\n      if (!targetStart)\n        targetStart = 0;\n      if (end > 0 && end < start)\n        end = start;\n      if (end === start)\n        return 0;\n      if (target.length === 0 || this.length === 0)\n        return 0;\n      if (targetStart < 0) {\n        throw new RangeError(\"targetStart out of bounds\");\n      }\n      if (start < 0 || start >= this.length)\n        throw new RangeError(\"Index out of range\");\n      if (end < 0)\n        throw new RangeError(\"sourceEnd out of bounds\");\n      if (end > this.length)\n        end = this.length;\n      if (target.length - targetStart < end - start) {\n        end = target.length - targetStart + start;\n      }\n      const len = end - start;\n      if (this === target && typeof Uint8Array.prototype.copyWithin === \"function\") {\n        this.copyWithin(targetStart, start, end);\n      } else {\n        Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);\n      }\n      return len;\n    };\n    Buffer3.prototype.fill = function fill(val, start, end, encoding) {\n      if (typeof val === \"string\") {\n        if (typeof start === \"string\") {\n          encoding = start;\n          start = 0;\n          end = this.length;\n        } else if (typeof end === \"string\") {\n          encoding = end;\n          end = this.length;\n        }\n        if (encoding !== void 0 && typeof encoding !== \"string\") {\n          throw new TypeError(\"encoding must be a string\");\n        }\n        if (typeof encoding === \"string\" && !Buffer3.isEncoding(encoding)) {\n          throw new TypeError(\"Unknown encoding: \" + encoding);\n        }\n        if (val.length === 1) {\n          const code = val.charCodeAt(0);\n          if (encoding === \"utf8\" && code < 128 || encoding === \"latin1\") {\n            val = code;\n          }\n        }\n      } else if (typeof val === \"number\") {\n        val = val & 255;\n      } else if (typeof val === \"boolean\") {\n        val = Number(val);\n      }\n      if (start < 0 || this.length < start || this.length < end) {\n        throw new RangeError(\"Out of range index\");\n      }\n      if (end <= start) {\n        return this;\n      }\n      start = start >>> 0;\n      end = end === void 0 ? this.length : end >>> 0;\n      if (!val)\n        val = 0;\n      let i;\n      if (typeof val === \"number\") {\n        for (i = start; i < end; ++i) {\n          this[i] = val;\n        }\n      } else {\n        const bytes = Buffer3.isBuffer(val) ? val : Buffer3.from(val, encoding);\n        const len = bytes.length;\n        if (len === 0) {\n          throw new TypeError('The value \"' + val + '\" is invalid for argument \"value\"');\n        }\n        for (i = 0; i < end - start; ++i) {\n          this[i + start] = bytes[i % len];\n        }\n      }\n      return this;\n    };\n    const errors = {};\n    function E(sym, getMessage, Base) {\n      errors[sym] = class NodeError extends Base {\n        constructor() {\n          super();\n          Object.defineProperty(this, \"message\", {\n            value: getMessage.apply(this, arguments),\n            writable: true,\n            configurable: true\n          });\n          this.name = `${this.name} [${sym}]`;\n          this.stack;\n          delete this.name;\n        }\n        get code() {\n          return sym;\n        }\n        set code(value) {\n          Object.defineProperty(this, \"code\", {\n            configurable: true,\n            enumerable: true,\n            value,\n            writable: true\n          });\n        }\n        toString() {\n          return `${this.name} [${sym}]: ${this.message}`;\n        }\n      };\n    }\n    E(\"ERR_BUFFER_OUT_OF_BOUNDS\", function(name) {\n      if (name) {\n        return `${name} is outside of buffer bounds`;\n      }\n      return \"Attempt to access memory outside buffer bounds\";\n    }, RangeError);\n    E(\"ERR_INVALID_ARG_TYPE\", function(name, actual) {\n      return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`;\n    }, TypeError);\n    E(\"ERR_OUT_OF_RANGE\", function(str, range, input) {\n      let msg = `The value of \"${str}\" is out of range.`;\n      let received = input;\n      if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n        received = addNumericalSeparator(String(input));\n      } else if (typeof input === \"bigint\") {\n        received = String(input);\n        if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n          received = addNumericalSeparator(received);\n        }\n        received += \"n\";\n      }\n      msg += ` It must be ${range}. Received ${received}`;\n      return msg;\n    }, RangeError);\n    function addNumericalSeparator(val) {\n      let res = \"\";\n      let i = val.length;\n      const start = val[0] === \"-\" ? 1 : 0;\n      for (; i >= start + 4; i -= 3) {\n        res = `_${val.slice(i - 3, i)}${res}`;\n      }\n      return `${val.slice(0, i)}${res}`;\n    }\n    function checkBounds(buf, offset2, byteLength2) {\n      validateNumber(offset2, \"offset\");\n      if (buf[offset2] === void 0 || buf[offset2 + byteLength2] === void 0) {\n        boundsError(offset2, buf.length - (byteLength2 + 1));\n      }\n    }\n    function checkIntBI(value, min, max, buf, offset2, byteLength2) {\n      if (value > max || value < min) {\n        const n = typeof min === \"bigint\" ? \"n\" : \"\";\n        let range;\n        {\n          if (min === 0 || min === BigInt(0)) {\n            range = `>= 0${n} and < 2${n} ** ${(byteLength2 + 1) * 8}${n}`;\n          } else {\n            range = `>= -(2${n} ** ${(byteLength2 + 1) * 8 - 1}${n}) and < 2 ** ${(byteLength2 + 1) * 8 - 1}${n}`;\n          }\n        }\n        throw new errors.ERR_OUT_OF_RANGE(\"value\", range, value);\n      }\n      checkBounds(buf, offset2, byteLength2);\n    }\n    function validateNumber(value, name) {\n      if (typeof value !== \"number\") {\n        throw new errors.ERR_INVALID_ARG_TYPE(name, \"number\", value);\n      }\n    }\n    function boundsError(value, length, type2) {\n      if (Math.floor(value) !== value) {\n        validateNumber(value, type2);\n        throw new errors.ERR_OUT_OF_RANGE(\"offset\", \"an integer\", value);\n      }\n      if (length < 0) {\n        throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();\n      }\n      throw new errors.ERR_OUT_OF_RANGE(\"offset\", `>= ${0} and <= ${length}`, value);\n    }\n    const INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;\n    function base64clean(str) {\n      str = str.split(\"=\")[0];\n      str = str.trim().replace(INVALID_BASE64_RE, \"\");\n      if (str.length < 2)\n        return \"\";\n      while (str.length % 4 !== 0) {\n        str = str + \"=\";\n      }\n      return str;\n    }\n    function utf8ToBytes2(string2, units) {\n      units = units || Infinity;\n      let codePoint;\n      const length = string2.length;\n      let leadSurrogate = null;\n      const bytes = [];\n      for (let i = 0; i < length; ++i) {\n        codePoint = string2.charCodeAt(i);\n        if (codePoint > 55295 && codePoint < 57344) {\n          if (!leadSurrogate) {\n            if (codePoint > 56319) {\n              if ((units -= 3) > -1)\n                bytes.push(239, 191, 189);\n              continue;\n            } else if (i + 1 === length) {\n              if ((units -= 3) > -1)\n                bytes.push(239, 191, 189);\n              continue;\n            }\n            leadSurrogate = codePoint;\n            continue;\n          }\n          if (codePoint < 56320) {\n            if ((units -= 3) > -1)\n              bytes.push(239, 191, 189);\n            leadSurrogate = codePoint;\n            continue;\n          }\n          codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;\n        } else if (leadSurrogate) {\n          if ((units -= 3) > -1)\n            bytes.push(239, 191, 189);\n        }\n        leadSurrogate = null;\n        if (codePoint < 128) {\n          if ((units -= 1) < 0)\n            break;\n          bytes.push(codePoint);\n        } else if (codePoint < 2048) {\n          if ((units -= 2) < 0)\n            break;\n          bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);\n        } else if (codePoint < 65536) {\n          if ((units -= 3) < 0)\n            break;\n          bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n        } else if (codePoint < 1114112) {\n          if ((units -= 4) < 0)\n            break;\n          bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);\n        } else {\n          throw new Error(\"Invalid code point\");\n        }\n      }\n      return bytes;\n    }\n    function asciiToBytes(str) {\n      const byteArray = [];\n      for (let i = 0; i < str.length; ++i) {\n        byteArray.push(str.charCodeAt(i) & 255);\n      }\n      return byteArray;\n    }\n    function utf16leToBytes(str, units) {\n      let c, hi, lo;\n      const byteArray = [];\n      for (let i = 0; i < str.length; ++i) {\n        if ((units -= 2) < 0)\n          break;\n        c = str.charCodeAt(i);\n        hi = c >> 8;\n        lo = c % 256;\n        byteArray.push(lo);\n        byteArray.push(hi);\n      }\n      return byteArray;\n    }\n    function base64ToBytes(str) {\n      return base64.toByteArray(base64clean(str));\n    }\n    function blitBuffer(src, dst, offset2, length) {\n      let i;\n      for (i = 0; i < length; ++i) {\n        if (i + offset2 >= dst.length || i >= src.length)\n          break;\n        dst[i + offset2] = src[i];\n      }\n      return i;\n    }\n    function isInstance(obj, type2) {\n      return obj instanceof type2 || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type2.name;\n    }\n    function numberIsNaN(obj) {\n      return obj !== obj;\n    }\n    const hexSliceLookupTable = function() {\n      const alphabet = \"0123456789abcdef\";\n      const table = new Array(256);\n      for (let i = 0; i < 16; ++i) {\n        const i16 = i * 16;\n        for (let j = 0; j < 16; ++j) {\n          table[i16 + j] = alphabet[i] + alphabet[j];\n        }\n      }\n      return table;\n    }();\n    function defineBigIntMethod(fn) {\n      return typeof BigInt === \"undefined\" ? BufferBigIntNotDefined : fn;\n    }\n    function BufferBigIntNotDefined() {\n      throw new Error(\"BigInt not supported\");\n    }\n    return exports;\n  }\n  var exports$2, _dewExec$2, exports$1, _dewExec$1, exports, _dewExec;\n  var init_chunk_DtuTasat = __esm({\n    \"../../../node_modules/.pnpm/@jspm+core@2.1.0/node_modules/@jspm/core/nodelibs/browser/chunk-DtuTasat.js\"() {\n      \"use strict\";\n      init_dirname();\n      init_buffer2();\n      init_process2();\n      exports$2 = {};\n      _dewExec$2 = false;\n      exports$1 = {};\n      _dewExec$1 = false;\n      exports = {};\n      _dewExec = false;\n    }\n  });\n\n  // ../../../node_modules/.pnpm/@jspm+core@2.1.0/node_modules/@jspm/core/nodelibs/browser/buffer.js\n  var buffer_exports = {};\n  __export(buffer_exports, {\n    Buffer: () => Buffer2,\n    INSPECT_MAX_BYTES: () => INSPECT_MAX_BYTES,\n    default: () => exports2,\n    kMaxLength: () => kMaxLength\n  });\n  var exports2, Buffer2, INSPECT_MAX_BYTES, kMaxLength;\n  var init_buffer = __esm({\n    \"../../../node_modules/.pnpm/@jspm+core@2.1.0/node_modules/@jspm/core/nodelibs/browser/buffer.js\"() {\n      \"use strict\";\n      init_dirname();\n      init_buffer2();\n      init_process2();\n      init_chunk_DtuTasat();\n      exports2 = dew();\n      exports2[\"Buffer\"];\n      exports2[\"SlowBuffer\"];\n      exports2[\"INSPECT_MAX_BYTES\"];\n      exports2[\"kMaxLength\"];\n      Buffer2 = exports2.Buffer;\n      INSPECT_MAX_BYTES = exports2.INSPECT_MAX_BYTES;\n      kMaxLength = exports2.kMaxLength;\n    }\n  });\n\n  // ../../../node_modules/.pnpm/@lit-protocol+esbuild-plugin-polyfill-node@0.3.0_esbuild@0.19.12/node_modules/@lit-protocol/esbuild-plugin-polyfill-node/polyfills/buffer.js\n  var init_buffer2 = __esm({\n    \"../../../node_modules/.pnpm/@lit-protocol+esbuild-plugin-polyfill-node@0.3.0_esbuild@0.19.12/node_modules/@lit-protocol/esbuild-plugin-polyfill-node/polyfills/buffer.js\"() {\n      \"use strict\";\n      init_buffer();\n    }\n  });\n\n  // ../../../node_modules/.pnpm/bn.js@5.2.2/node_modules/bn.js/lib/bn.js\n  var require_bn = __commonJS({\n    \"../../../node_modules/.pnpm/bn.js@5.2.2/node_modules/bn.js/lib/bn.js\"(exports3, module) {\n      \"use strict\";\n      init_dirname();\n      init_buffer2();\n      init_process2();\n      (function(module2, exports4) {\n        \"use strict\";\n        function assert3(val, msg) {\n          if (!val)\n            throw new Error(msg || \"Assertion failed\");\n        }\n        function inherits(ctor, superCtor) {\n          ctor.super_ = superCtor;\n          var TempCtor = function() {\n          };\n          TempCtor.prototype = superCtor.prototype;\n          ctor.prototype = new TempCtor();\n          ctor.prototype.constructor = ctor;\n        }\n        function BN2(number2, base, endian) {\n          if (BN2.isBN(number2)) {\n            return number2;\n          }\n          this.negative = 0;\n          this.words = null;\n          this.length = 0;\n          this.red = null;\n          if (number2 !== null) {\n            if (base === \"le\" || base === \"be\") {\n              endian = base;\n              base = 10;\n            }\n            this._init(number2 || 0, base || 10, endian || \"be\");\n          }\n        }\n        if (typeof module2 === \"object\") {\n          module2.exports = BN2;\n        } else {\n          exports4.BN = BN2;\n        }\n        BN2.BN = BN2;\n        BN2.wordSize = 26;\n        var Buffer3;\n        try {\n          if (typeof window !== \"undefined\" && typeof window.Buffer !== \"undefined\") {\n            Buffer3 = window.Buffer;\n          } else {\n            Buffer3 = (init_buffer(), __toCommonJS(buffer_exports)).Buffer;\n          }\n        } catch (e) {\n        }\n        BN2.isBN = function isBN(num) {\n          if (num instanceof BN2) {\n            return true;\n          }\n          return num !== null && typeof num === \"object\" && num.constructor.wordSize === BN2.wordSize && Array.isArray(num.words);\n        };\n        BN2.max = function max(left, right) {\n          if (left.cmp(right) > 0)\n            return left;\n          return right;\n        };\n        BN2.min = function min(left, right) {\n          if (left.cmp(right) < 0)\n            return left;\n          return right;\n        };\n        BN2.prototype._init = function init(number2, base, endian) {\n          if (typeof number2 === \"number\") {\n            return this._initNumber(number2, base, endian);\n          }\n          if (typeof number2 === \"object\") {\n            return this._initArray(number2, base, endian);\n          }\n          if (base === \"hex\") {\n            base = 16;\n          }\n          assert3(base === (base | 0) && base >= 2 && base <= 36);\n          number2 = number2.toString().replace(/\\s+/g, \"\");\n          var start = 0;\n          if (number2[0] === \"-\") {\n            start++;\n            this.negative = 1;\n          }\n          if (start < number2.length) {\n            if (base === 16) {\n              this._parseHex(number2, start, endian);\n            } else {\n              this._parseBase(number2, base, start);\n              if (endian === \"le\") {\n                this._initArray(this.toArray(), base, endian);\n              }\n            }\n          }\n        };\n        BN2.prototype._initNumber = function _initNumber(number2, base, endian) {\n          if (number2 < 0) {\n            this.negative = 1;\n            number2 = -number2;\n          }\n          if (number2 < 67108864) {\n            this.words = [number2 & 67108863];\n            this.length = 1;\n          } else if (number2 < 4503599627370496) {\n            this.words = [\n              number2 & 67108863,\n              number2 / 67108864 & 67108863\n            ];\n            this.length = 2;\n          } else {\n            assert3(number2 < 9007199254740992);\n            this.words = [\n              number2 & 67108863,\n              number2 / 67108864 & 67108863,\n              1\n            ];\n            this.length = 3;\n          }\n          if (endian !== \"le\")\n            return;\n          this._initArray(this.toArray(), base, endian);\n        };\n        BN2.prototype._initArray = function _initArray(number2, base, endian) {\n          assert3(typeof number2.length === \"number\");\n          if (number2.length <= 0) {\n            this.words = [0];\n            this.length = 1;\n            return this;\n          }\n          this.length = Math.ceil(number2.length / 3);\n          this.words = new Array(this.length);\n          for (var i = 0; i < this.length; i++) {\n            this.words[i] = 0;\n          }\n          var j, w;\n          var off = 0;\n          if (endian === \"be\") {\n            for (i = number2.length - 1, j = 0; i >= 0; i -= 3) {\n              w = number2[i] | number2[i - 1] << 8 | number2[i - 2] << 16;\n              this.words[j] |= w << off & 67108863;\n              this.words[j + 1] = w >>> 26 - off & 67108863;\n              off += 24;\n              if (off >= 26) {\n                off -= 26;\n                j++;\n              }\n            }\n          } else if (endian === \"le\") {\n            for (i = 0, j = 0; i < number2.length; i += 3) {\n              w = number2[i] | number2[i + 1] << 8 | number2[i + 2] << 16;\n              this.words[j] |= w << off & 67108863;\n              this.words[j + 1] = w >>> 26 - off & 67108863;\n              off += 24;\n              if (off >= 26) {\n                off -= 26;\n                j++;\n              }\n            }\n          }\n          return this._strip();\n        };\n        function parseHex4Bits(string2, index) {\n          var c = string2.charCodeAt(index);\n          if (c >= 48 && c <= 57) {\n            return c - 48;\n          } else if (c >= 65 && c <= 70) {\n            return c - 55;\n          } else if (c >= 97 && c <= 102) {\n            return c - 87;\n          } else {\n            assert3(false, \"Invalid character in \" + string2);\n          }\n        }\n        function parseHexByte(string2, lowerBound, index) {\n          var r = parseHex4Bits(string2, index);\n          if (index - 1 >= lowerBound) {\n            r |= parseHex4Bits(string2, index - 1) << 4;\n          }\n          return r;\n        }\n        BN2.prototype._parseHex = function _parseHex(number2, start, endian) {\n          this.length = Math.ceil((number2.length - start) / 6);\n          this.words = new Array(this.length);\n          for (var i = 0; i < this.length; i++) {\n            this.words[i] = 0;\n          }\n          var off = 0;\n          var j = 0;\n          var w;\n          if (endian === \"be\") {\n            for (i = number2.length - 1; i >= start; i -= 2) {\n              w = parseHexByte(number2, start, i) << off;\n              this.words[j] |= w & 67108863;\n              if (off >= 18) {\n                off -= 18;\n                j += 1;\n                this.words[j] |= w >>> 26;\n              } else {\n                off += 8;\n              }\n            }\n          } else {\n            var parseLength = number2.length - start;\n            for (i = parseLength % 2 === 0 ? start + 1 : start; i < number2.length; i += 2) {\n              w = parseHexByte(number2, start, i) << off;\n              this.words[j] |= w & 67108863;\n              if (off >= 18) {\n                off -= 18;\n                j += 1;\n                this.words[j] |= w >>> 26;\n              } else {\n                off += 8;\n              }\n            }\n          }\n          this._strip();\n        };\n        function parseBase(str, start, end, mul) {\n          var r = 0;\n          var b = 0;\n          var len = Math.min(str.length, end);\n          for (var i = start; i < len; i++) {\n            var c = str.charCodeAt(i) - 48;\n            r *= mul;\n            if (c >= 49) {\n              b = c - 49 + 10;\n            } else if (c >= 17) {\n              b = c - 17 + 10;\n            } else {\n              b = c;\n            }\n            assert3(c >= 0 && b < mul, \"Invalid character\");\n            r += b;\n          }\n          return r;\n        }\n        BN2.prototype._parseBase = function _parseBase(number2, base, start) {\n          this.words = [0];\n          this.length = 1;\n          for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {\n            limbLen++;\n          }\n          limbLen--;\n          limbPow = limbPow / base | 0;\n          var total = number2.length - start;\n          var mod2 = total % limbLen;\n          var end = Math.min(total, total - mod2) + start;\n          var word = 0;\n          for (var i = start; i < end; i += limbLen) {\n            word = parseBase(number2, i, i + limbLen, base);\n            this.imuln(limbPow);\n            if (this.words[0] + word < 67108864) {\n              this.words[0] += word;\n            } else {\n              this._iaddn(word);\n            }\n          }\n          if (mod2 !== 0) {\n            var pow = 1;\n            word = parseBase(number2, i, number2.length, base);\n            for (i = 0; i < mod2; i++) {\n              pow *= base;\n            }\n            this.imuln(pow);\n            if (this.words[0] + word < 67108864) {\n              this.words[0] += word;\n            } else {\n              this._iaddn(word);\n            }\n          }\n          this._strip();\n        };\n        BN2.prototype.copy = function copy(dest) {\n          dest.words = new Array(this.length);\n          for (var i = 0; i < this.length; i++) {\n            dest.words[i] = this.words[i];\n          }\n          dest.length = this.length;\n          dest.negative = this.negative;\n          dest.red = this.red;\n        };\n        function move(dest, src) {\n          dest.words = src.words;\n          dest.length = src.length;\n          dest.negative = src.negative;\n          dest.red = src.red;\n        }\n        BN2.prototype._move = function _move(dest) {\n          move(dest, this);\n        };\n        BN2.prototype.clone = function clone() {\n          var r = new BN2(null);\n          this.copy(r);\n          return r;\n        };\n        BN2.prototype._expand = function _expand(size) {\n          while (this.length < size) {\n            this.words[this.length++] = 0;\n          }\n          return this;\n        };\n        BN2.prototype._strip = function strip() {\n          while (this.length > 1 && this.words[this.length - 1] === 0) {\n            this.length--;\n          }\n          return this._normSign();\n        };\n        BN2.prototype._normSign = function _normSign() {\n          if (this.length === 1 && this.words[0] === 0) {\n            this.negative = 0;\n          }\n          return this;\n        };\n        if (typeof Symbol !== \"undefined\" && typeof Symbol.for === \"function\") {\n          try {\n            BN2.prototype[Symbol.for(\"nodejs.util.inspect.custom\")] = inspect;\n          } catch (e) {\n            BN2.prototype.inspect = inspect;\n          }\n        } else {\n          BN2.prototype.inspect = inspect;\n        }\n        function inspect() {\n          return (this.red ? \"<BN-R: \" : \"<BN: \") + this.toString(16) + \">\";\n        }\n        var zeros = [\n          \"\",\n          \"0\",\n          \"00\",\n          \"000\",\n          \"0000\",\n          \"00000\",\n          \"000000\",\n          \"0000000\",\n          \"00000000\",\n          \"000000000\",\n          \"0000000000\",\n          \"00000000000\",\n          \"000000000000\",\n          \"0000000000000\",\n          \"00000000000000\",\n          \"000000000000000\",\n          \"0000000000000000\",\n          \"00000000000000000\",\n          \"000000000000000000\",\n          \"0000000000000000000\",\n          \"00000000000000000000\",\n          \"000000000000000000000\",\n          \"0000000000000000000000\",\n          \"00000000000000000000000\",\n          \"000000000000000000000000\",\n          \"0000000000000000000000000\"\n        ];\n        var groupSizes = [\n          0,\n          0,\n          25,\n          16,\n          12,\n          11,\n          10,\n          9,\n          8,\n          8,\n          7,\n          7,\n          7,\n          7,\n          6,\n          6,\n          6,\n          6,\n          6,\n          6,\n          6,\n          5,\n          5,\n          5,\n          5,\n          5,\n          5,\n          5,\n          5,\n          5,\n          5,\n          5,\n          5,\n          5,\n          5,\n          5,\n          5\n        ];\n        var groupBases = [\n          0,\n          0,\n          33554432,\n          43046721,\n          16777216,\n          48828125,\n          60466176,\n          40353607,\n          16777216,\n          43046721,\n          1e7,\n          19487171,\n          35831808,\n          62748517,\n          7529536,\n          11390625,\n          16777216,\n          24137569,\n          34012224,\n          47045881,\n          64e6,\n          4084101,\n          5153632,\n          6436343,\n          7962624,\n          9765625,\n          11881376,\n          14348907,\n          17210368,\n          20511149,\n          243e5,\n          28629151,\n          33554432,\n          39135393,\n          45435424,\n          52521875,\n          60466176\n        ];\n        BN2.prototype.toString = function toString(base, padding) {\n          base = base || 10;\n          padding = padding | 0 || 1;\n          var out;\n          if (base === 16 || base === \"hex\") {\n            out = \"\";\n            var off = 0;\n            var carry = 0;\n            for (var i = 0; i < this.length; i++) {\n              var w = this.words[i];\n              var word = ((w << off | carry) & 16777215).toString(16);\n              carry = w >>> 24 - off & 16777215;\n              off += 2;\n              if (off >= 26) {\n                off -= 26;\n                i--;\n              }\n              if (carry !== 0 || i !== this.length - 1) {\n                out = zeros[6 - word.length] + word + out;\n              } else {\n                out = word + out;\n              }\n            }\n            if (carry !== 0) {\n              out = carry.toString(16) + out;\n            }\n            while (out.length % padding !== 0) {\n              out = \"0\" + out;\n            }\n            if (this.negative !== 0) {\n              out = \"-\" + out;\n            }\n            return out;\n          }\n          if (base === (base | 0) && base >= 2 && base <= 36) {\n            var groupSize = groupSizes[base];\n            var groupBase = groupBases[base];\n            out = \"\";\n            var c = this.clone();\n            c.negative = 0;\n            while (!c.isZero()) {\n              var r = c.modrn(groupBase).toString(base);\n              c = c.idivn(groupBase);\n              if (!c.isZero()) {\n                out = zeros[groupSize - r.length] + r + out;\n              } else {\n                out = r + out;\n              }\n            }\n            if (this.isZero()) {\n              out = \"0\" + out;\n            }\n            while (out.length % padding !== 0) {\n              out = \"0\" + out;\n            }\n            if (this.negative !== 0) {\n              out = \"-\" + out;\n            }\n            return out;\n          }\n          assert3(false, \"Base should be between 2 and 36\");\n        };\n        BN2.prototype.toNumber = function toNumber() {\n          var ret = this.words[0];\n          if (this.length === 2) {\n            ret += this.words[1] * 67108864;\n          } else if (this.length === 3 && this.words[2] === 1) {\n            ret += 4503599627370496 + this.words[1] * 67108864;\n          } else if (this.length > 2) {\n            assert3(false, \"Number can only safely store up to 53 bits\");\n          }\n          return this.negative !== 0 ? -ret : ret;\n        };\n        BN2.prototype.toJSON = function toJSON() {\n          return this.toString(16, 2);\n        };\n        if (Buffer3) {\n          BN2.prototype.toBuffer = function toBuffer2(endian, length) {\n            return this.toArrayLike(Buffer3, endian, length);\n          };\n        }\n        BN2.prototype.toArray = function toArray(endian, length) {\n          return this.toArrayLike(Array, endian, length);\n        };\n        var allocate = function allocate2(ArrayType, size) {\n          if (ArrayType.allocUnsafe) {\n            return ArrayType.allocUnsafe(size);\n          }\n          return new ArrayType(size);\n        };\n        BN2.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {\n          this._strip();\n          var byteLength = this.byteLength();\n          var reqLength = length || Math.max(1, byteLength);\n          assert3(byteLength <= reqLength, \"byte array longer than desired length\");\n          assert3(reqLength > 0, \"Requested array length <= 0\");\n          var res = allocate(ArrayType, reqLength);\n          var postfix = endian === \"le\" ? \"LE\" : \"BE\";\n          this[\"_toArrayLike\" + postfix](res, byteLength);\n          return res;\n        };\n        BN2.prototype._toArrayLikeLE = function _toArrayLikeLE(res, byteLength) {\n          var position = 0;\n          var carry = 0;\n          for (var i = 0, shift = 0; i < this.length; i++) {\n            var word = this.words[i] << shift | carry;\n            res[position++] = word & 255;\n            if (position < res.length) {\n              res[position++] = word >> 8 & 255;\n            }\n            if (position < res.length) {\n              res[position++] = word >> 16 & 255;\n            }\n            if (shift === 6) {\n              if (position < res.length) {\n                res[position++] = word >> 24 & 255;\n              }\n              carry = 0;\n              shift = 0;\n            } else {\n              carry = word >>> 24;\n              shift += 2;\n            }\n          }\n          if (position < res.length) {\n            res[position++] = carry;\n            while (position < res.length) {\n              res[position++] = 0;\n            }\n          }\n        };\n        BN2.prototype._toArrayLikeBE = function _toArrayLikeBE(res, byteLength) {\n          var position = res.length - 1;\n          var carry = 0;\n          for (var i = 0, shift = 0; i < this.length; i++) {\n            var word = this.words[i] << shift | carry;\n            res[position--] = word & 255;\n            if (position >= 0) {\n              res[position--] = word >> 8 & 255;\n            }\n            if (position >= 0) {\n              res[position--] = word >> 16 & 255;\n            }\n            if (shift === 6) {\n              if (position >= 0) {\n                res[position--] = word >> 24 & 255;\n              }\n              carry = 0;\n              shift = 0;\n            } else {\n              carry = word >>> 24;\n              shift += 2;\n            }\n          }\n          if (position >= 0) {\n            res[position--] = carry;\n            while (position >= 0) {\n              res[position--] = 0;\n            }\n          }\n        };\n        if (Math.clz32) {\n          BN2.prototype._countBits = function _countBits(w) {\n            return 32 - Math.clz32(w);\n          };\n        } else {\n          BN2.prototype._countBits = function _countBits(w) {\n            var t = w;\n            var r = 0;\n            if (t >= 4096) {\n              r += 13;\n              t >>>= 13;\n            }\n            if (t >= 64) {\n              r += 7;\n              t >>>= 7;\n            }\n            if (t >= 8) {\n              r += 4;\n              t >>>= 4;\n            }\n            if (t >= 2) {\n              r += 2;\n              t >>>= 2;\n            }\n            return r + t;\n          };\n        }\n        BN2.prototype._zeroBits = function _zeroBits(w) {\n          if (w === 0)\n            return 26;\n          var t = w;\n          var r = 0;\n          if ((t & 8191) === 0) {\n            r += 13;\n            t >>>= 13;\n          }\n          if ((t & 127) === 0) {\n            r += 7;\n            t >>>= 7;\n          }\n          if ((t & 15) === 0) {\n            r += 4;\n            t >>>= 4;\n          }\n          if ((t & 3) === 0) {\n            r += 2;\n            t >>>= 2;\n          }\n          if ((t & 1) === 0) {\n            r++;\n          }\n          return r;\n        };\n        BN2.prototype.bitLength = function bitLength() {\n          var w = this.words[this.length - 1];\n          var hi = this._countBits(w);\n          return (this.length - 1) * 26 + hi;\n        };\n        function toBitArray(num) {\n          var w = new Array(num.bitLength());\n          for (var bit = 0; bit < w.length; bit++) {\n            var off = bit / 26 | 0;\n            var wbit = bit % 26;\n            w[bit] = num.words[off] >>> wbit & 1;\n          }\n          return w;\n        }\n        BN2.prototype.zeroBits = function zeroBits() {\n          if (this.isZero())\n            return 0;\n          var r = 0;\n          for (var i = 0; i < this.length; i++) {\n            var b = this._zeroBits(this.words[i]);\n            r += b;\n            if (b !== 26)\n              break;\n          }\n          return r;\n        };\n        BN2.prototype.byteLength = function byteLength() {\n          return Math.ceil(this.bitLength() / 8);\n        };\n        BN2.prototype.toTwos = function toTwos(width) {\n          if (this.negative !== 0) {\n            return this.abs().inotn(width).iaddn(1);\n          }\n          return this.clone();\n        };\n        BN2.prototype.fromTwos = function fromTwos(width) {\n          if (this.testn(width - 1)) {\n            return this.notn(width).iaddn(1).ineg();\n          }\n          return this.clone();\n        };\n        BN2.prototype.isNeg = function isNeg() {\n          return this.negative !== 0;\n        };\n        BN2.prototype.neg = function neg() {\n          return this.clone().ineg();\n        };\n        BN2.prototype.ineg = function ineg() {\n          if (!this.isZero()) {\n            this.negative ^= 1;\n          }\n          return this;\n        };\n        BN2.prototype.iuor = function iuor(num) {\n          while (this.length < num.length) {\n            this.words[this.length++] = 0;\n          }\n          for (var i = 0; i < num.length; i++) {\n            this.words[i] = this.words[i] | num.words[i];\n          }\n          return this._strip();\n        };\n        BN2.prototype.ior = function ior(num) {\n          assert3((this.negative | num.negative) === 0);\n          return this.iuor(num);\n        };\n        BN2.prototype.or = function or(num) {\n          if (this.length > num.length)\n            return this.clone().ior(num);\n          return num.clone().ior(this);\n        };\n        BN2.prototype.uor = function uor(num) {\n          if (this.length > num.length)\n            return this.clone().iuor(num);\n          return num.clone().iuor(this);\n        };\n        BN2.prototype.iuand = function iuand(num) {\n          var b;\n          if (this.length > num.length) {\n            b = num;\n          } else {\n            b = this;\n          }\n          for (var i = 0; i < b.length; i++) {\n            this.words[i] = this.words[i] & num.words[i];\n          }\n          this.length = b.length;\n          return this._strip();\n        };\n        BN2.prototype.iand = function iand(num) {\n          assert3((this.negative | num.negative) === 0);\n          return this.iuand(num);\n        };\n        BN2.prototype.and = function and(num) {\n          if (this.length > num.length)\n            return this.clone().iand(num);\n          return num.clone().iand(this);\n        };\n        BN2.prototype.uand = function uand(num) {\n          if (this.length > num.length)\n            return this.clone().iuand(num);\n          return num.clone().iuand(this);\n        };\n        BN2.prototype.iuxor = function iuxor(num) {\n          var a;\n          var b;\n          if (this.length > num.length) {\n            a = this;\n            b = num;\n          } else {\n            a = num;\n            b = this;\n          }\n          for (var i = 0; i < b.length; i++) {\n            this.words[i] = a.words[i] ^ b.words[i];\n          }\n          if (this !== a) {\n            for (; i < a.length; i++) {\n              this.words[i] = a.words[i];\n            }\n          }\n          this.length = a.length;\n          return this._strip();\n        };\n        BN2.prototype.ixor = function ixor(num) {\n          assert3((this.negative | num.negative) === 0);\n          return this.iuxor(num);\n        };\n        BN2.prototype.xor = function xor(num) {\n          if (this.length > num.length)\n            return this.clone().ixor(num);\n          return num.clone().ixor(this);\n        };\n        BN2.prototype.uxor = function uxor(num) {\n          if (this.length > num.length)\n            return this.clone().iuxor(num);\n          return num.clone().iuxor(this);\n        };\n        BN2.prototype.inotn = function inotn(width) {\n          assert3(typeof width === \"number\" && width >= 0);\n          var bytesNeeded = Math.ceil(width / 26) | 0;\n          var bitsLeft = width % 26;\n          this._expand(bytesNeeded);\n          if (bitsLeft > 0) {\n            bytesNeeded--;\n          }\n          for (var i = 0; i < bytesNeeded; i++) {\n            this.words[i] = ~this.words[i] & 67108863;\n          }\n          if (bitsLeft > 0) {\n            this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;\n          }\n          return this._strip();\n        };\n        BN2.prototype.notn = function notn(width) {\n          return this.clone().inotn(width);\n        };\n        BN2.prototype.setn = function setn(bit, val) {\n          assert3(typeof bit === \"number\" && bit >= 0);\n          var off = bit / 26 | 0;\n          var wbit = bit % 26;\n          this._expand(off + 1);\n          if (val) {\n            this.words[off] = this.words[off] | 1 << wbit;\n          } else {\n            this.words[off] = this.words[off] & ~(1 << wbit);\n          }\n          return this._strip();\n        };\n        BN2.prototype.iadd = function iadd(num) {\n          var r;\n          if (this.negative !== 0 && num.negative === 0) {\n            this.negative = 0;\n            r = this.isub(num);\n            this.negative ^= 1;\n            return this._normSign();\n          } else if (this.negative === 0 && num.negative !== 0) {\n            num.negative = 0;\n            r = this.isub(num);\n            num.negative = 1;\n            return r._normSign();\n          }\n          var a, b;\n          if (this.length > num.length) {\n            a = this;\n            b = num;\n          } else {\n            a = num;\n            b = this;\n          }\n          var carry = 0;\n          for (var i = 0; i < b.length; i++) {\n            r = (a.words[i] | 0) + (b.words[i] | 0) + carry;\n            this.words[i] = r & 67108863;\n            carry = r >>> 26;\n          }\n          for (; carry !== 0 && i < a.length; i++) {\n            r = (a.words[i] | 0) + carry;\n            this.words[i] = r & 67108863;\n            carry = r >>> 26;\n          }\n          this.length = a.length;\n          if (carry !== 0) {\n            this.words[this.length] = carry;\n            this.length++;\n          } else if (a !== this) {\n            for (; i < a.length; i++) {\n              this.words[i] = a.words[i];\n            }\n          }\n          return this;\n        };\n        BN2.prototype.add = function add2(num) {\n          var res;\n          if (num.negative !== 0 && this.negative === 0) {\n            num.negative = 0;\n            res = this.sub(num);\n            num.negative ^= 1;\n            return res;\n          } else if (num.negative === 0 && this.negative !== 0) {\n            this.negative = 0;\n            res = num.sub(this);\n            this.negative = 1;\n            return res;\n          }\n          if (this.length > num.length)\n            return this.clone().iadd(num);\n          return num.clone().iadd(this);\n        };\n        BN2.prototype.isub = function isub(num) {\n          if (num.negative !== 0) {\n            num.negative = 0;\n            var r = this.iadd(num);\n            num.negative = 1;\n            return r._normSign();\n          } else if (this.negative !== 0) {\n            this.negative = 0;\n            this.iadd(num);\n            this.negative = 1;\n            return this._normSign();\n          }\n          var cmp = this.cmp(num);\n          if (cmp === 0) {\n            this.negative = 0;\n            this.length = 1;\n            this.words[0] = 0;\n            return this;\n          }\n          var a, b;\n          if (cmp > 0) {\n            a = this;\n            b = num;\n          } else {\n            a = num;\n            b = this;\n          }\n          var carry = 0;\n          for (var i = 0; i < b.length; i++) {\n            r = (a.words[i] | 0) - (b.words[i] | 0) + carry;\n            carry = r >> 26;\n            this.words[i] = r & 67108863;\n          }\n          for (; carry !== 0 && i < a.length; i++) {\n            r = (a.words[i] | 0) + carry;\n            carry = r >> 26;\n            this.words[i] = r & 67108863;\n          }\n          if (carry === 0 && i < a.length && a !== this) {\n            for (; i < a.length; i++) {\n              this.words[i] = a.words[i];\n            }\n          }\n          this.length = Math.max(this.length, i);\n          if (a !== this) {\n            this.negative = 1;\n          }\n          return this._strip();\n        };\n        BN2.prototype.sub = function sub(num) {\n          return this.clone().isub(num);\n        };\n        function smallMulTo(self, num, out) {\n          out.negative = num.negative ^ self.negative;\n          var len = self.length + num.length | 0;\n          out.length = len;\n          len = len - 1 | 0;\n          var a = self.words[0] | 0;\n          var b = num.words[0] | 0;\n          var r = a * b;\n          var lo = r & 67108863;\n          var carry = r / 67108864 | 0;\n          out.words[0] = lo;\n          for (var k = 1; k < len; k++) {\n            var ncarry = carry >>> 26;\n            var rword = carry & 67108863;\n            var maxJ = Math.min(k, num.length - 1);\n            for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n              var i = k - j | 0;\n              a = self.words[i] | 0;\n              b = num.words[j] | 0;\n              r = a * b + rword;\n              ncarry += r / 67108864 | 0;\n              rword = r & 67108863;\n            }\n            out.words[k] = rword | 0;\n            carry = ncarry | 0;\n          }\n          if (carry !== 0) {\n            out.words[k] = carry | 0;\n          } else {\n            out.length--;\n          }\n          return out._strip();\n        }\n        var comb10MulTo = function comb10MulTo2(self, num, out) {\n          var a = self.words;\n          var b = num.words;\n          var o = out.words;\n          var c = 0;\n          var lo;\n          var mid;\n          var hi;\n          var a0 = a[0] | 0;\n          var al0 = a0 & 8191;\n          var ah0 = a0 >>> 13;\n          var a1 = a[1] | 0;\n          var al1 = a1 & 8191;\n          var ah1 = a1 >>> 13;\n          var a2 = a[2] | 0;\n          var al2 = a2 & 8191;\n          var ah2 = a2 >>> 13;\n          var a3 = a[3] | 0;\n          var al3 = a3 & 8191;\n          var ah3 = a3 >>> 13;\n          var a4 = a[4] | 0;\n          var al4 = a4 & 8191;\n          var ah4 = a4 >>> 13;\n          var a5 = a[5] | 0;\n          var al5 = a5 & 8191;\n          var ah5 = a5 >>> 13;\n          var a6 = a[6] | 0;\n          var al6 = a6 & 8191;\n          var ah6 = a6 >>> 13;\n          var a7 = a[7] | 0;\n          var al7 = a7 & 8191;\n          var ah7 = a7 >>> 13;\n          var a8 = a[8] | 0;\n          var al8 = a8 & 8191;\n          var ah8 = a8 >>> 13;\n          var a9 = a[9] | 0;\n          var al9 = a9 & 8191;\n          var ah9 = a9 >>> 13;\n          var b0 = b[0] | 0;\n          var bl0 = b0 & 8191;\n          var bh0 = b0 >>> 13;\n          var b1 = b[1] | 0;\n          var bl1 = b1 & 8191;\n          var bh1 = b1 >>> 13;\n          var b2 = b[2] | 0;\n          var bl2 = b2 & 8191;\n          var bh2 = b2 >>> 13;\n          var b3 = b[3] | 0;\n          var bl3 = b3 & 8191;\n          var bh3 = b3 >>> 13;\n          var b4 = b[4] | 0;\n          var bl4 = b4 & 8191;\n          var bh4 = b4 >>> 13;\n          var b5 = b[5] | 0;\n          var bl5 = b5 & 8191;\n          var bh5 = b5 >>> 13;\n          var b6 = b[6] | 0;\n          var bl6 = b6 & 8191;\n          var bh6 = b6 >>> 13;\n          var b7 = b[7] | 0;\n          var bl7 = b7 & 8191;\n          var bh7 = b7 >>> 13;\n          var b8 = b[8] | 0;\n          var bl8 = b8 & 8191;\n          var bh8 = b8 >>> 13;\n          var b9 = b[9] | 0;\n          var bl9 = b9 & 8191;\n          var bh9 = b9 >>> 13;\n          out.negative = self.negative ^ num.negative;\n          out.length = 19;\n          lo = Math.imul(al0, bl0);\n          mid = Math.imul(al0, bh0);\n          mid = mid + Math.imul(ah0, bl0) | 0;\n          hi = Math.imul(ah0, bh0);\n          var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;\n          w0 &= 67108863;\n          lo = Math.imul(al1, bl0);\n          mid = Math.imul(al1, bh0);\n          mid = mid + Math.imul(ah1, bl0) | 0;\n          hi = Math.imul(ah1, bh0);\n          lo = lo + Math.imul(al0, bl1) | 0;\n          mid = mid + Math.imul(al0, bh1) | 0;\n          mid = mid + Math.imul(ah0, bl1) | 0;\n          hi = hi + Math.imul(ah0, bh1) | 0;\n          var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;\n          w1 &= 67108863;\n          lo = Math.imul(al2, bl0);\n          mid = Math.imul(al2, bh0);\n          mid = mid + Math.imul(ah2, bl0) | 0;\n          hi = Math.imul(ah2, bh0);\n          lo = lo + Math.imul(al1, bl1) | 0;\n          mid = mid + Math.imul(al1, bh1) | 0;\n          mid = mid + Math.imul(ah1, bl1) | 0;\n          hi = hi + Math.imul(ah1, bh1) | 0;\n          lo = lo + Math.imul(al0, bl2) | 0;\n          mid = mid + Math.imul(al0, bh2) | 0;\n          mid = mid + Math.imul(ah0, bl2) | 0;\n          hi = hi + Math.imul(ah0, bh2) | 0;\n          var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;\n          w2 &= 67108863;\n          lo = Math.imul(al3, bl0);\n          mid = Math.imul(al3, bh0);\n          mid = mid + Math.imul(ah3, bl0) | 0;\n          hi = Math.imul(ah3, bh0);\n          lo = lo + Math.imul(al2, bl1) | 0;\n          mid = mid + Math.imul(al2, bh1) | 0;\n          mid = mid + Math.imul(ah2, bl1) | 0;\n          hi = hi + Math.imul(ah2, bh1) | 0;\n          lo = lo + Math.imul(al1, bl2) | 0;\n          mid = mid + Math.imul(al1, bh2) | 0;\n          mid = mid + Math.imul(ah1, bl2) | 0;\n          hi = hi + Math.imul(ah1, bh2) | 0;\n          lo = lo + Math.imul(al0, bl3) | 0;\n          mid = mid + Math.imul(al0, bh3) | 0;\n          mid = mid + Math.imul(ah0, bl3) | 0;\n          hi = hi + Math.imul(ah0, bh3) | 0;\n          var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;\n          w3 &= 67108863;\n          lo = Math.imul(al4, bl0);\n          mid = Math.imul(al4, bh0);\n          mid = mid + Math.imul(ah4, bl0) | 0;\n          hi = Math.imul(ah4, bh0);\n          lo = lo + Math.imul(al3, bl1) | 0;\n          mid = mid + Math.imul(al3, bh1) | 0;\n          mid = mid + Math.imul(ah3, bl1) | 0;\n          hi = hi + Math.imul(ah3, bh1) | 0;\n          lo = lo + Math.imul(al2, bl2) | 0;\n          mid = mid + Math.imul(al2, bh2) | 0;\n          mid = mid + Math.imul(ah2, bl2) | 0;\n          hi = hi + Math.imul(ah2, bh2) | 0;\n          lo = lo + Math.imul(al1, bl3) | 0;\n          mid = mid + Math.imul(al1, bh3) | 0;\n          mid = mid + Math.imul(ah1, bl3) | 0;\n          hi = hi + Math.imul(ah1, bh3) | 0;\n          lo = lo + Math.imul(al0, bl4) | 0;\n          mid = mid + Math.imul(al0, bh4) | 0;\n          mid = mid + Math.imul(ah0, bl4) | 0;\n          hi = hi + Math.imul(ah0, bh4) | 0;\n          var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;\n          w4 &= 67108863;\n          lo = Math.imul(al5, bl0);\n          mid = Math.imul(al5, bh0);\n          mid = mid + Math.imul(ah5, bl0) | 0;\n          hi = Math.imul(ah5, bh0);\n          lo = lo + Math.imul(al4, bl1) | 0;\n          mid = mid + Math.imul(al4, bh1) | 0;\n          mid = mid + Math.imul(ah4, bl1) | 0;\n          hi = hi + Math.imul(ah4, bh1) | 0;\n          lo = lo + Math.imul(al3, bl2) | 0;\n          mid = mid + Math.imul(al3, bh2) | 0;\n          mid = mid + Math.imul(ah3, bl2) | 0;\n          hi = hi + Math.imul(ah3, bh2) | 0;\n          lo = lo + Math.imul(al2, bl3) | 0;\n          mid = mid + Math.imul(al2, bh3) | 0;\n          mid = mid + Math.imul(ah2, bl3) | 0;\n          hi = hi + Math.imul(ah2, bh3) | 0;\n          lo = lo + Math.imul(al1, bl4) | 0;\n          mid = mid + Math.imul(al1, bh4) | 0;\n          mid = mid + Math.imul(ah1, bl4) | 0;\n          hi = hi + Math.imul(ah1, bh4) | 0;\n          lo = lo + Math.imul(al0, bl5) | 0;\n          mid = mid + Math.imul(al0, bh5) | 0;\n          mid = mid + Math.imul(ah0, bl5) | 0;\n          hi = hi + Math.imul(ah0, bh5) | 0;\n          var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;\n          w5 &= 67108863;\n          lo = Math.imul(al6, bl0);\n          mid = Math.imul(al6, bh0);\n          mid = mid + Math.imul(ah6, bl0) | 0;\n          hi = Math.imul(ah6, bh0);\n          lo = lo + Math.imul(al5, bl1) | 0;\n          mid = mid + Math.imul(al5, bh1) | 0;\n          mid = mid + Math.imul(ah5, bl1) | 0;\n          hi = hi + Math.imul(ah5, bh1) | 0;\n          lo = lo + Math.imul(al4, bl2) | 0;\n          mid = mid + Math.imul(al4, bh2) | 0;\n          mid = mid + Math.imul(ah4, bl2) | 0;\n          hi = hi + Math.imul(ah4, bh2) | 0;\n          lo = lo + Math.imul(al3, bl3) | 0;\n          mid = mid + Math.imul(al3, bh3) | 0;\n          mid = mid + Math.imul(ah3, bl3) | 0;\n          hi = hi + Math.imul(ah3, bh3) | 0;\n          lo = lo + Math.imul(al2, bl4) | 0;\n          mid = mid + Math.imul(al2, bh4) | 0;\n          mid = mid + Math.imul(ah2, bl4) | 0;\n          hi = hi + Math.imul(ah2, bh4) | 0;\n          lo = lo + Math.imul(al1, bl5) | 0;\n          mid = mid + Math.imul(al1, bh5) | 0;\n          mid = mid + Math.imul(ah1, bl5) | 0;\n          hi = hi + Math.imul(ah1, bh5) | 0;\n          lo = lo + Math.imul(al0, bl6) | 0;\n          mid = mid + Math.imul(al0, bh6) | 0;\n          mid = mid + Math.imul(ah0, bl6) | 0;\n          hi = hi + Math.imul(ah0, bh6) | 0;\n          var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;\n          w6 &= 67108863;\n          lo = Math.imul(al7, bl0);\n          mid = Math.imul(al7, bh0);\n          mid = mid + Math.imul(ah7, bl0) | 0;\n          hi = Math.imul(ah7, bh0);\n          lo = lo + Math.imul(al6, bl1) | 0;\n          mid = mid + Math.imul(al6, bh1) | 0;\n          mid = mid + Math.imul(ah6, bl1) | 0;\n          hi = hi + Math.imul(ah6, bh1) | 0;\n          lo = lo + Math.imul(al5, bl2) | 0;\n          mid = mid + Math.imul(al5, bh2) | 0;\n          mid = mid + Math.imul(ah5, bl2) | 0;\n          hi = hi + Math.imul(ah5, bh2) | 0;\n          lo = lo + Math.imul(al4, bl3) | 0;\n          mid = mid + Math.imul(al4, bh3) | 0;\n          mid = mid + Math.imul(ah4, bl3) | 0;\n          hi = hi + Math.imul(ah4, bh3) | 0;\n          lo = lo + Math.imul(al3, bl4) | 0;\n          mid = mid + Math.imul(al3, bh4) | 0;\n          mid = mid + Math.imul(ah3, bl4) | 0;\n          hi = hi + Math.imul(ah3, bh4) | 0;\n          lo = lo + Math.imul(al2, bl5) | 0;\n          mid = mid + Math.imul(al2, bh5) | 0;\n          mid = mid + Math.imul(ah2, bl5) | 0;\n          hi = hi + Math.imul(ah2, bh5) | 0;\n          lo = lo + Math.imul(al1, bl6) | 0;\n          mid = mid + Math.imul(al1, bh6) | 0;\n          mid = mid + Math.imul(ah1, bl6) | 0;\n          hi = hi + Math.imul(ah1, bh6) | 0;\n          lo = lo + Math.imul(al0, bl7) | 0;\n          mid = mid + Math.imul(al0, bh7) | 0;\n          mid = mid + Math.imul(ah0, bl7) | 0;\n          hi = hi + Math.imul(ah0, bh7) | 0;\n          var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;\n          w7 &= 67108863;\n          lo = Math.imul(al8, bl0);\n          mid = Math.imul(al8, bh0);\n          mid = mid + Math.imul(ah8, bl0) | 0;\n          hi = Math.imul(ah8, bh0);\n          lo = lo + Math.imul(al7, bl1) | 0;\n          mid = mid + Math.imul(al7, bh1) | 0;\n          mid = mid + Math.imul(ah7, bl1) | 0;\n          hi = hi + Math.imul(ah7, bh1) | 0;\n          lo = lo + Math.imul(al6, bl2) | 0;\n          mid = mid + Math.imul(al6, bh2) | 0;\n          mid = mid + Math.imul(ah6, bl2) | 0;\n          hi = hi + Math.imul(ah6, bh2) | 0;\n          lo = lo + Math.imul(al5, bl3) | 0;\n          mid = mid + Math.imul(al5, bh3) | 0;\n          mid = mid + Math.imul(ah5, bl3) | 0;\n          hi = hi + Math.imul(ah5, bh3) | 0;\n          lo = lo + Math.imul(al4, bl4) | 0;\n          mid = mid + Math.imul(al4, bh4) | 0;\n          mid = mid + Math.imul(ah4, bl4) | 0;\n          hi = hi + Math.imul(ah4, bh4) | 0;\n          lo = lo + Math.imul(al3, bl5) | 0;\n          mid = mid + Math.imul(al3, bh5) | 0;\n          mid = mid + Math.imul(ah3, bl5) | 0;\n          hi = hi + Math.imul(ah3, bh5) | 0;\n          lo = lo + Math.imul(al2, bl6) | 0;\n          mid = mid + Math.imul(al2, bh6) | 0;\n          mid = mid + Math.imul(ah2, bl6) | 0;\n          hi = hi + Math.imul(ah2, bh6) | 0;\n          lo = lo + Math.imul(al1, bl7) | 0;\n          mid = mid + Math.imul(al1, bh7) | 0;\n          mid = mid + Math.imul(ah1, bl7) | 0;\n          hi = hi + Math.imul(ah1, bh7) | 0;\n          lo = lo + Math.imul(al0, bl8) | 0;\n          mid = mid + Math.imul(al0, bh8) | 0;\n          mid = mid + Math.imul(ah0, bl8) | 0;\n          hi = hi + Math.imul(ah0, bh8) | 0;\n          var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;\n          w8 &= 67108863;\n          lo = Math.imul(al9, bl0);\n          mid = Math.imul(al9, bh0);\n          mid = mid + Math.imul(ah9, bl0) | 0;\n          hi = Math.imul(ah9, bh0);\n          lo = lo + Math.imul(al8, bl1) | 0;\n          mid = mid + Math.imul(al8, bh1) | 0;\n          mid = mid + Math.imul(ah8, bl1) | 0;\n          hi = hi + Math.imul(ah8, bh1) | 0;\n          lo = lo + Math.imul(al7, bl2) | 0;\n          mid = mid + Math.imul(al7, bh2) | 0;\n          mid = mid + Math.imul(ah7, bl2) | 0;\n          hi = hi + Math.imul(ah7, bh2) | 0;\n          lo = lo + Math.imul(al6, bl3) | 0;\n          mid = mid + Math.imul(al6, bh3) | 0;\n          mid = mid + Math.imul(ah6, bl3) | 0;\n          hi = hi + Math.imul(ah6, bh3) | 0;\n          lo = lo + Math.imul(al5, bl4) | 0;\n          mid = mid + Math.imul(al5, bh4) | 0;\n          mid = mid + Math.imul(ah5, bl4) | 0;\n          hi = hi + Math.imul(ah5, bh4) | 0;\n          lo = lo + Math.imul(al4, bl5) | 0;\n          mid = mid + Math.imul(al4, bh5) | 0;\n          mid = mid + Math.imul(ah4, bl5) | 0;\n          hi = hi + Math.imul(ah4, bh5) | 0;\n          lo = lo + Math.imul(al3, bl6) | 0;\n          mid = mid + Math.imul(al3, bh6) | 0;\n          mid = mid + Math.imul(ah3, bl6) | 0;\n          hi = hi + Math.imul(ah3, bh6) | 0;\n          lo = lo + Math.imul(al2, bl7) | 0;\n          mid = mid + Math.imul(al2, bh7) | 0;\n          mid = mid + Math.imul(ah2, bl7) | 0;\n          hi = hi + Math.imul(ah2, bh7) | 0;\n          lo = lo + Math.imul(al1, bl8) | 0;\n          mid = mid + Math.imul(al1, bh8) | 0;\n          mid = mid + Math.imul(ah1, bl8) | 0;\n          hi = hi + Math.imul(ah1, bh8) | 0;\n          lo = lo + Math.imul(al0, bl9) | 0;\n          mid = mid + Math.imul(al0, bh9) | 0;\n          mid = mid + Math.imul(ah0, bl9) | 0;\n          hi = hi + Math.imul(ah0, bh9) | 0;\n          var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;\n          w9 &= 67108863;\n          lo = Math.imul(al9, bl1);\n          mid = Math.imul(al9, bh1);\n          mid = mid + Math.imul(ah9, bl1) | 0;\n          hi = Math.imul(ah9, bh1);\n          lo = lo + Math.imul(al8, bl2) | 0;\n          mid = mid + Math.imul(al8, bh2) | 0;\n          mid = mid + Math.imul(ah8, bl2) | 0;\n          hi = hi + Math.imul(ah8, bh2) | 0;\n          lo = lo + Math.imul(al7, bl3) | 0;\n          mid = mid + Math.imul(al7, bh3) | 0;\n          mid = mid + Math.imul(ah7, bl3) | 0;\n          hi = hi + Math.imul(ah7, bh3) | 0;\n          lo = lo + Math.imul(al6, bl4) | 0;\n          mid = mid + Math.imul(al6, bh4) | 0;\n          mid = mid + Math.imul(ah6, bl4) | 0;\n          hi = hi + Math.imul(ah6, bh4) | 0;\n          lo = lo + Math.imul(al5, bl5) | 0;\n          mid = mid + Math.imul(al5, bh5) | 0;\n          mid = mid + Math.imul(ah5, bl5) | 0;\n          hi = hi + Math.imul(ah5, bh5) | 0;\n          lo = lo + Math.imul(al4, bl6) | 0;\n          mid = mid + Math.imul(al4, bh6) | 0;\n          mid = mid + Math.imul(ah4, bl6) | 0;\n          hi = hi + Math.imul(ah4, bh6) | 0;\n          lo = lo + Math.imul(al3, bl7) | 0;\n          mid = mid + Math.imul(al3, bh7) | 0;\n          mid = mid + Math.imul(ah3, bl7) | 0;\n          hi = hi + Math.imul(ah3, bh7) | 0;\n          lo = lo + Math.imul(al2, bl8) | 0;\n          mid = mid + Math.imul(al2, bh8) | 0;\n          mid = mid + Math.imul(ah2, bl8) | 0;\n          hi = hi + Math.imul(ah2, bh8) | 0;\n          lo = lo + Math.imul(al1, bl9) | 0;\n          mid = mid + Math.imul(al1, bh9) | 0;\n          mid = mid + Math.imul(ah1, bl9) | 0;\n          hi = hi + Math.imul(ah1, bh9) | 0;\n          var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;\n          w10 &= 67108863;\n          lo = Math.imul(al9, bl2);\n          mid = Math.imul(al9, bh2);\n          mid = mid + Math.imul(ah9, bl2) | 0;\n          hi = Math.imul(ah9, bh2);\n          lo = lo + Math.imul(al8, bl3) | 0;\n          mid = mid + Math.imul(al8, bh3) | 0;\n          mid = mid + Math.imul(ah8, bl3) | 0;\n          hi = hi + Math.imul(ah8, bh3) | 0;\n          lo = lo + Math.imul(al7, bl4) | 0;\n          mid = mid + Math.imul(al7, bh4) | 0;\n          mid = mid + Math.imul(ah7, bl4) | 0;\n          hi = hi + Math.imul(ah7, bh4) | 0;\n          lo = lo + Math.imul(al6, bl5) | 0;\n          mid = mid + Math.imul(al6, bh5) | 0;\n          mid = mid + Math.imul(ah6, bl5) | 0;\n          hi = hi + Math.imul(ah6, bh5) | 0;\n          lo = lo + Math.imul(al5, bl6) | 0;\n          mid = mid + Math.imul(al5, bh6) | 0;\n          mid = mid + Math.imul(ah5, bl6) | 0;\n          hi = hi + Math.imul(ah5, bh6) | 0;\n          lo = lo + Math.imul(al4, bl7) | 0;\n          mid = mid + Math.imul(al4, bh7) | 0;\n          mid = mid + Math.imul(ah4, bl7) | 0;\n          hi = hi + Math.imul(ah4, bh7) | 0;\n          lo = lo + Math.imul(al3, bl8) | 0;\n          mid = mid + Math.imul(al3, bh8) | 0;\n          mid = mid + Math.imul(ah3, bl8) | 0;\n          hi = hi + Math.imul(ah3, bh8) | 0;\n          lo = lo + Math.imul(al2, bl9) | 0;\n          mid = mid + Math.imul(al2, bh9) | 0;\n          mid = mid + Math.imul(ah2, bl9) | 0;\n          hi = hi + Math.imul(ah2, bh9) | 0;\n          var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;\n          w11 &= 67108863;\n          lo = Math.imul(al9, bl3);\n          mid = Math.imul(al9, bh3);\n          mid = mid + Math.imul(ah9, bl3) | 0;\n          hi = Math.imul(ah9, bh3);\n          lo = lo + Math.imul(al8, bl4) | 0;\n          mid = mid + Math.imul(al8, bh4) | 0;\n          mid = mid + Math.imul(ah8, bl4) | 0;\n          hi = hi + Math.imul(ah8, bh4) | 0;\n          lo = lo + Math.imul(al7, bl5) | 0;\n          mid = mid + Math.imul(al7, bh5) | 0;\n          mid = mid + Math.imul(ah7, bl5) | 0;\n          hi = hi + Math.imul(ah7, bh5) | 0;\n          lo = lo + Math.imul(al6, bl6) | 0;\n          mid = mid + Math.imul(al6, bh6) | 0;\n          mid = mid + Math.imul(ah6, bl6) | 0;\n          hi = hi + Math.imul(ah6, bh6) | 0;\n          lo = lo + Math.imul(al5, bl7) | 0;\n          mid = mid + Math.imul(al5, bh7) | 0;\n          mid = mid + Math.imul(ah5, bl7) | 0;\n          hi = hi + Math.imul(ah5, bh7) | 0;\n          lo = lo + Math.imul(al4, bl8) | 0;\n          mid = mid + Math.imul(al4, bh8) | 0;\n          mid = mid + Math.imul(ah4, bl8) | 0;\n          hi = hi + Math.imul(ah4, bh8) | 0;\n          lo = lo + Math.imul(al3, bl9) | 0;\n          mid = mid + Math.imul(al3, bh9) | 0;\n          mid = mid + Math.imul(ah3, bl9) | 0;\n          hi = hi + Math.imul(ah3, bh9) | 0;\n          var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;\n          w12 &= 67108863;\n          lo = Math.imul(al9, bl4);\n          mid = Math.imul(al9, bh4);\n          mid = mid + Math.imul(ah9, bl4) | 0;\n          hi = Math.imul(ah9, bh4);\n          lo = lo + Math.imul(al8, bl5) | 0;\n          mid = mid + Math.imul(al8, bh5) | 0;\n          mid = mid + Math.imul(ah8, bl5) | 0;\n          hi = hi + Math.imul(ah8, bh5) | 0;\n          lo = lo + Math.imul(al7, bl6) | 0;\n          mid = mid + Math.imul(al7, bh6) | 0;\n          mid = mid + Math.imul(ah7, bl6) | 0;\n          hi = hi + Math.imul(ah7, bh6) | 0;\n          lo = lo + Math.imul(al6, bl7) | 0;\n          mid = mid + Math.imul(al6, bh7) | 0;\n          mid = mid + Math.imul(ah6, bl7) | 0;\n          hi = hi + Math.imul(ah6, bh7) | 0;\n          lo = lo + Math.imul(al5, bl8) | 0;\n          mid = mid + Math.imul(al5, bh8) | 0;\n          mid = mid + Math.imul(ah5, bl8) | 0;\n          hi = hi + Math.imul(ah5, bh8) | 0;\n          lo = lo + Math.imul(al4, bl9) | 0;\n          mid = mid + Math.imul(al4, bh9) | 0;\n          mid = mid + Math.imul(ah4, bl9) | 0;\n          hi = hi + Math.imul(ah4, bh9) | 0;\n          var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;\n          w13 &= 67108863;\n          lo = Math.imul(al9, bl5);\n          mid = Math.imul(al9, bh5);\n          mid = mid + Math.imul(ah9, bl5) | 0;\n          hi = Math.imul(ah9, bh5);\n          lo = lo + Math.imul(al8, bl6) | 0;\n          mid = mid + Math.imul(al8, bh6) | 0;\n          mid = mid + Math.imul(ah8, bl6) | 0;\n          hi = hi + Math.imul(ah8, bh6) | 0;\n          lo = lo + Math.imul(al7, bl7) | 0;\n          mid = mid + Math.imul(al7, bh7) | 0;\n          mid = mid + Math.imul(ah7, bl7) | 0;\n          hi = hi + Math.imul(ah7, bh7) | 0;\n          lo = lo + Math.imul(al6, bl8) | 0;\n          mid = mid + Math.imul(al6, bh8) | 0;\n          mid = mid + Math.imul(ah6, bl8) | 0;\n          hi = hi + Math.imul(ah6, bh8) | 0;\n          lo = lo + Math.imul(al5, bl9) | 0;\n          mid = mid + Math.imul(al5, bh9) | 0;\n          mid = mid + Math.imul(ah5, bl9) | 0;\n          hi = hi + Math.imul(ah5, bh9) | 0;\n          var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;\n          w14 &= 67108863;\n          lo = Math.imul(al9, bl6);\n          mid = Math.imul(al9, bh6);\n          mid = mid + Math.imul(ah9, bl6) | 0;\n          hi = Math.imul(ah9, bh6);\n          lo = lo + Math.imul(al8, bl7) | 0;\n          mid = mid + Math.imul(al8, bh7) | 0;\n          mid = mid + Math.imul(ah8, bl7) | 0;\n          hi = hi + Math.imul(ah8, bh7) | 0;\n          lo = lo + Math.imul(al7, bl8) | 0;\n          mid = mid + Math.imul(al7, bh8) | 0;\n          mid = mid + Math.imul(ah7, bl8) | 0;\n          hi = hi + Math.imul(ah7, bh8) | 0;\n          lo = lo + Math.imul(al6, bl9) | 0;\n          mid = mid + Math.imul(al6, bh9) | 0;\n          mid = mid + Math.imul(ah6, bl9) | 0;\n          hi = hi + Math.imul(ah6, bh9) | 0;\n          var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;\n          w15 &= 67108863;\n          lo = Math.imul(al9, bl7);\n          mid = Math.imul(al9, bh7);\n          mid = mid + Math.imul(ah9, bl7) | 0;\n          hi = Math.imul(ah9, bh7);\n          lo = lo + Math.imul(al8, bl8) | 0;\n          mid = mid + Math.imul(al8, bh8) | 0;\n          mid = mid + Math.imul(ah8, bl8) | 0;\n          hi = hi + Math.imul(ah8, bh8) | 0;\n          lo = lo + Math.imul(al7, bl9) | 0;\n          mid = mid + Math.imul(al7, bh9) | 0;\n          mid = mid + Math.imul(ah7, bl9) | 0;\n          hi = hi + Math.imul(ah7, bh9) | 0;\n          var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;\n          w16 &= 67108863;\n          lo = Math.imul(al9, bl8);\n          mid = Math.imul(al9, bh8);\n          mid = mid + Math.imul(ah9, bl8) | 0;\n          hi = Math.imul(ah9, bh8);\n          lo = lo + Math.imul(al8, bl9) | 0;\n          mid = mid + Math.imul(al8, bh9) | 0;\n          mid = mid + Math.imul(ah8, bl9) | 0;\n          hi = hi + Math.imul(ah8, bh9) | 0;\n          var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;\n          w17 &= 67108863;\n          lo = Math.imul(al9, bl9);\n          mid = Math.imul(al9, bh9);\n          mid = mid + Math.imul(ah9, bl9) | 0;\n          hi = Math.imul(ah9, bh9);\n          var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;\n          c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;\n          w18 &= 67108863;\n          o[0] = w0;\n          o[1] = w1;\n          o[2] = w2;\n          o[3] = w3;\n          o[4] = w4;\n          o[5] = w5;\n          o[6] = w6;\n          o[7] = w7;\n          o[8] = w8;\n          o[9] = w9;\n          o[10] = w10;\n          o[11] = w11;\n          o[12] = w12;\n          o[13] = w13;\n          o[14] = w14;\n          o[15] = w15;\n          o[16] = w16;\n          o[17] = w17;\n          o[18] = w18;\n          if (c !== 0) {\n            o[19] = c;\n            out.length++;\n          }\n          return out;\n        };\n        if (!Math.imul) {\n          comb10MulTo = smallMulTo;\n        }\n        function bigMulTo(self, num, out) {\n          out.negative = num.negative ^ self.negative;\n          out.length = self.length + num.length;\n          var carry = 0;\n          var hncarry = 0;\n          for (var k = 0; k < out.length - 1; k++) {\n            var ncarry = hncarry;\n            hncarry = 0;\n            var rword = carry & 67108863;\n            var maxJ = Math.min(k, num.length - 1);\n            for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {\n              var i = k - j;\n              var a = self.words[i] | 0;\n              var b = num.words[j] | 0;\n              var r = a * b;\n              var lo = r & 67108863;\n              ncarry = ncarry + (r / 67108864 | 0) | 0;\n              lo = lo + rword | 0;\n              rword = lo & 67108863;\n              ncarry = ncarry + (lo >>> 26) | 0;\n              hncarry += ncarry >>> 26;\n              ncarry &= 67108863;\n            }\n            out.words[k] = rword;\n            carry = ncarry;\n            ncarry = hncarry;\n          }\n          if (carry !== 0) {\n            out.words[k] = carry;\n          } else {\n            out.length--;\n          }\n          return out._strip();\n        }\n        function jumboMulTo(self, num, out) {\n          return bigMulTo(self, num, out);\n        }\n        BN2.prototype.mulTo = function mulTo(num, out) {\n          var res;\n          var len = this.length + num.length;\n          if (this.length === 10 && num.length === 10) {\n            res = comb10MulTo(this, num, out);\n          } else if (len < 63) {\n            res = smallMulTo(this, num, out);\n          } else if (len < 1024) {\n            res = bigMulTo(this, num, out);\n          } else {\n            res = jumboMulTo(this, num, out);\n          }\n          return res;\n        };\n        function FFTM(x, y) {\n          this.x = x;\n          this.y = y;\n        }\n        FFTM.prototype.makeRBT = function makeRBT(N) {\n          var t = new Array(N);\n          var l = BN2.prototype._countBits(N) - 1;\n          for (var i = 0; i < N; i++) {\n            t[i] = this.revBin(i, l, N);\n          }\n          return t;\n        };\n        FFTM.prototype.revBin = function revBin(x, l, N) {\n          if (x === 0 || x === N - 1)\n            return x;\n          var rb = 0;\n          for (var i = 0; i < l; i++) {\n            rb |= (x & 1) << l - i - 1;\n            x >>= 1;\n          }\n          return rb;\n        };\n        FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {\n          for (var i = 0; i < N; i++) {\n            rtws[i] = rws[rbt[i]];\n            itws[i] = iws[rbt[i]];\n          }\n        };\n        FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {\n          this.permute(rbt, rws, iws, rtws, itws, N);\n          for (var s = 1; s < N; s <<= 1) {\n            var l = s << 1;\n            var rtwdf = Math.cos(2 * Math.PI / l);\n            var itwdf = Math.sin(2 * Math.PI / l);\n            for (var p = 0; p < N; p += l) {\n              var rtwdf_ = rtwdf;\n              var itwdf_ = itwdf;\n              for (var j = 0; j < s; j++) {\n                var re = rtws[p + j];\n                var ie = itws[p + j];\n                var ro = rtws[p + j + s];\n                var io = itws[p + j + s];\n                var rx = rtwdf_ * ro - itwdf_ * io;\n                io = rtwdf_ * io + itwdf_ * ro;\n                ro = rx;\n                rtws[p + j] = re + ro;\n                itws[p + j] = ie + io;\n                rtws[p + j + s] = re - ro;\n                itws[p + j + s] = ie - io;\n                if (j !== l) {\n                  rx = rtwdf * rtwdf_ - itwdf * itwdf_;\n                  itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;\n                  rtwdf_ = rx;\n                }\n              }\n            }\n          }\n        };\n        FFTM.prototype.guessLen13b = function guessLen13b(n, m) {\n          var N = Math.max(m, n) | 1;\n          var odd = N & 1;\n          var i = 0;\n          for (N = N / 2 | 0; N; N = N >>> 1) {\n            i++;\n          }\n          return 1 << i + 1 + odd;\n        };\n        FFTM.prototype.conjugate = function conjugate(rws, iws, N) {\n          if (N <= 1)\n            return;\n          for (var i = 0; i < N / 2; i++) {\n            var t = rws[i];\n            rws[i] = rws[N - i - 1];\n            rws[N - i - 1] = t;\n            t = iws[i];\n            iws[i] = -iws[N - i - 1];\n            iws[N - i - 1] = -t;\n          }\n        };\n        FFTM.prototype.normalize13b = function normalize13b(ws, N) {\n          var carry = 0;\n          for (var i = 0; i < N / 2; i++) {\n            var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;\n            ws[i] = w & 67108863;\n            if (w < 67108864) {\n              carry = 0;\n            } else {\n              carry = w / 67108864 | 0;\n            }\n          }\n          return ws;\n        };\n        FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {\n          var carry = 0;\n          for (var i = 0; i < len; i++) {\n            carry = carry + (ws[i] | 0);\n            rws[2 * i] = carry & 8191;\n            carry = carry >>> 13;\n            rws[2 * i + 1] = carry & 8191;\n            carry = carry >>> 13;\n          }\n          for (i = 2 * len; i < N; ++i) {\n            rws[i] = 0;\n          }\n          assert3(carry === 0);\n          assert3((carry & ~8191) === 0);\n        };\n        FFTM.prototype.stub = function stub(N) {\n          var ph = new Array(N);\n          for (var i = 0; i < N; i++) {\n            ph[i] = 0;\n          }\n          return ph;\n        };\n        FFTM.prototype.mulp = function mulp(x, y, out) {\n          var N = 2 * this.guessLen13b(x.length, y.length);\n          var rbt = this.makeRBT(N);\n          var _ = this.stub(N);\n          var rws = new Array(N);\n          var rwst = new Array(N);\n          var iwst = new Array(N);\n          var nrws = new Array(N);\n          var nrwst = new Array(N);\n          var niwst = new Array(N);\n          var rmws = out.words;\n          rmws.length = N;\n          this.convert13b(x.words, x.length, rws, N);\n          this.convert13b(y.words, y.length, nrws, N);\n          this.transform(rws, _, rwst, iwst, N, rbt);\n          this.transform(nrws, _, nrwst, niwst, N, rbt);\n          for (var i = 0; i < N; i++) {\n            var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];\n            iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];\n            rwst[i] = rx;\n          }\n          this.conjugate(rwst, iwst, N);\n          this.transform(rwst, iwst, rmws, _, N, rbt);\n          this.conjugate(rmws, _, N);\n          this.normalize13b(rmws, N);\n          out.negative = x.negative ^ y.negative;\n          out.length = x.length + y.length;\n          return out._strip();\n        };\n        BN2.prototype.mul = function mul(num) {\n          var out = new BN2(null);\n          out.words = new Array(this.length + num.length);\n          return this.mulTo(num, out);\n        };\n        BN2.prototype.mulf = function mulf(num) {\n          var out = new BN2(null);\n          out.words = new Array(this.length + num.length);\n          return jumboMulTo(this, num, out);\n        };\n        BN2.prototype.imul = function imul(num) {\n          return this.clone().mulTo(num, this);\n        };\n        BN2.prototype.imuln = function imuln(num) {\n          var isNegNum = num < 0;\n          if (isNegNum)\n            num = -num;\n          assert3(typeof num === \"number\");\n          assert3(num < 67108864);\n          var carry = 0;\n          for (var i = 0; i < this.length; i++) {\n            var w = (this.words[i] | 0) * num;\n            var lo = (w & 67108863) + (carry & 67108863);\n            carry >>= 26;\n            carry += w / 67108864 | 0;\n            carry += lo >>> 26;\n            this.words[i] = lo & 67108863;\n          }\n          if (carry !== 0) {\n            this.words[i] = carry;\n            this.length++;\n          }\n          this.length = num === 0 ? 1 : this.length;\n          return isNegNum ? this.ineg() : this;\n        };\n        BN2.prototype.muln = function muln(num) {\n          return this.clone().imuln(num);\n        };\n        BN2.prototype.sqr = function sqr() {\n          return this.mul(this);\n        };\n        BN2.prototype.isqr = function isqr() {\n          return this.imul(this.clone());\n        };\n        BN2.prototype.pow = function pow(num) {\n          var w = toBitArray(num);\n          if (w.length === 0)\n            return new BN2(1);\n          var res = this;\n          for (var i = 0; i < w.length; i++, res = res.sqr()) {\n            if (w[i] !== 0)\n              break;\n          }\n          if (++i < w.length) {\n            for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {\n              if (w[i] === 0)\n                continue;\n              res = res.mul(q);\n            }\n          }\n          return res;\n        };\n        BN2.prototype.iushln = function iushln(bits) {\n          assert3(typeof bits === \"number\" && bits >= 0);\n          var r = bits % 26;\n          var s = (bits - r) / 26;\n          var carryMask = 67108863 >>> 26 - r << 26 - r;\n          var i;\n          if (r !== 0) {\n            var carry = 0;\n            for (i = 0; i < this.length; i++) {\n              var newCarry = this.words[i] & carryMask;\n              var c = (this.words[i] | 0) - newCarry << r;\n              this.words[i] = c | carry;\n              carry = newCarry >>> 26 - r;\n            }\n            if (carry) {\n              this.words[i] = carry;\n              this.length++;\n            }\n          }\n          if (s !== 0) {\n            for (i = this.length - 1; i >= 0; i--) {\n              this.words[i + s] = this.words[i];\n            }\n            for (i = 0; i < s; i++) {\n              this.words[i] = 0;\n            }\n            this.length += s;\n          }\n          return this._strip();\n        };\n        BN2.prototype.ishln = function ishln(bits) {\n          assert3(this.negative === 0);\n          return this.iushln(bits);\n        };\n        BN2.prototype.iushrn = function iushrn(bits, hint, extended) {\n          assert3(typeof bits === \"number\" && bits >= 0);\n          var h;\n          if (hint) {\n            h = (hint - hint % 26) / 26;\n          } else {\n            h = 0;\n          }\n          var r = bits % 26;\n          var s = Math.min((bits - r) / 26, this.length);\n          var mask2 = 67108863 ^ 67108863 >>> r << r;\n          var maskedWords = extended;\n          h -= s;\n          h = Math.max(0, h);\n          if (maskedWords) {\n            for (var i = 0; i < s; i++) {\n              maskedWords.words[i] = this.words[i];\n            }\n            maskedWords.length = s;\n          }\n          if (s === 0) {\n          } else if (this.length > s) {\n            this.length -= s;\n            for (i = 0; i < this.length; i++) {\n              this.words[i] = this.words[i + s];\n            }\n          } else {\n            this.words[0] = 0;\n            this.length = 1;\n          }\n          var carry = 0;\n          for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {\n            var word = this.words[i] | 0;\n            this.words[i] = carry << 26 - r | word >>> r;\n            carry = word & mask2;\n          }\n          if (maskedWords && carry !== 0) {\n            maskedWords.words[maskedWords.length++] = carry;\n          }\n          if (this.length === 0) {\n            this.words[0] = 0;\n            this.length = 1;\n          }\n          return this._strip();\n        };\n        BN2.prototype.ishrn = function ishrn(bits, hint, extended) {\n          assert3(this.negative === 0);\n          return this.iushrn(bits, hint, extended);\n        };\n        BN2.prototype.shln = function shln(bits) {\n          return this.clone().ishln(bits);\n        };\n        BN2.prototype.ushln = function ushln(bits) {\n          return this.clone().iushln(bits);\n        };\n        BN2.prototype.shrn = function shrn(bits) {\n          return this.clone().ishrn(bits);\n        };\n        BN2.prototype.ushrn = function ushrn(bits) {\n          return this.clone().iushrn(bits);\n        };\n        BN2.prototype.testn = function testn(bit) {\n          assert3(typeof bit === \"number\" && bit >= 0);\n          var r = bit % 26;\n          var s = (bit - r) / 26;\n          var q = 1 << r;\n          if (this.length <= s)\n            return false;\n          var w = this.words[s];\n          return !!(w & q);\n        };\n        BN2.prototype.imaskn = function imaskn(bits) {\n          assert3(typeof bits === \"number\" && bits >= 0);\n          var r = bits % 26;\n          var s = (bits - r) / 26;\n          assert3(this.negative === 0, \"imaskn works only with positive numbers\");\n          if (this.length <= s) {\n            return this;\n          }\n          if (r !== 0) {\n            s++;\n          }\n          this.length = Math.min(s, this.length);\n          if (r !== 0) {\n            var mask2 = 67108863 ^ 67108863 >>> r << r;\n            this.words[this.length - 1] &= mask2;\n          }\n          return this._strip();\n        };\n        BN2.prototype.maskn = function maskn(bits) {\n          return this.clone().imaskn(bits);\n        };\n        BN2.prototype.iaddn = function iaddn(num) {\n          assert3(typeof num === \"number\");\n          assert3(num < 67108864);\n          if (num < 0)\n            return this.isubn(-num);\n          if (this.negative !== 0) {\n            if (this.length === 1 && (this.words[0] | 0) <= num) {\n              this.words[0] = num - (this.words[0] | 0);\n              this.negative = 0;\n              return this;\n            }\n            this.negative = 0;\n            this.isubn(num);\n            this.negative = 1;\n            return this;\n          }\n          return this._iaddn(num);\n        };\n        BN2.prototype._iaddn = function _iaddn(num) {\n          this.words[0] += num;\n          for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {\n            this.words[i] -= 67108864;\n            if (i === this.length - 1) {\n              this.words[i + 1] = 1;\n            } else {\n              this.words[i + 1]++;\n            }\n          }\n          this.length = Math.max(this.length, i + 1);\n          return this;\n        };\n        BN2.prototype.isubn = function isubn(num) {\n          assert3(typeof num === \"number\");\n          assert3(num < 67108864);\n          if (num < 0)\n            return this.iaddn(-num);\n          if (this.negative !== 0) {\n            this.negative = 0;\n            this.iaddn(num);\n            this.negative = 1;\n            return this;\n          }\n          this.words[0] -= num;\n          if (this.length === 1 && this.words[0] < 0) {\n            this.words[0] = -this.words[0];\n            this.negative = 1;\n          } else {\n            for (var i = 0; i < this.length && this.words[i] < 0; i++) {\n              this.words[i] += 67108864;\n              this.words[i + 1] -= 1;\n            }\n          }\n          return this._strip();\n        };\n        BN2.prototype.addn = function addn(num) {\n          return this.clone().iaddn(num);\n        };\n        BN2.prototype.subn = function subn(num) {\n          return this.clone().isubn(num);\n        };\n        BN2.prototype.iabs = function iabs() {\n          this.negative = 0;\n          return this;\n        };\n        BN2.prototype.abs = function abs() {\n          return this.clone().iabs();\n        };\n        BN2.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {\n          var len = num.length + shift;\n          var i;\n          this._expand(len);\n          var w;\n          var carry = 0;\n          for (i = 0; i < num.length; i++) {\n            w = (this.words[i + shift] | 0) + carry;\n            var right = (num.words[i] | 0) * mul;\n            w -= right & 67108863;\n            carry = (w >> 26) - (right / 67108864 | 0);\n            this.words[i + shift] = w & 67108863;\n          }\n          for (; i < this.length - shift; i++) {\n            w = (this.words[i + shift] | 0) + carry;\n            carry = w >> 26;\n            this.words[i + shift] = w & 67108863;\n          }\n          if (carry === 0)\n            return this._strip();\n          assert3(carry === -1);\n          carry = 0;\n          for (i = 0; i < this.length; i++) {\n            w = -(this.words[i] | 0) + carry;\n            carry = w >> 26;\n            this.words[i] = w & 67108863;\n          }\n          this.negative = 1;\n          return this._strip();\n        };\n        BN2.prototype._wordDiv = function _wordDiv(num, mode) {\n          var shift = this.length - num.length;\n          var a = this.clone();\n          var b = num;\n          var bhi = b.words[b.length - 1] | 0;\n          var bhiBits = this._countBits(bhi);\n          shift = 26 - bhiBits;\n          if (shift !== 0) {\n            b = b.ushln(shift);\n            a.iushln(shift);\n            bhi = b.words[b.length - 1] | 0;\n          }\n          var m = a.length - b.length;\n          var q;\n          if (mode !== \"mod\") {\n            q = new BN2(null);\n            q.length = m + 1;\n            q.words = new Array(q.length);\n            for (var i = 0; i < q.length; i++) {\n              q.words[i] = 0;\n            }\n          }\n          var diff = a.clone()._ishlnsubmul(b, 1, m);\n          if (diff.negative === 0) {\n            a = diff;\n            if (q) {\n              q.words[m] = 1;\n            }\n          }\n          for (var j = m - 1; j >= 0; j--) {\n            var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);\n            qj = Math.min(qj / bhi | 0, 67108863);\n            a._ishlnsubmul(b, qj, j);\n            while (a.negative !== 0) {\n              qj--;\n              a.negative = 0;\n              a._ishlnsubmul(b, 1, j);\n              if (!a.isZero()) {\n                a.negative ^= 1;\n              }\n            }\n            if (q) {\n              q.words[j] = qj;\n            }\n          }\n          if (q) {\n            q._strip();\n          }\n          a._strip();\n          if (mode !== \"div\" && shift !== 0) {\n            a.iushrn(shift);\n          }\n          return {\n            div: q || null,\n            mod: a\n          };\n        };\n        BN2.prototype.divmod = function divmod(num, mode, positive) {\n          assert3(!num.isZero());\n          if (this.isZero()) {\n            return {\n              div: new BN2(0),\n              mod: new BN2(0)\n            };\n          }\n          var div, mod2, res;\n          if (this.negative !== 0 && num.negative === 0) {\n            res = this.neg().divmod(num, mode);\n            if (mode !== \"mod\") {\n              div = res.div.neg();\n            }\n            if (mode !== \"div\") {\n              mod2 = res.mod.neg();\n              if (positive && mod2.negative !== 0) {\n                mod2.iadd(num);\n              }\n            }\n            return {\n              div,\n              mod: mod2\n            };\n          }\n          if (this.negative === 0 && num.negative !== 0) {\n            res = this.divmod(num.neg(), mode);\n            if (mode !== \"mod\") {\n              div = res.div.neg();\n            }\n            return {\n              div,\n              mod: res.mod\n            };\n          }\n          if ((this.negative & num.negative) !== 0) {\n            res = this.neg().divmod(num.neg(), mode);\n            if (mode !== \"div\") {\n              mod2 = res.mod.neg();\n              if (positive && mod2.negative !== 0) {\n                mod2.isub(num);\n              }\n            }\n            return {\n              div: res.div,\n              mod: mod2\n            };\n          }\n          if (num.length > this.length || this.cmp(num) < 0) {\n            return {\n              div: new BN2(0),\n              mod: this\n            };\n          }\n          if (num.length === 1) {\n            if (mode === \"div\") {\n              return {\n                div: this.divn(num.words[0]),\n                mod: null\n              };\n            }\n            if (mode === \"mod\") {\n              return {\n                div: null,\n                mod: new BN2(this.modrn(num.words[0]))\n              };\n            }\n            return {\n              div: this.divn(num.words[0]),\n              mod: new BN2(this.modrn(num.words[0]))\n            };\n          }\n          return this._wordDiv(num, mode);\n        };\n        BN2.prototype.div = function div(num) {\n          return this.divmod(num, \"div\", false).div;\n        };\n        BN2.prototype.mod = function mod2(num) {\n          return this.divmod(num, \"mod\", false).mod;\n        };\n        BN2.prototype.umod = function umod(num) {\n          return this.divmod(num, \"mod\", true).mod;\n        };\n        BN2.prototype.divRound = function divRound(num) {\n          var dm = this.divmod(num);\n          if (dm.mod.isZero())\n            return dm.div;\n          var mod2 = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;\n          var half = num.ushrn(1);\n          var r2 = num.andln(1);\n          var cmp = mod2.cmp(half);\n          if (cmp < 0 || r2 === 1 && cmp === 0)\n            return dm.div;\n          return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);\n        };\n        BN2.prototype.modrn = function modrn(num) {\n          var isNegNum = num < 0;\n          if (isNegNum)\n            num = -num;\n          assert3(num <= 67108863);\n          var p = (1 << 26) % num;\n          var acc = 0;\n          for (var i = this.length - 1; i >= 0; i--) {\n            acc = (p * acc + (this.words[i] | 0)) % num;\n          }\n          return isNegNum ? -acc : acc;\n        };\n        BN2.prototype.modn = function modn(num) {\n          return this.modrn(num);\n        };\n        BN2.prototype.idivn = function idivn(num) {\n          var isNegNum = num < 0;\n          if (isNegNum)\n            num = -num;\n          assert3(num <= 67108863);\n          var carry = 0;\n          for (var i = this.length - 1; i >= 0; i--) {\n            var w = (this.words[i] | 0) + carry * 67108864;\n            this.words[i] = w / num | 0;\n            carry = w % num;\n          }\n          this._strip();\n          return isNegNum ? this.ineg() : this;\n        };\n        BN2.prototype.divn = function divn(num) {\n          return this.clone().idivn(num);\n        };\n        BN2.prototype.egcd = function egcd(p) {\n          assert3(p.negative === 0);\n          assert3(!p.isZero());\n          var x = this;\n          var y = p.clone();\n          if (x.negative !== 0) {\n            x = x.umod(p);\n          } else {\n            x = x.clone();\n          }\n          var A = new BN2(1);\n          var B = new BN2(0);\n          var C = new BN2(0);\n          var D = new BN2(1);\n          var g = 0;\n          while (x.isEven() && y.isEven()) {\n            x.iushrn(1);\n            y.iushrn(1);\n            ++g;\n          }\n          var yp = y.clone();\n          var xp = x.clone();\n          while (!x.isZero()) {\n            for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)\n              ;\n            if (i > 0) {\n              x.iushrn(i);\n              while (i-- > 0) {\n                if (A.isOdd() || B.isOdd()) {\n                  A.iadd(yp);\n                  B.isub(xp);\n                }\n                A.iushrn(1);\n                B.iushrn(1);\n              }\n            }\n            for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)\n              ;\n            if (j > 0) {\n              y.iushrn(j);\n              while (j-- > 0) {\n                if (C.isOdd() || D.isOdd()) {\n                  C.iadd(yp);\n                  D.isub(xp);\n                }\n                C.iushrn(1);\n                D.iushrn(1);\n              }\n            }\n            if (x.cmp(y) >= 0) {\n              x.isub(y);\n              A.isub(C);\n              B.isub(D);\n            } else {\n              y.isub(x);\n              C.isub(A);\n              D.isub(B);\n            }\n          }\n          return {\n            a: C,\n            b: D,\n            gcd: y.iushln(g)\n          };\n        };\n        BN2.prototype._invmp = function _invmp(p) {\n          assert3(p.negative === 0);\n          assert3(!p.isZero());\n          var a = this;\n          var b = p.clone();\n          if (a.negative !== 0) {\n            a = a.umod(p);\n          } else {\n            a = a.clone();\n          }\n          var x1 = new BN2(1);\n          var x2 = new BN2(0);\n          var delta = b.clone();\n          while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {\n            for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)\n              ;\n            if (i > 0) {\n              a.iushrn(i);\n              while (i-- > 0) {\n                if (x1.isOdd()) {\n                  x1.iadd(delta);\n                }\n                x1.iushrn(1);\n              }\n            }\n            for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)\n              ;\n            if (j > 0) {\n              b.iushrn(j);\n              while (j-- > 0) {\n                if (x2.isOdd()) {\n                  x2.iadd(delta);\n                }\n                x2.iushrn(1);\n              }\n            }\n            if (a.cmp(b) >= 0) {\n              a.isub(b);\n              x1.isub(x2);\n            } else {\n              b.isub(a);\n              x2.isub(x1);\n            }\n          }\n          var res;\n          if (a.cmpn(1) === 0) {\n            res = x1;\n          } else {\n            res = x2;\n          }\n          if (res.cmpn(0) < 0) {\n            res.iadd(p);\n          }\n          return res;\n        };\n        BN2.prototype.gcd = function gcd(num) {\n          if (this.isZero())\n            return num.abs();\n          if (num.isZero())\n            return this.abs();\n          var a = this.clone();\n          var b = num.clone();\n          a.negative = 0;\n          b.negative = 0;\n          for (var shift = 0; a.isEven() && b.isEven(); shift++) {\n            a.iushrn(1);\n            b.iushrn(1);\n          }\n          do {\n            while (a.isEven()) {\n              a.iushrn(1);\n            }\n            while (b.isEven()) {\n              b.iushrn(1);\n            }\n            var r = a.cmp(b);\n            if (r < 0) {\n              var t = a;\n              a = b;\n              b = t;\n            } else if (r === 0 || b.cmpn(1) === 0) {\n              break;\n            }\n            a.isub(b);\n          } while (true);\n          return b.iushln(shift);\n        };\n        BN2.prototype.invm = function invm(num) {\n          return this.egcd(num).a.umod(num);\n        };\n        BN2.prototype.isEven = function isEven() {\n          return (this.words[0] & 1) === 0;\n        };\n        BN2.prototype.isOdd = function isOdd() {\n          return (this.words[0] & 1) === 1;\n        };\n        BN2.prototype.andln = function andln(num) {\n          return this.words[0] & num;\n        };\n        BN2.prototype.bincn = function bincn(bit) {\n          assert3(typeof bit === \"number\");\n          var r = bit % 26;\n          var s = (bit - r) / 26;\n          var q = 1 << r;\n          if (this.length <= s) {\n            this._expand(s + 1);\n            this.words[s] |= q;\n            return this;\n          }\n          var carry = q;\n          for (var i = s; carry !== 0 && i < this.length; i++) {\n            var w = this.words[i] | 0;\n            w += carry;\n            carry = w >>> 26;\n            w &= 67108863;\n            this.words[i] = w;\n          }\n          if (carry !== 0) {\n            this.words[i] = carry;\n            this.length++;\n          }\n          return this;\n        };\n        BN2.prototype.isZero = function isZero() {\n          return this.length === 1 && this.words[0] === 0;\n        };\n        BN2.prototype.cmpn = function cmpn(num) {\n          var negative = num < 0;\n          if (this.negative !== 0 && !negative)\n            return -1;\n          if (this.negative === 0 && negative)\n            return 1;\n          this._strip();\n          var res;\n          if (this.length > 1) {\n            res = 1;\n          } else {\n            if (negative) {\n              num = -num;\n            }\n            assert3(num <= 67108863, \"Number is too big\");\n            var w = this.words[0] | 0;\n            res = w === num ? 0 : w < num ? -1 : 1;\n          }\n          if (this.negative !== 0)\n            return -res | 0;\n          return res;\n        };\n        BN2.prototype.cmp = function cmp(num) {\n          if (this.negative !== 0 && num.negative === 0)\n            return -1;\n          if (this.negative === 0 && num.negative !== 0)\n            return 1;\n          var res = this.ucmp(num);\n          if (this.negative !== 0)\n            return -res | 0;\n          return res;\n        };\n        BN2.prototype.ucmp = function ucmp(num) {\n          if (this.length > num.length)\n            return 1;\n          if (this.length < num.length)\n            return -1;\n          var res = 0;\n          for (var i = this.length - 1; i >= 0; i--) {\n            var a = this.words[i] | 0;\n            var b = num.words[i] | 0;\n            if (a === b)\n              continue;\n            if (a < b) {\n              res = -1;\n            } else if (a > b) {\n              res = 1;\n            }\n            break;\n          }\n          return res;\n        };\n        BN2.prototype.gtn = function gtn(num) {\n          return this.cmpn(num) === 1;\n        };\n        BN2.prototype.gt = function gt(num) {\n          return this.cmp(num) === 1;\n        };\n        BN2.prototype.gten = function gten(num) {\n          return this.cmpn(num) >= 0;\n        };\n        BN2.prototype.gte = function gte(num) {\n          return this.cmp(num) >= 0;\n        };\n        BN2.prototype.ltn = function ltn(num) {\n          return this.cmpn(num) === -1;\n        };\n        BN2.prototype.lt = function lt(num) {\n          return this.cmp(num) === -1;\n        };\n        BN2.prototype.lten = function lten(num) {\n          return this.cmpn(num) <= 0;\n        };\n        BN2.prototype.lte = function lte(num) {\n          return this.cmp(num) <= 0;\n        };\n        BN2.prototype.eqn = function eqn(num) {\n          return this.cmpn(num) === 0;\n        };\n        BN2.prototype.eq = function eq(num) {\n          return this.cmp(num) === 0;\n        };\n        BN2.red = function red(num) {\n          return new Red(num);\n        };\n        BN2.prototype.toRed = function toRed(ctx) {\n          assert3(!this.red, \"Already a number in reduction context\");\n          assert3(this.negative === 0, \"red works only with positives\");\n          return ctx.convertTo(this)._forceRed(ctx);\n        };\n        BN2.prototype.fromRed = function fromRed() {\n          assert3(this.red, \"fromRed works only with numbers in reduction context\");\n          return this.red.convertFrom(this);\n        };\n        BN2.prototype._forceRed = function _forceRed(ctx) {\n          this.red = ctx;\n          return this;\n        };\n        BN2.prototype.forceRed = function forceRed(ctx) {\n          assert3(!this.red, \"Already a number in reduction context\");\n          return this._forceRed(ctx);\n        };\n        BN2.prototype.redAdd = function redAdd(num) {\n          assert3(this.red, \"redAdd works only with red numbers\");\n          return this.red.add(this, num);\n        };\n        BN2.prototype.redIAdd = function redIAdd(num) {\n          assert3(this.red, \"redIAdd works only with red numbers\");\n          return this.red.iadd(this, num);\n        };\n        BN2.prototype.redSub = function redSub(num) {\n          assert3(this.red, \"redSub works only with red numbers\");\n          return this.red.sub(this, num);\n        };\n        BN2.prototype.redISub = function redISub(num) {\n          assert3(this.red, \"redISub works only with red numbers\");\n          return this.red.isub(this, num);\n        };\n        BN2.prototype.redShl = function redShl(num) {\n          assert3(this.red, \"redShl works only with red numbers\");\n          return this.red.shl(this, num);\n        };\n        BN2.prototype.redMul = function redMul(num) {\n          assert3(this.red, \"redMul works only with red numbers\");\n          this.red._verify2(this, num);\n          return this.red.mul(this, num);\n        };\n        BN2.prototype.redIMul = function redIMul(num) {\n          assert3(this.red, \"redMul works only with red numbers\");\n          this.red._verify2(this, num);\n          return this.red.imul(this, num);\n        };\n        BN2.prototype.redSqr = function redSqr() {\n          assert3(this.red, \"redSqr works only with red numbers\");\n          this.red._verify1(this);\n          return this.red.sqr(this);\n        };\n        BN2.prototype.redISqr = function redISqr() {\n          assert3(this.red, \"redISqr works only with red numbers\");\n          this.red._verify1(this);\n          return this.red.isqr(this);\n        };\n        BN2.prototype.redSqrt = function redSqrt() {\n          assert3(this.red, \"redSqrt works only with red numbers\");\n          this.red._verify1(this);\n          return this.red.sqrt(this);\n        };\n        BN2.prototype.redInvm = function redInvm() {\n          assert3(this.red, \"redInvm works only with red numbers\");\n          this.red._verify1(this);\n          return this.red.invm(this);\n        };\n        BN2.prototype.redNeg = function redNeg() {\n          assert3(this.red, \"redNeg works only with red numbers\");\n          this.red._verify1(this);\n          return this.red.neg(this);\n        };\n        BN2.prototype.redPow = function redPow(num) {\n          assert3(this.red && !num.red, \"redPow(normalNum)\");\n          this.red._verify1(this);\n          return this.red.pow(this, num);\n        };\n        var primes = {\n          k256: null,\n          p224: null,\n          p192: null,\n          p25519: null\n        };\n        function MPrime(name, p) {\n          this.name = name;\n          this.p = new BN2(p, 16);\n          this.n = this.p.bitLength();\n          this.k = new BN2(1).iushln(this.n).isub(this.p);\n          this.tmp = this._tmp();\n        }\n        MPrime.prototype._tmp = function _tmp() {\n          var tmp = new BN2(null);\n          tmp.words = new Array(Math.ceil(this.n / 13));\n          return tmp;\n        };\n        MPrime.prototype.ireduce = function ireduce(num) {\n          var r = num;\n          var rlen;\n          do {\n            this.split(r, this.tmp);\n            r = this.imulK(r);\n            r = r.iadd(this.tmp);\n            rlen = r.bitLength();\n          } while (rlen > this.n);\n          var cmp = rlen < this.n ? -1 : r.ucmp(this.p);\n          if (cmp === 0) {\n            r.words[0] = 0;\n            r.length = 1;\n          } else if (cmp > 0) {\n            r.isub(this.p);\n          } else {\n            if (r.strip !== void 0) {\n              r.strip();\n            } else {\n              r._strip();\n            }\n          }\n          return r;\n        };\n        MPrime.prototype.split = function split2(input, out) {\n          input.iushrn(this.n, 0, out);\n        };\n        MPrime.prototype.imulK = function imulK(num) {\n          return num.imul(this.k);\n        };\n        function K256() {\n          MPrime.call(\n            this,\n            \"k256\",\n            \"ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f\"\n          );\n        }\n        inherits(K256, MPrime);\n        K256.prototype.split = function split2(input, output) {\n          var mask2 = 4194303;\n          var outLen = Math.min(input.length, 9);\n          for (var i = 0; i < outLen; i++) {\n            output.words[i] = input.words[i];\n          }\n          output.length = outLen;\n          if (input.length <= 9) {\n            input.words[0] = 0;\n            input.length = 1;\n            return;\n          }\n          var prev = input.words[9];\n          output.words[output.length++] = prev & mask2;\n          for (i = 10; i < input.length; i++) {\n            var next = input.words[i] | 0;\n            input.words[i - 10] = (next & mask2) << 4 | prev >>> 22;\n            prev = next;\n          }\n          prev >>>= 22;\n          input.words[i - 10] = prev;\n          if (prev === 0 && input.length > 10) {\n            input.length -= 10;\n          } else {\n            input.length -= 9;\n          }\n        };\n        K256.prototype.imulK = function imulK(num) {\n          num.words[num.length] = 0;\n          num.words[num.length + 1] = 0;\n          num.length += 2;\n          var lo = 0;\n          for (var i = 0; i < num.length; i++) {\n            var w = num.words[i] | 0;\n            lo += w * 977;\n            num.words[i] = lo & 67108863;\n            lo = w * 64 + (lo / 67108864 | 0);\n          }\n          if (num.words[num.length - 1] === 0) {\n            num.length--;\n            if (num.words[num.length - 1] === 0) {\n              num.length--;\n            }\n          }\n          return num;\n        };\n        function P224() {\n          MPrime.call(\n            this,\n            \"p224\",\n            \"ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001\"\n          );\n        }\n        inherits(P224, MPrime);\n        function P192() {\n          MPrime.call(\n            this,\n            \"p192\",\n            \"ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff\"\n          );\n        }\n        inherits(P192, MPrime);\n        function P25519() {\n          MPrime.call(\n            this,\n            \"25519\",\n            \"7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed\"\n          );\n        }\n        inherits(P25519, MPrime);\n        P25519.prototype.imulK = function imulK(num) {\n          var carry = 0;\n          for (var i = 0; i < num.length; i++) {\n            var hi = (num.words[i] | 0) * 19 + carry;\n            var lo = hi & 67108863;\n            hi >>>= 26;\n            num.words[i] = lo;\n            carry = hi;\n          }\n          if (carry !== 0) {\n            num.words[num.length++] = carry;\n          }\n          return num;\n        };\n        BN2._prime = function prime(name) {\n          if (primes[name])\n            return primes[name];\n          var prime2;\n          if (name === \"k256\") {\n            prime2 = new K256();\n          } else if (name === \"p224\") {\n            prime2 = new P224();\n          } else if (name === \"p192\") {\n            prime2 = new P192();\n          } else if (name === \"p25519\") {\n            prime2 = new P25519();\n          } else {\n            throw new Error(\"Unknown prime \" + name);\n          }\n          primes[name] = prime2;\n          return prime2;\n        };\n        function Red(m) {\n          if (typeof m === \"string\") {\n            var prime = BN2._prime(m);\n            this.m = prime.p;\n            this.prime = prime;\n          } else {\n            assert3(m.gtn(1), \"modulus must be greater than 1\");\n            this.m = m;\n            this.prime = null;\n          }\n        }\n        Red.prototype._verify1 = function _verify1(a) {\n          assert3(a.negative === 0, \"red works only with positives\");\n          assert3(a.red, \"red works only with red numbers\");\n        };\n        Red.prototype._verify2 = function _verify2(a, b) {\n          assert3((a.negative | b.negative) === 0, \"red works only with positives\");\n          assert3(\n            a.red && a.red === b.red,\n            \"red works only with red numbers\"\n          );\n        };\n        Red.prototype.imod = function imod(a) {\n          if (this.prime)\n            return this.prime.ireduce(a)._forceRed(this);\n          move(a, a.umod(this.m)._forceRed(this));\n          return a;\n        };\n        Red.prototype.neg = function neg(a) {\n          if (a.isZero()) {\n            return a.clone();\n          }\n          return this.m.sub(a)._forceRed(this);\n        };\n        Red.prototype.add = function add2(a, b) {\n          this._verify2(a, b);\n          var res = a.add(b);\n          if (res.cmp(this.m) >= 0) {\n            res.isub(this.m);\n          }\n          return res._forceRed(this);\n        };\n        Red.prototype.iadd = function iadd(a, b) {\n          this._verify2(a, b);\n          var res = a.iadd(b);\n          if (res.cmp(this.m) >= 0) {\n            res.isub(this.m);\n          }\n          return res;\n        };\n        Red.prototype.sub = function sub(a, b) {\n          this._verify2(a, b);\n          var res = a.sub(b);\n          if (res.cmpn(0) < 0) {\n            res.iadd(this.m);\n          }\n          return res._forceRed(this);\n        };\n        Red.prototype.isub = function isub(a, b) {\n          this._verify2(a, b);\n          var res = a.isub(b);\n          if (res.cmpn(0) < 0) {\n            res.iadd(this.m);\n          }\n          return res;\n        };\n        Red.prototype.shl = function shl(a, num) {\n          this._verify1(a);\n          return this.imod(a.ushln(num));\n        };\n        Red.prototype.imul = function imul(a, b) {\n          this._verify2(a, b);\n          return this.imod(a.imul(b));\n        };\n        Red.prototype.mul = function mul(a, b) {\n          this._verify2(a, b);\n          return this.imod(a.mul(b));\n        };\n        Red.prototype.isqr = function isqr(a) {\n          return this.imul(a, a.clone());\n        };\n        Red.prototype.sqr = function sqr(a) {\n          return this.mul(a, a);\n        };\n        Red.prototype.sqrt = function sqrt(a) {\n          if (a.isZero())\n            return a.clone();\n          var mod3 = this.m.andln(3);\n          assert3(mod3 % 2 === 1);\n          if (mod3 === 3) {\n            var pow = this.m.add(new BN2(1)).iushrn(2);\n            return this.pow(a, pow);\n          }\n          var q = this.m.subn(1);\n          var s = 0;\n          while (!q.isZero() && q.andln(1) === 0) {\n            s++;\n            q.iushrn(1);\n          }\n          assert3(!q.isZero());\n          var one = new BN2(1).toRed(this);\n          var nOne = one.redNeg();\n          var lpow = this.m.subn(1).iushrn(1);\n          var z = this.m.bitLength();\n          z = new BN2(2 * z * z).toRed(this);\n          while (this.pow(z, lpow).cmp(nOne) !== 0) {\n            z.redIAdd(nOne);\n          }\n          var c = this.pow(z, q);\n          var r = this.pow(a, q.addn(1).iushrn(1));\n          var t = this.pow(a, q);\n          var m = s;\n          while (t.cmp(one) !== 0) {\n            var tmp = t;\n            for (var i = 0; tmp.cmp(one) !== 0; i++) {\n              tmp = tmp.redSqr();\n            }\n            assert3(i < m);\n            var b = this.pow(c, new BN2(1).iushln(m - i - 1));\n            r = r.redMul(b);\n            c = b.redSqr();\n            t = t.redMul(c);\n            m = i;\n          }\n          return r;\n        };\n        Red.prototype.invm = function invm(a) {\n          var inv = a._invmp(this.m);\n          if (inv.negative !== 0) {\n            inv.negative = 0;\n            return this.imod(inv).redNeg();\n          } else {\n            return this.imod(inv);\n          }\n        };\n        Red.prototype.pow = function pow(a, num) {\n          if (num.isZero())\n            return new BN2(1).toRed(this);\n          if (num.cmpn(1) === 0)\n            return a.clone();\n          var windowSize = 4;\n          var wnd = new Array(1 << windowSize);\n          wnd[0] = new BN2(1).toRed(this);\n          wnd[1] = a;\n          for (var i = 2; i < wnd.length; i++) {\n            wnd[i] = this.mul(wnd[i - 1], a);\n          }\n          var res = wnd[0];\n          var current = 0;\n          var currentLen = 0;\n          var start = num.bitLength() % 26;\n          if (start === 0) {\n            start = 26;\n          }\n          for (i = num.length - 1; i >= 0; i--) {\n            var word = num.words[i];\n            for (var j = start - 1; j >= 0; j--) {\n              var bit = word >> j & 1;\n              if (res !== wnd[0]) {\n                res = this.sqr(res);\n              }\n              if (bit === 0 && current === 0) {\n                currentLen = 0;\n                continue;\n              }\n              current <<= 1;\n              current |= bit;\n              currentLen++;\n              if (currentLen !== windowSize && (i !== 0 || j !== 0))\n                continue;\n              res = this.mul(res, wnd[current]);\n              currentLen = 0;\n              current = 0;\n            }\n            start = 26;\n          }\n          return res;\n        };\n        Red.prototype.convertTo = function convertTo(num) {\n          var r = num.umod(this.m);\n          return r === num ? r.clone() : r;\n        };\n        Red.prototype.convertFrom = function convertFrom(num) {\n          var res = num.clone();\n          res.red = null;\n          return res;\n        };\n        BN2.mont = function mont(num) {\n          return new Mont(num);\n        };\n        function Mont(m) {\n          Red.call(this, m);\n          this.shift = this.m.bitLength();\n          if (this.shift % 26 !== 0) {\n            this.shift += 26 - this.shift % 26;\n          }\n          this.r = new BN2(1).iushln(this.shift);\n          this.r2 = this.imod(this.r.sqr());\n          this.rinv = this.r._invmp(this.m);\n          this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);\n          this.minv = this.minv.umod(this.r);\n          this.minv = this.r.sub(this.minv);\n        }\n        inherits(Mont, Red);\n        Mont.prototype.convertTo = function convertTo(num) {\n          return this.imod(num.ushln(this.shift));\n        };\n        Mont.prototype.convertFrom = function convertFrom(num) {\n          var r = this.imod(num.mul(this.rinv));\n          r.red = null;\n          return r;\n        };\n        Mont.prototype.imul = function imul(a, b) {\n          if (a.isZero() || b.isZero()) {\n            a.words[0] = 0;\n            a.length = 1;\n            return a;\n          }\n          var t = a.imul(b);\n          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n          var u = t.isub(c).iushrn(this.shift);\n          var res = u;\n          if (u.cmp(this.m) >= 0) {\n            res = u.isub(this.m);\n          } else if (u.cmpn(0) < 0) {\n            res = u.iadd(this.m);\n          }\n          return res._forceRed(this);\n        };\n        Mont.prototype.mul = function mul(a, b) {\n          if (a.isZero() || b.isZero())\n            return new BN2(0)._forceRed(this);\n          var t = a.mul(b);\n          var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);\n          var u = t.isub(c).iushrn(this.shift);\n          var res = u;\n          if (u.cmp(this.m) >= 0) {\n            res = u.isub(this.m);\n          } else if (u.cmpn(0) < 0) {\n            res = u.iadd(this.m);\n          }\n          return res._forceRed(this);\n        };\n        Mont.prototype.invm = function invm(a) {\n          var res = this.imod(a._invmp(this.m).mul(this.r2));\n          return res._forceRed(this);\n        };\n      })(typeof module === \"undefined\" || module, exports3);\n    }\n  });\n\n  // ../../../node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js\n  var require_safe_buffer = __commonJS({\n    \"../../../node_modules/.pnpm/safe-buffer@5.2.1/node_modules/safe-buffer/index.js\"(exports3, module) {\n      \"use strict\";\n      init_dirname();\n      init_buffer2();\n      init_process2();\n      var buffer = (init_buffer(), __toCommonJS(buffer_exports));\n      var Buffer3 = buffer.Buffer;\n      function copyProps(src, dst) {\n        for (var key in src) {\n          dst[key] = src[key];\n        }\n      }\n      if (Buffer3.from && Buffer3.alloc && Buffer3.allocUnsafe && Buffer3.allocUnsafeSlow) {\n        module.exports = buffer;\n      } else {\n        copyProps(buffer, exports3);\n        exports3.Buffer = SafeBuffer;\n      }\n      function SafeBuffer(arg, encodingOrOffset, length) {\n        return Buffer3(arg, encodingOrOffset, length);\n      }\n      SafeBuffer.prototype = Object.create(Buffer3.prototype);\n      copyProps(Buffer3, SafeBuffer);\n      SafeBuffer.from = function(arg, encodingOrOffset, length) {\n        if (typeof arg === \"number\") {\n          throw new TypeError(\"Argument must not be a number\");\n        }\n        return Buffer3(arg, encodingOrOffset, length);\n      };\n      SafeBuffer.alloc = function(size, fill, encoding) {\n        if (typeof size !== \"number\") {\n          throw new TypeError(\"Argument must be a number\");\n        }\n        var buf = Buffer3(size);\n        if (fill !== void 0) {\n          if (typeof encoding === \"string\") {\n            buf.fill(fill, encoding);\n          } else {\n            buf.fill(fill);\n          }\n        } else {\n          buf.fill(0);\n        }\n        return buf;\n      };\n      SafeBuffer.allocUnsafe = function(size) {\n        if (typeof size !== \"number\") {\n          throw new TypeError(\"Argument must be a number\");\n        }\n        return Buffer3(size);\n      };\n      SafeBuffer.allocUnsafeSlow = function(size) {\n        if (typeof size !== \"number\") {\n          throw new TypeError(\"Argument must be a number\");\n        }\n        return buffer.SlowBuffer(size);\n      };\n    }\n  });\n\n  // ../../../node_modules/.pnpm/base-x@3.0.11/node_modules/base-x/src/index.js\n  var require_src = __commonJS({\n    \"../../../node_modules/.pnpm/base-x@3.0.11/node_modules/base-x/src/index.js\"(exports3, module) {\n      \"use strict\";\n      init_dirname();\n      init_buffer2();\n      init_process2();\n      var _Buffer = require_safe_buffer().Buffer;\n      function base(ALPHABET) {\n        if (ALPHABET.length >= 255) {\n          throw new TypeError(\"Alphabet too long\");\n        }\n        var BASE_MAP = new Uint8Array(256);\n        for (var j = 0; j < BASE_MAP.length; j++) {\n          BASE_MAP[j] = 255;\n        }\n        for (var i = 0; i < ALPHABET.length; i++) {\n          var x = ALPHABET.charAt(i);\n          var xc = x.charCodeAt(0);\n          if (BASE_MAP[xc] !== 255) {\n            throw new TypeError(x + \" is ambiguous\");\n          }\n          BASE_MAP[xc] = i;\n        }\n        var BASE = ALPHABET.length;\n        var LEADER = ALPHABET.charAt(0);\n        var FACTOR = Math.log(BASE) / Math.log(256);\n        var iFACTOR = Math.log(256) / Math.log(BASE);\n        function encode(source) {\n          if (Array.isArray(source) || source instanceof Uint8Array) {\n            source = _Buffer.from(source);\n          }\n          if (!_Buffer.isBuffer(source)) {\n            throw new TypeError(\"Expected Buffer\");\n          }\n          if (source.length === 0) {\n            return \"\";\n          }\n          var zeroes = 0;\n          var length = 0;\n          var pbegin = 0;\n          var pend = source.length;\n          while (pbegin !== pend && source[pbegin] === 0) {\n            pbegin++;\n            zeroes++;\n          }\n          var size = (pend - pbegin) * iFACTOR + 1 >>> 0;\n          var b58 = new Uint8Array(size);\n          while (pbegin !== pend) {\n            var carry = source[pbegin];\n            var i2 = 0;\n            for (var it1 = size - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {\n              carry += 256 * b58[it1] >>> 0;\n              b58[it1] = carry % BASE >>> 0;\n              carry = carry / BASE >>> 0;\n            }\n            if (carry !== 0) {\n              throw new Error(\"Non-zero carry\");\n            }\n            length = i2;\n            pbegin++;\n          }\n          var it2 = size - length;\n          while (it2 !== size && b58[it2] === 0) {\n            it2++;\n          }\n          var str = LEADER.repeat(zeroes);\n          for (; it2 < size; ++it2) {\n            str += ALPHABET.charAt(b58[it2]);\n          }\n          return str;\n        }\n        function decodeUnsafe(source) {\n          if (typeof source !== \"string\") {\n            throw new TypeError(\"Expected String\");\n          }\n          if (source.length === 0) {\n            return _Buffer.alloc(0);\n          }\n          var psz = 0;\n          var zeroes = 0;\n          var length = 0;\n          while (source[psz] === LEADER) {\n            zeroes++;\n            psz++;\n          }\n          var size = (source.length - psz) * FACTOR + 1 >>> 0;\n          var b256 = new Uint8Array(size);\n          while (psz < source.length) {\n            var charCode = source.charCodeAt(psz);\n            if (charCode > 255) {\n              return;\n            }\n            var carry = BASE_MAP[charCode];\n            if (carry === 255) {\n              return;\n            }\n            var i2 = 0;\n            for (var it3 = size - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {\n              carry += BASE * b256[it3] >>> 0;\n              b256[it3] = carry % 256 >>> 0;\n              carry = carry / 256 >>> 0;\n            }\n            if (carry !== 0) {\n              throw new Error(\"Non-zero carry\");\n            }\n            length = i2;\n            psz++;\n          }\n          var it4 = size - length;\n          while (it4 !== size && b256[it4] === 0) {\n            it4++;\n          }\n          var vch = _Buffer.allocUnsafe(zeroes + (size - it4));\n          vch.fill(0, 0, zeroes);\n          var j2 = zeroes;\n          while (it4 !== size) {\n            vch[j2++] = b256[it4++];\n          }\n          return vch;\n        }\n        function decode(string2) {\n          var buffer = decodeUnsafe(string2);\n          if (buffer) {\n            return buffer;\n          }\n          throw new Error(\"Non-base\" + BASE + \" character\");\n        }\n        return {\n          encode,\n          decodeUnsafe,\n          decode\n        };\n      }\n      module.exports = base;\n    }\n  });\n\n  // ../../../node_modules/.pnpm/bs58@4.0.1/node_modules/bs58/index.js\n  var require_bs58 = __commonJS({\n    \"../../../node_modules/.pnpm/bs58@4.0.1/node_modules/bs58/index.js\"(exports3, module) {\n      \"use strict\";\n      init_dirname();\n      init_buffer2();\n      init_process2();\n      var basex = require_src();\n      var ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n      module.exports = basex(ALPHABET);\n    }\n  });\n\n  // ../../../node_modules/.pnpm/text-encoding-utf-8@1.0.2/node_modules/text-encoding-utf-8/lib/encoding.lib.js\n  var require_encoding_lib = __commonJS({\n    \"../../../node_modules/.pnpm/text-encoding-utf-8@1.0.2/node_modules/text-encoding-utf-8/lib/encoding.lib.js\"(exports3) {\n      \"use strict\";\n      init_dirname();\n      init_buffer2();\n      init_process2();\n      function inRange2(a, min, max) {\n        return min <= a && a <= max;\n      }\n      function ToDictionary(o) {\n        if (o === void 0)\n          return {};\n        if (o === Object(o))\n          return o;\n        throw TypeError(\"Could not convert argument to dictionary\");\n      }\n      function stringToCodePoints(string2) {\n        var s = String(string2);\n        var n = s.length;\n        var i = 0;\n        var u = [];\n        while (i < n) {\n          var c = s.charCodeAt(i);\n          if (c < 55296 || c > 57343) {\n            u.push(c);\n          } else if (56320 <= c && c <= 57343) {\n            u.push(65533);\n          } else if (55296 <= c && c <= 56319) {\n            if (i === n - 1) {\n              u.push(65533);\n            } else {\n              var d = string2.charCodeAt(i + 1);\n              if (56320 <= d && d <= 57343) {\n                var a = c & 1023;\n                var b = d & 1023;\n                u.push(65536 + (a << 10) + b);\n                i += 1;\n              } else {\n                u.push(65533);\n              }\n            }\n          }\n          i += 1;\n        }\n        return u;\n      }\n      function codePointsToString(code_points) {\n        var s = \"\";\n        for (var i = 0; i < code_points.length; ++i) {\n          var cp = code_points[i];\n          if (cp <= 65535) {\n            s += String.fromCharCode(cp);\n          } else {\n            cp -= 65536;\n            s += String.fromCharCode(\n              (cp >> 10) + 55296,\n              (cp & 1023) + 56320\n            );\n          }\n        }\n        return s;\n      }\n      var end_of_stream = -1;\n      function Stream(tokens) {\n        this.tokens = [].slice.call(tokens);\n      }\n      Stream.prototype = {\n        /**\n         * @return {boolean} True if end-of-stream has been hit.\n         */\n        endOfStream: function() {\n          return !this.tokens.length;\n        },\n        /**\n         * When a token is read from a stream, the first token in the\n         * stream must be returned and subsequently removed, and\n         * end-of-stream must be returned otherwise.\n         *\n         * @return {number} Get the next token from the stream, or\n         * end_of_stream.\n         */\n        read: function() {\n          if (!this.tokens.length)\n            return end_of_stream;\n          return this.tokens.shift();\n        },\n        /**\n         * When one or more tokens are prepended to a stream, those tokens\n         * must be inserted, in given order, before the first token in the\n         * stream.\n         *\n         * @param {(number|!Array.<number>)} token The token(s) to prepend to the stream.\n         */\n        prepend: function(token) {\n          if (Array.isArray(token)) {\n            var tokens = (\n              /**@type {!Array.<number>}*/\n              token\n            );\n            while (tokens.length)\n              this.tokens.unshift(tokens.pop());\n          } else {\n            this.tokens.unshift(token);\n          }\n        },\n        /**\n         * When one or more tokens are pushed to a stream, those tokens\n         * must be inserted, in given order, after the last token in the\n         * stream.\n         *\n         * @param {(number|!Array.<number>)} token The tokens(s) to prepend to the stream.\n         */\n        push: function(token) {\n          if (Array.isArray(token)) {\n            var tokens = (\n              /**@type {!Array.<number>}*/\n              token\n            );\n            while (tokens.length)\n              this.tokens.push(tokens.shift());\n          } else {\n            this.tokens.push(token);\n          }\n        }\n      };\n      var finished = -1;\n      function decoderError(fatal, opt_code_point) {\n        if (fatal)\n          throw TypeError(\"Decoder error\");\n        return opt_code_point || 65533;\n      }\n      var DEFAULT_ENCODING = \"utf-8\";\n      function TextDecoder2(encoding, options) {\n        if (!(this instanceof TextDecoder2)) {\n          return new TextDecoder2(encoding, options);\n        }\n        encoding = encoding !== void 0 ? String(encoding).toLowerCase() : DEFAULT_ENCODING;\n        if (encoding !== DEFAULT_ENCODING) {\n          throw new Error(\"Encoding not supported. Only utf-8 is supported\");\n        }\n        options = ToDictionary(options);\n        this._streaming = false;\n        this._BOMseen = false;\n        this._decoder = null;\n        this._fatal = Boolean(options[\"fatal\"]);\n        this._ignoreBOM = Boolean(options[\"ignoreBOM\"]);\n        Object.defineProperty(this, \"encoding\", { value: \"utf-8\" });\n        Object.defineProperty(this, \"fatal\", { value: this._fatal });\n        Object.defineProperty(this, \"ignoreBOM\", { value: this._ignoreBOM });\n      }\n      TextDecoder2.prototype = {\n        /**\n         * @param {ArrayBufferView=} input The buffer of bytes to decode.\n         * @param {Object=} options\n         * @return {string} The decoded string.\n         */\n        decode: function decode(input, options) {\n          var bytes;\n          if (typeof input === \"object\" && input instanceof ArrayBuffer) {\n            bytes = new Uint8Array(input);\n          } else if (typeof input === \"object\" && \"buffer\" in input && input.buffer instanceof ArrayBuffer) {\n            bytes = new Uint8Array(\n              input.buffer,\n              input.byteOffset,\n              input.byteLength\n            );\n          } else {\n            bytes = new Uint8Array(0);\n          }\n          options = ToDictionary(options);\n          if (!this._streaming) {\n            this._decoder = new UTF8Decoder({ fatal: this._fatal });\n            this._BOMseen = false;\n          }\n          this._streaming = Boolean(options[\"stream\"]);\n          var input_stream = new Stream(bytes);\n          var code_points = [];\n          var result;\n          while (!input_stream.endOfStream()) {\n            result = this._decoder.handler(input_stream, input_stream.read());\n            if (result === finished)\n              break;\n            if (result === null)\n              continue;\n            if (Array.isArray(result))\n              code_points.push.apply(\n                code_points,\n                /**@type {!Array.<number>}*/\n                result\n              );\n            else\n              code_points.push(result);\n          }\n          if (!this._streaming) {\n            do {\n              result = this._decoder.handler(input_stream, input_stream.read());\n              if (result === finished)\n                break;\n              if (result === null)\n                continue;\n              if (Array.isArray(result))\n                code_points.push.apply(\n                  code_points,\n                  /**@type {!Array.<number>}*/\n                  result\n                );\n              else\n                code_points.push(result);\n            } while (!input_stream.endOfStream());\n            this._decoder = null;\n          }\n          if (code_points.length) {\n            if ([\"utf-8\"].indexOf(this.encoding) !== -1 && !this._ignoreBOM && !this._BOMseen) {\n              if (code_points[0] === 65279) {\n                this._BOMseen = true;\n                code_points.shift();\n              } else {\n                this._BOMseen = true;\n              }\n            }\n          }\n          return codePointsToString(code_points);\n        }\n      };\n      function TextEncoder2(encoding, options) {\n        if (!(this instanceof TextEncoder2))\n          return new TextEncoder2(encoding, options);\n        encoding = encoding !== void 0 ? String(encoding).toLowerCase() : DEFAULT_ENCODING;\n        if (encoding !== DEFAULT_ENCODING) {\n          throw new Error(\"Encoding not supported. Only utf-8 is supported\");\n        }\n        options = ToDictionary(options);\n        this._streaming = false;\n        this._encoder = null;\n        this._options = { fatal: Boolean(options[\"fatal\"]) };\n        Object.defineProperty(this, \"encoding\", { value: \"utf-8\" });\n      }\n      TextEncoder2.prototype = {\n        /**\n         * @param {string=} opt_string The string to encode.\n         * @param {Object=} options\n         * @return {Uint8Array} Encoded bytes, as a Uint8Array.\n         */\n        encode: function encode(opt_string, options) {\n          opt_string = opt_string ? String(opt_string) : \"\";\n          options = ToDictionary(options);\n          if (!this._streaming)\n            this._encoder = new UTF8Encoder(this._options);\n          this._streaming = Boolean(options[\"stream\"]);\n          var bytes = [];\n          var input_stream = new Stream(stringToCodePoints(opt_string));\n          var result;\n          while (!input_stream.endOfStream()) {\n            result = this._encoder.handler(input_stream, input_stream.read());\n            if (result === finished)\n              break;\n            if (Array.isArray(result))\n              bytes.push.apply(\n                bytes,\n                /**@type {!Array.<number>}*/\n                result\n              );\n            else\n              bytes.push(result);\n          }\n          if (!this._streaming) {\n            while (true) {\n              result = this._encoder.handler(input_stream, input_stream.read());\n              if (result === finished)\n                break;\n              if (Array.isArray(result))\n                bytes.push.apply(\n                  bytes,\n                  /**@type {!Array.<number>}*/\n                  result\n                );\n              else\n                bytes.push(result);\n            }\n            this._encoder = null;\n          }\n          return new Uint8Array(bytes);\n        }\n      };\n      function UTF8Decoder(options) {\n        var fatal = options.fatal;\n        var utf8_code_point = 0, utf8_bytes_seen = 0, utf8_bytes_needed = 0, utf8_lower_boundary = 128, utf8_upper_boundary = 191;\n        this.handler = function(stream, bite) {\n          if (bite === end_of_stream && utf8_bytes_needed !== 0) {\n            utf8_bytes_needed = 0;\n            return decoderError(fatal);\n          }\n          if (bite === end_of_stream)\n            return finished;\n          if (utf8_bytes_needed === 0) {\n            if (inRange2(bite, 0, 127)) {\n              return bite;\n            }\n            if (inRange2(bite, 194, 223)) {\n              utf8_bytes_needed = 1;\n              utf8_code_point = bite - 192;\n            } else if (inRange2(bite, 224, 239)) {\n              if (bite === 224)\n                utf8_lower_boundary = 160;\n              if (bite === 237)\n                utf8_upper_boundary = 159;\n              utf8_bytes_needed = 2;\n              utf8_code_point = bite - 224;\n            } else if (inRange2(bite, 240, 244)) {\n              if (bite === 240)\n                utf8_lower_boundary = 144;\n              if (bite === 244)\n                utf8_upper_boundary = 143;\n              utf8_bytes_needed = 3;\n              utf8_code_point = bite - 240;\n            } else {\n              return decoderError(fatal);\n            }\n            utf8_code_point = utf8_code_point << 6 * utf8_bytes_needed;\n            return null;\n          }\n          if (!inRange2(bite, utf8_lower_boundary, utf8_upper_boundary)) {\n            utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n            utf8_lower_boundary = 128;\n            utf8_upper_boundary = 191;\n            stream.prepend(bite);\n            return decoderError(fatal);\n          }\n          utf8_lower_boundary = 128;\n          utf8_upper_boundary = 191;\n          utf8_bytes_seen += 1;\n          utf8_code_point += bite - 128 << 6 * (utf8_bytes_needed - utf8_bytes_seen);\n          if (utf8_bytes_seen !== utf8_bytes_needed)\n            return null;\n          var code_point = utf8_code_point;\n          utf8_code_point = utf8_bytes_needed = utf8_bytes_seen = 0;\n          return code_point;\n        };\n      }\n      function UTF8Encoder(options) {\n        var fatal = options.fatal;\n        this.handler = function(stream, code_point) {\n          if (code_point === end_of_stream)\n            return finished;\n          if (inRange2(code_point, 0, 127))\n            return code_point;\n          var count, offset2;\n          if (inRange2(code_point, 128, 2047)) {\n            count = 1;\n            offset2 = 192;\n          } else if (inRange2(code_point, 2048, 65535)) {\n            count = 2;\n            offset2 = 224;\n          } else if (inRange2(code_point, 65536, 1114111)) {\n            count = 3;\n            offset2 = 240;\n          }\n          var bytes = [(code_point >> 6 * count) + offset2];\n          while (count > 0) {\n            var temp = code_point >> 6 * (count - 1);\n            bytes.push(128 | temp & 63);\n            count -= 1;\n          }\n          return bytes;\n        };\n      }\n      exports3.TextEncoder = TextEncoder2;\n      exports3.TextDecoder = TextDecoder2;\n    }\n  });\n\n  // ../../../node_modules/.pnpm/borsh@0.7.0/node_modules/borsh/lib/index.js\n  var require_lib = __commonJS({\n    \"../../../node_modules/.pnpm/borsh@0.7.0/node_modules/borsh/lib/index.js\"(exports3) {\n      \"use strict\";\n      init_dirname();\n      init_buffer2();\n      init_process2();\n      var __createBinding = exports3 && exports3.__createBinding || (Object.create ? function(o, m, k, k2) {\n        if (k2 === void 0)\n          k2 = k;\n        Object.defineProperty(o, k2, { enumerable: true, get: function() {\n          return m[k];\n        } });\n      } : function(o, m, k, k2) {\n        if (k2 === void 0)\n          k2 = k;\n        o[k2] = m[k];\n      });\n      var __setModuleDefault = exports3 && exports3.__setModuleDefault || (Object.create ? function(o, v) {\n        Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n      } : function(o, v) {\n        o[\"default\"] = v;\n      });\n      var __decorate = exports3 && exports3.__decorate || function(decorators, target, key, desc) {\n        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n        if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\")\n          r = Reflect.decorate(decorators, target, key, desc);\n        else\n          for (var i = decorators.length - 1; i >= 0; i--)\n            if (d = decorators[i])\n              r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n        return c > 3 && r && Object.defineProperty(target, key, r), r;\n      };\n      var __importStar = exports3 && exports3.__importStar || function(mod2) {\n        if (mod2 && mod2.__esModule)\n          return mod2;\n        var result = {};\n        if (mod2 != null) {\n          for (var k in mod2)\n            if (k !== \"default\" && Object.hasOwnProperty.call(mod2, k))\n              __createBinding(result, mod2, k);\n        }\n        __setModuleDefault(result, mod2);\n        return result;\n      };\n      var __importDefault = exports3 && exports3.__importDefault || function(mod2) {\n        return mod2 && mod2.__esModule ? mod2 : { \"default\": mod2 };\n      };\n      Object.defineProperty(exports3, \"__esModule\", { value: true });\n      exports3.deserializeUnchecked = exports3.deserialize = exports3.serialize = exports3.BinaryReader = exports3.BinaryWriter = exports3.BorshError = exports3.baseDecode = exports3.baseEncode = void 0;\n      var bn_js_1 = __importDefault(require_bn());\n      var bs58_1 = __importDefault(require_bs58());\n      var encoding = __importStar(require_encoding_lib());\n      var ResolvedTextDecoder = typeof TextDecoder !== \"function\" ? encoding.TextDecoder : TextDecoder;\n      var textDecoder = new ResolvedTextDecoder(\"utf-8\", { fatal: true });\n      function baseEncode(value) {\n        if (typeof value === \"string\") {\n          value = Buffer2.from(value, \"utf8\");\n        }\n        return bs58_1.default.encode(Buffer2.from(value));\n      }\n      exports3.baseEncode = baseEncode;\n      function baseDecode(value) {\n        return Buffer2.from(bs58_1.default.decode(value));\n      }\n      exports3.baseDecode = baseDecode;\n      var INITIAL_LENGTH = 1024;\n      var BorshError = class extends Error {\n        constructor(message) {\n          super(message);\n          this.fieldPath = [];\n          this.originalMessage = message;\n        }\n        addToFieldPath(fieldName) {\n          this.fieldPath.splice(0, 0, fieldName);\n          this.message = this.originalMessage + \": \" + this.fieldPath.join(\".\");\n        }\n      };\n      exports3.BorshError = BorshError;\n      var BinaryWriter = class {\n        constructor() {\n          this.buf = Buffer2.alloc(INITIAL_LENGTH);\n          this.length = 0;\n        }\n        maybeResize() {\n          if (this.buf.length < 16 + this.length) {\n            this.buf = Buffer2.concat([this.buf, Buffer2.alloc(INITIAL_LENGTH)]);\n          }\n        }\n        writeU8(value) {\n          this.maybeResize();\n          this.buf.writeUInt8(value, this.length);\n          this.length += 1;\n        }\n        writeU16(value) {\n          this.maybeResize();\n          this.buf.writeUInt16LE(value, this.length);\n          this.length += 2;\n        }\n        writeU32(value) {\n          this.maybeResize();\n          this.buf.writeUInt32LE(value, this.length);\n          this.length += 4;\n        }\n        writeU64(value) {\n          this.maybeResize();\n          this.writeBuffer(Buffer2.from(new bn_js_1.default(value).toArray(\"le\", 8)));\n        }\n        writeU128(value) {\n          this.maybeResize();\n          this.writeBuffer(Buffer2.from(new bn_js_1.default(value).toArray(\"le\", 16)));\n        }\n        writeU256(value) {\n          this.maybeResize();\n          this.writeBuffer(Buffer2.from(new bn_js_1.default(value).toArray(\"le\", 32)));\n        }\n        writeU512(value) {\n          this.maybeResize();\n          this.writeBuffer(Buffer2.from(new bn_js_1.default(value).toArray(\"le\", 64)));\n        }\n        writeBuffer(buffer) {\n          this.buf = Buffer2.concat([\n            Buffer2.from(this.buf.subarray(0, this.length)),\n            buffer,\n            Buffer2.alloc(INITIAL_LENGTH)\n          ]);\n          this.length += buffer.length;\n        }\n        writeString(str) {\n          this.maybeResize();\n          const b = Buffer2.from(str, \"utf8\");\n          this.writeU32(b.length);\n          this.writeBuffer(b);\n        }\n        writeFixedArray(array2) {\n          this.writeBuffer(Buffer2.from(array2));\n        }\n        writeArray(array2, fn) {\n          this.maybeResize();\n          this.writeU32(array2.length);\n          for (const elem of array2) {\n            this.maybeResize();\n            fn(elem);\n          }\n        }\n        toArray() {\n          return this.buf.subarray(0, this.length);\n        }\n      };\n      exports3.BinaryWriter = BinaryWriter;\n      function handlingRangeError(target, propertyKey, propertyDescriptor) {\n        const originalMethod = propertyDescriptor.value;\n        propertyDescriptor.value = function(...args) {\n          try {\n            return originalMethod.apply(this, args);\n          } catch (e) {\n            if (e instanceof RangeError) {\n              const code = e.code;\n              if ([\"ERR_BUFFER_OUT_OF_BOUNDS\", \"ERR_OUT_OF_RANGE\"].indexOf(code) >= 0) {\n                throw new BorshError(\"Reached the end of buffer when deserializing\");\n              }\n            }\n            throw e;\n          }\n        };\n      }\n      var BinaryReader = class {\n        constructor(buf) {\n          this.buf = buf;\n          this.offset = 0;\n        }\n        readU8() {\n          const value = this.buf.readUInt8(this.offset);\n          this.offset += 1;\n          return value;\n        }\n        readU16() {\n          const value = this.buf.readUInt16LE(this.offset);\n          this.offset += 2;\n          return value;\n        }\n        readU32() {\n          const value = this.buf.readUInt32LE(this.offset);\n          this.offset += 4;\n          return value;\n        }\n        readU64() {\n          const buf = this.readBuffer(8);\n          return new bn_js_1.default(buf, \"le\");\n        }\n        readU128() {\n          const buf = this.readBuffer(16);\n          return new bn_js_1.default(buf, \"le\");\n        }\n        readU256() {\n          const buf = this.readBuffer(32);\n          return new bn_js_1.default(buf, \"le\");\n        }\n        readU512() {\n          const buf = this.readBuffer(64);\n          return new bn_js_1.default(buf, \"le\");\n        }\n        readBuffer(len) {\n          if (this.offset + len > this.buf.length) {\n            throw new BorshError(`Expected buffer length ${len} isn't within bounds`);\n          }\n          const result = this.buf.slice(this.offset, this.offset + len);\n          this.offset += len;\n          return result;\n        }\n        readString() {\n          const len = this.readU32();\n          const buf = this.readBuffer(len);\n          try {\n            return textDecoder.decode(buf);\n          } catch (e) {\n            throw new BorshError(`Error decoding UTF-8 string: ${e}`);\n          }\n        }\n        readFixedArray(len) {\n          return new Uint8Array(this.readBuffer(len));\n        }\n        readArray(fn) {\n          const len = this.readU32();\n          const result = Array();\n          for (let i = 0; i < len; ++i) {\n            result.push(fn());\n          }\n          return result;\n        }\n      };\n      __decorate([\n        handlingRangeError\n      ], BinaryReader.prototype, \"readU8\", null);\n      __decorate([\n        handlingRangeError\n      ], BinaryReader.prototype, \"readU16\", null);\n      __decorate([\n        handlingRangeError\n      ], BinaryReader.prototype, \"readU32\", null);\n      __decorate([\n        handlingRangeError\n      ], BinaryReader.prototype, \"readU64\", null);\n      __decorate([\n        handlingRangeError\n      ], BinaryReader.prototype, \"readU128\", null);\n      __decorate([\n        handlingRangeError\n      ], BinaryReader.prototype, \"readU256\", null);\n      __decorate([\n        handlingRangeError\n      ], BinaryReader.prototype, \"readU512\", null);\n      __decorate([\n        handlingRangeError\n      ], BinaryReader.prototype, \"readString\", null);\n      __decorate([\n        handlingRangeError\n      ], BinaryReader.prototype, \"readFixedArray\", null);\n      __decorate([\n        handlingRangeError\n      ], BinaryReader.prototype, \"readArray\", null);\n      exports3.BinaryReader = BinaryReader;\n      function capitalizeFirstLetter(string2) {\n        return string2.charAt(0).toUpperCase() + string2.slice(1);\n      }\n      function serializeField(schema, fieldName, value, fieldType, writer) {\n        try {\n          if (typeof fieldType === \"string\") {\n            writer[`write${capitalizeFirstLetter(fieldType)}`](value);\n          } else if (fieldType instanceof Array) {\n            if (typeof fieldType[0] === \"number\") {\n              if (value.length !== fieldType[0]) {\n                throw new BorshError(`Expecting byte array of length ${fieldType[0]}, but got ${value.length} bytes`);\n              }\n              writer.writeFixedArray(value);\n            } else if (fieldType.length === 2 && typeof fieldType[1] === \"number\") {\n              if (value.length !== fieldType[1]) {\n                throw new BorshError(`Expecting byte array of length ${fieldType[1]}, but got ${value.length} bytes`);\n              }\n              for (let i = 0; i < fieldType[1]; i++) {\n                serializeField(schema, null, value[i], fieldType[0], writer);\n              }\n            } else {\n              writer.writeArray(value, (item) => {\n                serializeField(schema, fieldName, item, fieldType[0], writer);\n              });\n            }\n          } else if (fieldType.kind !== void 0) {\n            switch (fieldType.kind) {\n              case \"option\": {\n                if (value === null || value === void 0) {\n                  writer.writeU8(0);\n                } else {\n                  writer.writeU8(1);\n                  serializeField(schema, fieldName, value, fieldType.type, writer);\n                }\n                break;\n              }\n              case \"map\": {\n                writer.writeU32(value.size);\n                value.forEach((val, key) => {\n                  serializeField(schema, fieldName, key, fieldType.key, writer);\n                  serializeField(schema, fieldName, val, fieldType.value, writer);\n                });\n                break;\n              }\n              default:\n                throw new BorshError(`FieldType ${fieldType} unrecognized`);\n            }\n          } else {\n            serializeStruct(schema, value, writer);\n          }\n        } catch (error) {\n          if (error instanceof BorshError) {\n            error.addToFieldPath(fieldName);\n          }\n          throw error;\n        }\n      }\n      function serializeStruct(schema, obj, writer) {\n        if (typeof obj.borshSerialize === \"function\") {\n          obj.borshSerialize(writer);\n          return;\n        }\n        const structSchema = schema.get(obj.constructor);\n        if (!structSchema) {\n          throw new BorshError(`Class ${obj.constructor.name} is missing in schema`);\n        }\n        if (structSchema.kind === \"struct\") {\n          structSchema.fields.map(([fieldName, fieldType]) => {\n            serializeField(schema, fieldName, obj[fieldName], fieldType, writer);\n          });\n        } else if (structSchema.kind === \"enum\") {\n          const name = obj[structSchema.field];\n          for (let idx = 0; idx < structSchema.values.length; ++idx) {\n            const [fieldName, fieldType] = structSchema.values[idx];\n            if (fieldName === name) {\n              writer.writeU8(idx);\n              serializeField(schema, fieldName, obj[fieldName], fieldType, writer);\n              break;\n            }\n          }\n        } else {\n          throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${obj.constructor.name}`);\n        }\n      }\n      function serialize2(schema, obj, Writer = BinaryWriter) {\n        const writer = new Writer();\n        serializeStruct(schema, obj, writer);\n        return writer.toArray();\n      }\n      exports3.serialize = serialize2;\n      function deserializeField(schema, fieldName, fieldType, reader) {\n        try {\n          if (typeof fieldType === \"string\") {\n            return reader[`read${capitalizeFirstLetter(fieldType)}`]();\n          }\n          if (fieldType instanceof Array) {\n            if (typeof fieldType[0] === \"number\") {\n              return reader.readFixedArray(fieldType[0]);\n            } else if (typeof fieldType[1] === \"number\") {\n              const arr = [];\n              for (let i = 0; i < fieldType[1]; i++) {\n                arr.push(deserializeField(schema, null, fieldType[0], reader));\n              }\n              return arr;\n            } else {\n              return reader.readArray(() => deserializeField(schema, fieldName, fieldType[0], reader));\n            }\n          }\n          if (fieldType.kind === \"option\") {\n            const option = reader.readU8();\n            if (option) {\n              return deserializeField(schema, fieldName, fieldType.type, reader);\n            }\n            return void 0;\n          }\n          if (fieldType.kind === \"map\") {\n            let map = /* @__PURE__ */ new Map();\n            const length = reader.readU32();\n            for (let i = 0; i < length; i++) {\n              const key = deserializeField(schema, fieldName, fieldType.key, reader);\n              const val = deserializeField(schema, fieldName, fieldType.value, reader);\n              map.set(key, val);\n            }\n            return map;\n          }\n          return deserializeStruct(schema, fieldType, reader);\n        } catch (error) {\n          if (error instanceof BorshError) {\n            error.addToFieldPath(fieldName);\n          }\n          throw error;\n        }\n      }\n      function deserializeStruct(schema, classType, reader) {\n        if (typeof classType.borshDeserialize === \"function\") {\n          return classType.borshDeserialize(reader);\n        }\n        const structSchema = schema.get(classType);\n        if (!structSchema) {\n          throw new BorshError(`Class ${classType.name} is missing in schema`);\n        }\n        if (structSchema.kind === \"struct\") {\n          const result = {};\n          for (const [fieldName, fieldType] of schema.get(classType).fields) {\n            result[fieldName] = deserializeField(schema, fieldName, fieldType, reader);\n          }\n          return new classType(result);\n        }\n        if (structSchema.kind === \"enum\") {\n          const idx = reader.readU8();\n          if (idx >= structSchema.values.length) {\n            throw new BorshError(`Enum index: ${idx} is out of range`);\n          }\n          const [fieldName, fieldType] = structSchema.values[idx];\n          const fieldValue = deserializeField(schema, fieldName, fieldType, reader);\n          return new classType({ [fieldName]: fieldValue });\n        }\n        throw new BorshError(`Unexpected schema kind: ${structSchema.kind} for ${classType.constructor.name}`);\n      }\n      function deserialize2(schema, classType, buffer, Reader = BinaryReader) {\n        const reader = new Reader(buffer);\n        const result = deserializeStruct(schema, classType, reader);\n        if (reader.offset < buffer.length) {\n          throw new BorshError(`Unexpected ${buffer.length - reader.offset} bytes after deserialized data`);\n        }\n        return result;\n      }\n      exports3.deserialize = deserialize2;\n      function deserializeUnchecked2(schema, classType, buffer, Reader = BinaryReader) {\n        const reader = new Reader(buffer);\n        return deserializeStruct(schema, classType, reader);\n      }\n      exports3.deserializeUnchecked = deserializeUnchecked2;\n    }\n  });\n\n  // ../../../node_modules/.pnpm/@solana+buffer-layout@4.0.1/node_modules/@solana/buffer-layout/lib/Layout.js\n  var require_Layout = __commonJS({\n    \"../../../node_modules/.pnpm/@solana+buffer-layout@4.0.1/node_modules/@solana/buffer-layout/lib/Layout.js\"(exports3) {\n      \"use strict\";\n      init_dirname();\n      init_buffer2();\n      init_process2();\n      Object.defineProperty(exports3, \"__esModule\", { value: true });\n      exports3.s16 = exports3.s8 = exports3.nu64be = exports3.u48be = exports3.u40be = exports3.u32be = exports3.u24be = exports3.u16be = exports3.nu64 = exports3.u48 = exports3.u40 = exports3.u32 = exports3.u24 = exports3.u16 = exports3.u8 = exports3.offset = exports3.greedy = exports3.Constant = exports3.UTF8 = exports3.CString = exports3.Blob = exports3.Boolean = exports3.BitField = exports3.BitStructure = exports3.VariantLayout = exports3.Union = exports3.UnionLayoutDiscriminator = exports3.UnionDiscriminator = exports3.Structure = exports3.Sequence = exports3.DoubleBE = exports3.Double = exports3.FloatBE = exports3.Float = exports3.NearInt64BE = exports3.NearInt64 = exports3.NearUInt64BE = exports3.NearUInt64 = exports3.IntBE = exports3.Int = exports3.UIntBE = exports3.UInt = exports3.OffsetLayout = exports3.GreedyCount = exports3.ExternalLayout = exports3.bindConstructorLayout = exports3.nameWithProperty = exports3.Layout = exports3.uint8ArrayToBuffer = exports3.checkUint8Array = void 0;\n      exports3.constant = exports3.utf8 = exports3.cstr = exports3.blob = exports3.unionLayoutDiscriminator = exports3.union = exports3.seq = exports3.bits = exports3.struct = exports3.f64be = exports3.f64 = exports3.f32be = exports3.f32 = exports3.ns64be = exports3.s48be = exports3.s40be = exports3.s32be = exports3.s24be = exports3.s16be = exports3.ns64 = exports3.s48 = exports3.s40 = exports3.s32 = exports3.s24 = void 0;\n      var buffer_1 = (init_buffer(), __toCommonJS(buffer_exports));\n      function checkUint8Array(b) {\n        if (!(b instanceof Uint8Array)) {\n          throw new TypeError(\"b must be a Uint8Array\");\n        }\n      }\n      exports3.checkUint8Array = checkUint8Array;\n      function uint8ArrayToBuffer(b) {\n        checkUint8Array(b);\n        return buffer_1.Buffer.from(b.buffer, b.byteOffset, b.length);\n      }\n      exports3.uint8ArrayToBuffer = uint8ArrayToBuffer;\n      var Layout = class {\n        constructor(span, property) {\n          if (!Number.isInteger(span)) {\n            throw new TypeError(\"span must be an integer\");\n          }\n          this.span = span;\n          this.property = property;\n        }\n        /** Function to create an Object into which decoded properties will\n         * be written.\n         *\n         * Used only for layouts that {@link Layout#decode|decode} to Object\n         * instances, which means:\n         * * {@link Structure}\n         * * {@link Union}\n         * * {@link VariantLayout}\n         * * {@link BitStructure}\n         *\n         * If left undefined the JavaScript representation of these layouts\n         * will be Object instances.\n         *\n         * See {@link bindConstructorLayout}.\n         */\n        makeDestinationObject() {\n          return {};\n        }\n        /**\n         * Calculate the span of a specific instance of a layout.\n         *\n         * @param {Uint8Array} b - the buffer that contains an encoded instance.\n         *\n         * @param {Number} [offset] - the offset at which the encoded instance\n         * starts.  If absent a zero offset is inferred.\n         *\n         * @return {Number} - the number of bytes covered by the layout\n         * instance.  If this method is not overridden in a subclass the\n         * definition-time constant {@link Layout#span|span} will be\n         * returned.\n         *\n         * @throws {RangeError} - if the length of the value cannot be\n         * determined.\n         */\n        getSpan(b, offset2) {\n          if (0 > this.span) {\n            throw new RangeError(\"indeterminate span\");\n          }\n          return this.span;\n        }\n        /**\n         * Replicate the layout using a new property.\n         *\n         * This function must be used to get a structurally-equivalent layout\n         * with a different name since all {@link Layout} instances are\n         * immutable.\n         *\n         * **NOTE** This is a shallow copy.  All fields except {@link\n         * Layout#property|property} are strictly equal to the origin layout.\n         *\n         * @param {String} property - the value for {@link\n         * Layout#property|property} in the replica.\n         *\n         * @returns {Layout} - the copy with {@link Layout#property|property}\n         * set to `property`.\n         */\n        replicate(property) {\n          const rv = Object.create(this.constructor.prototype);\n          Object.assign(rv, this);\n          rv.property = property;\n          return rv;\n        }\n        /**\n         * Create an object from layout properties and an array of values.\n         *\n         * **NOTE** This function returns `undefined` if invoked on a layout\n         * that does not return its value as an Object.  Objects are\n         * returned for things that are a {@link Structure}, which includes\n         * {@link VariantLayout|variant layouts} if they are structures, and\n         * excludes {@link Union}s.  If you want this feature for a union\n         * you must use {@link Union.getVariant|getVariant} to select the\n         * desired layout.\n         *\n         * @param {Array} values - an array of values that correspond to the\n         * default order for properties.  As with {@link Layout#decode|decode}\n         * layout elements that have no property name are skipped when\n         * iterating over the array values.  Only the top-level properties are\n         * assigned; arguments are not assigned to properties of contained\n         * layouts.  Any unused values are ignored.\n         *\n         * @return {(Object|undefined)}\n         */\n        fromArray(values) {\n          return void 0;\n        }\n      };\n      exports3.Layout = Layout;\n      function nameWithProperty(name, lo) {\n        if (lo.property) {\n          return name + \"[\" + lo.property + \"]\";\n        }\n        return name;\n      }\n      exports3.nameWithProperty = nameWithProperty;\n      function bindConstructorLayout(Class, layout) {\n        if (\"function\" !== typeof Class) {\n          throw new TypeError(\"Class must be constructor\");\n        }\n        if (Object.prototype.hasOwnProperty.call(Class, \"layout_\")) {\n          throw new Error(\"Class is already bound to a layout\");\n        }\n        if (!(layout && layout instanceof Layout)) {\n          throw new TypeError(\"layout must be a Layout\");\n        }\n        if (Object.prototype.hasOwnProperty.call(layout, \"boundConstructor_\")) {\n          throw new Error(\"layout is already bound to a constructor\");\n        }\n        Class.layout_ = layout;\n        layout.boundConstructor_ = Class;\n        layout.makeDestinationObject = () => new Class();\n        Object.defineProperty(Class.prototype, \"encode\", {\n          value(b, offset2) {\n            return layout.encode(this, b, offset2);\n          },\n          writable: true\n        });\n        Object.defineProperty(Class, \"decode\", {\n          value(b, offset2) {\n            return layout.decode(b, offset2);\n          },\n          writable: true\n        });\n      }\n      exports3.bindConstructorLayout = bindConstructorLayout;\n      var ExternalLayout = class extends Layout {\n        /**\n         * Return `true` iff the external layout decodes to an unsigned\n         * integer layout.\n         *\n         * In that case it can be used as the source of {@link\n         * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},\n         * or as {@link UnionLayoutDiscriminator#layout|external union\n         * discriminators}.\n         *\n         * @abstract\n         */\n        isCount() {\n          throw new Error(\"ExternalLayout is abstract\");\n        }\n      };\n      exports3.ExternalLayout = ExternalLayout;\n      var GreedyCount = class extends ExternalLayout {\n        constructor(elementSpan = 1, property) {\n          if (!Number.isInteger(elementSpan) || 0 >= elementSpan) {\n            throw new TypeError(\"elementSpan must be a (positive) integer\");\n          }\n          super(-1, property);\n          this.elementSpan = elementSpan;\n        }\n        /** @override */\n        isCount() {\n          return true;\n        }\n        /** @override */\n        decode(b, offset2 = 0) {\n          checkUint8Array(b);\n          const rem = b.length - offset2;\n          return Math.floor(rem / this.elementSpan);\n        }\n        /** @override */\n        encode(src, b, offset2) {\n          return 0;\n        }\n      };\n      exports3.GreedyCount = GreedyCount;\n      var OffsetLayout = class extends ExternalLayout {\n        constructor(layout, offset2 = 0, property) {\n          if (!(layout instanceof Layout)) {\n            throw new TypeError(\"layout must be a Layout\");\n          }\n          if (!Number.isInteger(offset2)) {\n            throw new TypeError(\"offset must be integer or undefined\");\n          }\n          super(layout.span, property || layout.property);\n          this.layout = layout;\n          this.offset = offset2;\n        }\n        /** @override */\n        isCount() {\n          return this.layout instanceof UInt || this.layout instanceof UIntBE;\n        }\n        /** @override */\n        decode(b, offset2 = 0) {\n          return this.layout.decode(b, offset2 + this.offset);\n        }\n        /** @override */\n        encode(src, b, offset2 = 0) {\n          return this.layout.encode(src, b, offset2 + this.offset);\n        }\n      };\n      exports3.OffsetLayout = OffsetLayout;\n      var UInt = class extends Layout {\n        constructor(span, property) {\n          super(span, property);\n          if (6 < this.span) {\n            throw new RangeError(\"span must not exceed 6 bytes\");\n          }\n        }\n        /** @override */\n        decode(b, offset2 = 0) {\n          return uint8ArrayToBuffer(b).readUIntLE(offset2, this.span);\n        }\n        /** @override */\n        encode(src, b, offset2 = 0) {\n          uint8ArrayToBuffer(b).writeUIntLE(src, offset2, this.span);\n          return this.span;\n        }\n      };\n      exports3.UInt = UInt;\n      var UIntBE = class extends Layout {\n        constructor(span, property) {\n          super(span, property);\n          if (6 < this.span) {\n            throw new RangeError(\"span must not exceed 6 bytes\");\n          }\n        }\n        /** @override */\n        decode(b, offset2 = 0) {\n          return uint8ArrayToBuffer(b).readUIntBE(offset2, this.span);\n        }\n        /** @override */\n        encode(src, b, offset2 = 0) {\n          uint8ArrayToBuffer(b).writeUIntBE(src, offset2, this.span);\n          return this.span;\n        }\n      };\n      exports3.UIntBE = UIntBE;\n      var Int = class extends Layout {\n        constructor(span, property) {\n          super(span, property);\n          if (6 < this.span) {\n            throw new RangeError(\"span must not exceed 6 bytes\");\n          }\n        }\n        /** @override */\n        decode(b, offset2 = 0) {\n          return uint8ArrayToBuffer(b).readIntLE(offset2, this.span);\n        }\n        /** @override */\n        encode(src, b, offset2 = 0) {\n          uint8ArrayToBuffer(b).writeIntLE(src, offset2, this.span);\n          return this.span;\n        }\n      };\n      exports3.Int = Int;\n      var IntBE = class extends Layout {\n        constructor(span, property) {\n          super(span, property);\n          if (6 < this.span) {\n            throw new RangeError(\"span must not exceed 6 bytes\");\n          }\n        }\n        /** @override */\n        decode(b, offset2 = 0) {\n          return uint8ArrayToBuffer(b).readIntBE(offset2, this.span);\n        }\n        /** @override */\n        encode(src, b, offset2 = 0) {\n          uint8ArrayToBuffer(b).writeIntBE(src, offset2, this.span);\n          return this.span;\n        }\n      };\n      exports3.IntBE = IntBE;\n      var V2E32 = Math.pow(2, 32);\n      function divmodInt64(src) {\n        const hi32 = Math.floor(src / V2E32);\n        const lo32 = src - hi32 * V2E32;\n        return { hi32, lo32 };\n      }\n      function roundedInt64(hi32, lo32) {\n        return hi32 * V2E32 + lo32;\n      }\n      var NearUInt64 = class extends Layout {\n        constructor(property) {\n          super(8, property);\n        }\n        /** @override */\n        decode(b, offset2 = 0) {\n          const buffer = uint8ArrayToBuffer(b);\n          const lo32 = buffer.readUInt32LE(offset2);\n          const hi32 = buffer.readUInt32LE(offset2 + 4);\n          return roundedInt64(hi32, lo32);\n        }\n        /** @override */\n        encode(src, b, offset2 = 0) {\n          const split2 = divmodInt64(src);\n          const buffer = uint8ArrayToBuffer(b);\n          buffer.writeUInt32LE(split2.lo32, offset2);\n          buffer.writeUInt32LE(split2.hi32, offset2 + 4);\n          return 8;\n        }\n      };\n      exports3.NearUInt64 = NearUInt64;\n      var NearUInt64BE = class extends Layout {\n        constructor(property) {\n          super(8, property);\n        }\n        /** @override */\n        decode(b, offset2 = 0) {\n          const buffer = uint8ArrayToBuffer(b);\n          const hi32 = buffer.readUInt32BE(offset2);\n          const lo32 = buffer.readUInt32BE(offset2 + 4);\n          return roundedInt64(hi32, lo32);\n        }\n        /** @override */\n        encode(src, b, offset2 = 0) {\n          const split2 = divmodInt64(src);\n          const buffer = uint8ArrayToBuffer(b);\n          buffer.writeUInt32BE(split2.hi32, offset2);\n          buffer.writeUInt32BE(split2.lo32, offset2 + 4);\n          return 8;\n        }\n      };\n      exports3.NearUInt64BE = NearUInt64BE;\n      var NearInt64 = class extends Layout {\n        constructor(property) {\n          super(8, property);\n        }\n        /** @override */\n        decode(b, offset2 = 0) {\n          const buffer = uint8ArrayToBuffer(b);\n          const lo32 = buffer.readUInt32LE(offset2);\n          const hi32 = buffer.readInt32LE(offset2 + 4);\n          return roundedInt64(hi32, lo32);\n        }\n        /** @override */\n        encode(src, b, offset2 = 0) {\n          const split2 = divmodInt64(src);\n          const buffer = uint8ArrayToBuffer(b);\n          buffer.writeUInt32LE(split2.lo32, offset2);\n          buffer.writeInt32LE(split2.hi32, offset2 + 4);\n          return 8;\n        }\n      };\n      exports3.NearInt64 = NearInt64;\n      var NearInt64BE = class extends Layout {\n        constructor(property) {\n          super(8, property);\n        }\n        /** @override */\n        decode(b, offset2 = 0) {\n          const buffer = uint8ArrayToBuffer(b);\n          const hi32 = buffer.readInt32BE(offset2);\n          const lo32 = buffer.readUInt32BE(offset2 + 4);\n          return roundedInt64(hi32, lo32);\n        }\n        /** @override */\n        encode(src, b, offset2 = 0) {\n          const split2 = divmodInt64(src);\n          const buffer = uint8ArrayToBuffer(b);\n          buffer.writeInt32BE(split2.hi32, offset2);\n          buffer.writeUInt32BE(split2.lo32, offset2 + 4);\n          return 8;\n        }\n      };\n      exports3.NearInt64BE = NearInt64BE;\n      var Float = class extends Layout {\n        constructor(property) {\n          super(4, property);\n        }\n        /** @override */\n        decode(b, offset2 = 0) {\n          return uint8ArrayToBuffer(b).readFloatLE(offset2);\n        }\n        /** @override */\n        encode(src, b, offset2 = 0) {\n          uint8ArrayToBuffer(b).writeFloatLE(src, offset2);\n          return 4;\n        }\n      };\n      exports3.Float = Float;\n      var FloatBE = class extends Layout {\n        constructor(property) {\n          super(4, property);\n        }\n        /** @override */\n        decode(b, offset2 = 0) {\n          return uint8ArrayToBuffer(b).readFloatBE(offset2);\n        }\n        /** @override */\n        encode(src, b, offset2 = 0) {\n          uint8ArrayToBuffer(b).writeFloatBE(src, offset2);\n          return 4;\n        }\n      };\n      exports3.FloatBE = FloatBE;\n      var Double = class extends Layout {\n        constructor(property) {\n          super(8, property);\n        }\n        /** @override */\n        decode(b, offset2 = 0) {\n          return uint8ArrayToBuffer(b).readDoubleLE(offset2);\n        }\n        /** @override */\n        encode(src, b, offset2 = 0) {\n          uint8ArrayToBuffer(b).writeDoubleLE(src, offset2);\n          return 8;\n        }\n      };\n      exports3.Double = Double;\n      var DoubleBE = class extends Layout {\n        constructor(property) {\n          super(8, property);\n        }\n        /** @override */\n        decode(b, offset2 = 0) {\n          return uint8ArrayToBuffer(b).readDoubleBE(offset2);\n        }\n        /** @override */\n        encode(src, b, offset2 = 0) {\n          uint8ArrayToBuffer(b).writeDoubleBE(src, offset2);\n          return 8;\n        }\n      };\n      exports3.DoubleBE = DoubleBE;\n      var Sequence = class extends Layout {\n        constructor(elementLayout, count, property) {\n          if (!(elementLayout instanceof Layout)) {\n            throw new TypeError(\"elementLayout must be a Layout\");\n          }\n          if (!(count instanceof ExternalLayout && count.isCount() || Number.isInteger(count) && 0 <= count)) {\n            throw new TypeError(\"count must be non-negative integer or an unsigned integer ExternalLayout\");\n          }\n          let span = -1;\n          if (!(count instanceof ExternalLayout) && 0 < elementLayout.span) {\n            span = count * elementLayout.span;\n          }\n          super(span, property);\n          this.elementLayout = elementLayout;\n          this.count = count;\n        }\n        /** @override */\n        getSpan(b, offset2 = 0) {\n          if (0 <= this.span) {\n            return this.span;\n          }\n          let span = 0;\n          let count = this.count;\n          if (count instanceof ExternalLayout) {\n            count = count.decode(b, offset2);\n          }\n          if (0 < this.elementLayout.span) {\n            span = count * this.elementLayout.span;\n          } else {\n            let idx = 0;\n            while (idx < count) {\n              span += this.elementLayout.getSpan(b, offset2 + span);\n              ++idx;\n            }\n          }\n          return span;\n        }\n        /** @override */\n        decode(b, offset2 = 0) {\n          const rv = [];\n          let i = 0;\n          let count = this.count;\n          if (count instanceof ExternalLayout) {\n            count = count.decode(b, offset2);\n          }\n          while (i < count) {\n            rv.push(this.elementLayout.decode(b, offset2));\n            offset2 += this.elementLayout.getSpan(b, offset2);\n            i += 1;\n          }\n          return rv;\n        }\n        /** Implement {@link Layout#encode|encode} for {@link Sequence}.\n         *\n         * **NOTE** If `src` is shorter than {@link Sequence#count|count} then\n         * the unused space in the buffer is left unchanged.  If `src` is\n         * longer than {@link Sequence#count|count} the unneeded elements are\n         * ignored.\n         *\n         * **NOTE** If {@link Layout#count|count} is an instance of {@link\n         * ExternalLayout} then the length of `src` will be encoded as the\n         * count after `src` is encoded. */\n        encode(src, b, offset2 = 0) {\n          const elo = this.elementLayout;\n          const span = src.reduce((span2, v) => {\n            return span2 + elo.encode(v, b, offset2 + span2);\n          }, 0);\n          if (this.count instanceof ExternalLayout) {\n            this.count.encode(src.length, b, offset2);\n          }\n          return span;\n        }\n      };\n      exports3.Sequence = Sequence;\n      var Structure = class extends Layout {\n        constructor(fields, property, decodePrefixes) {\n          if (!(Array.isArray(fields) && fields.reduce((acc, v) => acc && v instanceof Layout, true))) {\n            throw new TypeError(\"fields must be array of Layout instances\");\n          }\n          if (\"boolean\" === typeof property && void 0 === decodePrefixes) {\n            decodePrefixes = property;\n            property = void 0;\n          }\n          for (const fd of fields) {\n            if (0 > fd.span && void 0 === fd.property) {\n              throw new Error(\"fields cannot contain unnamed variable-length layout\");\n            }\n          }\n          let span = -1;\n          try {\n            span = fields.reduce((span2, fd) => span2 + fd.getSpan(), 0);\n          } catch (e) {\n          }\n          super(span, property);\n          this.fields = fields;\n          this.decodePrefixes = !!decodePrefixes;\n        }\n        /** @override */\n        getSpan(b, offset2 = 0) {\n          if (0 <= this.span) {\n            return this.span;\n          }\n          let span = 0;\n          try {\n            span = this.fields.reduce((span2, fd) => {\n              const fsp = fd.getSpan(b, offset2);\n              offset2 += fsp;\n              return span2 + fsp;\n            }, 0);\n          } catch (e) {\n            throw new RangeError(\"indeterminate span\");\n          }\n          return span;\n        }\n        /** @override */\n        decode(b, offset2 = 0) {\n          checkUint8Array(b);\n          const dest = this.makeDestinationObject();\n          for (const fd of this.fields) {\n            if (void 0 !== fd.property) {\n              dest[fd.property] = fd.decode(b, offset2);\n            }\n            offset2 += fd.getSpan(b, offset2);\n            if (this.decodePrefixes && b.length === offset2) {\n              break;\n            }\n          }\n          return dest;\n        }\n        /** Implement {@link Layout#encode|encode} for {@link Structure}.\n         *\n         * If `src` is missing a property for a member with a defined {@link\n         * Layout#property|property} the corresponding region of the buffer is\n         * left unmodified. */\n        encode(src, b, offset2 = 0) {\n          const firstOffset = offset2;\n          let lastOffset = 0;\n          let lastWrote = 0;\n          for (const fd of this.fields) {\n            let span = fd.span;\n            lastWrote = 0 < span ? span : 0;\n            if (void 0 !== fd.property) {\n              const fv = src[fd.property];\n              if (void 0 !== fv) {\n                lastWrote = fd.encode(fv, b, offset2);\n                if (0 > span) {\n                  span = fd.getSpan(b, offset2);\n                }\n              }\n            }\n            lastOffset = offset2;\n            offset2 += span;\n          }\n          return lastOffset + lastWrote - firstOffset;\n        }\n        /** @override */\n        fromArray(values) {\n          const dest = this.makeDestinationObject();\n          for (const fd of this.fields) {\n            if (void 0 !== fd.property && 0 < values.length) {\n              dest[fd.property] = values.shift();\n            }\n          }\n          return dest;\n        }\n        /**\n         * Get access to the layout of a given property.\n         *\n         * @param {String} property - the structure member of interest.\n         *\n         * @return {Layout} - the layout associated with `property`, or\n         * undefined if there is no such property.\n         */\n        layoutFor(property) {\n          if (\"string\" !== typeof property) {\n            throw new TypeError(\"property must be string\");\n          }\n          for (const fd of this.fields) {\n            if (fd.property === property) {\n              return fd;\n            }\n          }\n          return void 0;\n        }\n        /**\n         * Get the offset of a structure member.\n         *\n         * @param {String} property - the structure member of interest.\n         *\n         * @return {Number} - the offset in bytes to the start of `property`\n         * within the structure, or undefined if `property` is not a field\n         * within the structure.  If the property is a member but follows a\n         * variable-length structure member a negative number will be\n         * returned.\n         */\n        offsetOf(property) {\n          if (\"string\" !== typeof property) {\n            throw new TypeError(\"property must be string\");\n          }\n          let offset2 = 0;\n          for (const fd of this.fields) {\n            if (fd.property === property) {\n              return offset2;\n            }\n            if (0 > fd.span) {\n              offset2 = -1;\n            } else if (0 <= offset2) {\n              offset2 += fd.span;\n            }\n          }\n          return void 0;\n        }\n      };\n      exports3.Structure = Structure;\n      var UnionDiscriminator = class {\n        constructor(property) {\n          this.property = property;\n        }\n        /** Analog to {@link Layout#decode|Layout decode} for union discriminators.\n         *\n         * The implementation of this method need not reference the buffer if\n         * variant information is available through other means. */\n        decode(b, offset2) {\n          throw new Error(\"UnionDiscriminator is abstract\");\n        }\n        /** Analog to {@link Layout#decode|Layout encode} for union discriminators.\n         *\n         * The implementation of this method need not store the value if\n         * variant information is maintained through other means. */\n        encode(src, b, offset2) {\n          throw new Error(\"UnionDiscriminator is abstract\");\n        }\n      };\n      exports3.UnionDiscriminator = UnionDiscriminator;\n      var UnionLayoutDiscriminator = class extends UnionDiscriminator {\n        constructor(layout, property) {\n          if (!(layout instanceof ExternalLayout && layout.isCount())) {\n            throw new TypeError(\"layout must be an unsigned integer ExternalLayout\");\n          }\n          super(property || layout.property || \"variant\");\n          this.layout = layout;\n        }\n        /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n        decode(b, offset2) {\n          return this.layout.decode(b, offset2);\n        }\n        /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n        encode(src, b, offset2) {\n          return this.layout.encode(src, b, offset2);\n        }\n      };\n      exports3.UnionLayoutDiscriminator = UnionLayoutDiscriminator;\n      var Union = class extends Layout {\n        constructor(discr, defaultLayout, property) {\n          let discriminator;\n          if (discr instanceof UInt || discr instanceof UIntBE) {\n            discriminator = new UnionLayoutDiscriminator(new OffsetLayout(discr));\n          } else if (discr instanceof ExternalLayout && discr.isCount()) {\n            discriminator = new UnionLayoutDiscriminator(discr);\n          } else if (!(discr instanceof UnionDiscriminator)) {\n            throw new TypeError(\"discr must be a UnionDiscriminator or an unsigned integer layout\");\n          } else {\n            discriminator = discr;\n          }\n          if (void 0 === defaultLayout) {\n            defaultLayout = null;\n          }\n          if (!(null === defaultLayout || defaultLayout instanceof Layout)) {\n            throw new TypeError(\"defaultLayout must be null or a Layout\");\n          }\n          if (null !== defaultLayout) {\n            if (0 > defaultLayout.span) {\n              throw new Error(\"defaultLayout must have constant span\");\n            }\n            if (void 0 === defaultLayout.property) {\n              defaultLayout = defaultLayout.replicate(\"content\");\n            }\n          }\n          let span = -1;\n          if (defaultLayout) {\n            span = defaultLayout.span;\n            if (0 <= span && (discr instanceof UInt || discr instanceof UIntBE)) {\n              span += discriminator.layout.span;\n            }\n          }\n          super(span, property);\n          this.discriminator = discriminator;\n          this.usesPrefixDiscriminator = discr instanceof UInt || discr instanceof UIntBE;\n          this.defaultLayout = defaultLayout;\n          this.registry = {};\n          let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);\n          this.getSourceVariant = function(src) {\n            return boundGetSourceVariant(src);\n          };\n          this.configGetSourceVariant = function(gsv) {\n            boundGetSourceVariant = gsv.bind(this);\n          };\n        }\n        /** @override */\n        getSpan(b, offset2 = 0) {\n          if (0 <= this.span) {\n            return this.span;\n          }\n          const vlo = this.getVariant(b, offset2);\n          if (!vlo) {\n            throw new Error(\"unable to determine span for unrecognized variant\");\n          }\n          return vlo.getSpan(b, offset2);\n        }\n        /**\n         * Method to infer a registered Union variant compatible with `src`.\n         *\n         * The first satisfied rule in the following sequence defines the\n         * return value:\n         * * If `src` has properties matching the Union discriminator and\n         *   the default layout, `undefined` is returned regardless of the\n         *   value of the discriminator property (this ensures the default\n         *   layout will be used);\n         * * If `src` has a property matching the Union discriminator, the\n         *   value of the discriminator identifies a registered variant, and\n         *   either (a) the variant has no layout, or (b) `src` has the\n         *   variant's property, then the variant is returned (because the\n         *   source satisfies the constraints of the variant it identifies);\n         * * If `src` does not have a property matching the Union\n         *   discriminator, but does have a property matching a registered\n         *   variant, then the variant is returned (because the source\n         *   matches a variant without an explicit conflict);\n         * * An error is thrown (because we either can't identify a variant,\n         *   or we were explicitly told the variant but can't satisfy it).\n         *\n         * @param {Object} src - an object presumed to be compatible with\n         * the content of the Union.\n         *\n         * @return {(undefined|VariantLayout)} - as described above.\n         *\n         * @throws {Error} - if `src` cannot be associated with a default or\n         * registered variant.\n         */\n        defaultGetSourceVariant(src) {\n          if (Object.prototype.hasOwnProperty.call(src, this.discriminator.property)) {\n            if (this.defaultLayout && this.defaultLayout.property && Object.prototype.hasOwnProperty.call(src, this.defaultLayout.property)) {\n              return void 0;\n            }\n            const vlo = this.registry[src[this.discriminator.property]];\n            if (vlo && (!vlo.layout || vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property))) {\n              return vlo;\n            }\n          } else {\n            for (const tag in this.registry) {\n              const vlo = this.registry[tag];\n              if (vlo.property && Object.prototype.hasOwnProperty.call(src, vlo.property)) {\n                return vlo;\n              }\n            }\n          }\n          throw new Error(\"unable to infer src variant\");\n        }\n        /** Implement {@link Layout#decode|decode} for {@link Union}.\n         *\n         * If the variant is {@link Union#addVariant|registered} the return\n         * value is an instance of that variant, with no explicit\n         * discriminator.  Otherwise the {@link Union#defaultLayout|default\n         * layout} is used to decode the content. */\n        decode(b, offset2 = 0) {\n          let dest;\n          const dlo = this.discriminator;\n          const discr = dlo.decode(b, offset2);\n          const clo = this.registry[discr];\n          if (void 0 === clo) {\n            const defaultLayout = this.defaultLayout;\n            let contentOffset = 0;\n            if (this.usesPrefixDiscriminator) {\n              contentOffset = dlo.layout.span;\n            }\n            dest = this.makeDestinationObject();\n            dest[dlo.property] = discr;\n            dest[defaultLayout.property] = defaultLayout.decode(b, offset2 + contentOffset);\n          } else {\n            dest = clo.decode(b, offset2);\n          }\n          return dest;\n        }\n        /** Implement {@link Layout#encode|encode} for {@link Union}.\n         *\n         * This API assumes the `src` object is consistent with the union's\n         * {@link Union#defaultLayout|default layout}.  To encode variants\n         * use the appropriate variant-specific {@link VariantLayout#encode}\n         * method. */\n        encode(src, b, offset2 = 0) {\n          const vlo = this.getSourceVariant(src);\n          if (void 0 === vlo) {\n            const dlo = this.discriminator;\n            const clo = this.defaultLayout;\n            let contentOffset = 0;\n            if (this.usesPrefixDiscriminator) {\n              contentOffset = dlo.layout.span;\n            }\n            dlo.encode(src[dlo.property], b, offset2);\n            return contentOffset + clo.encode(src[clo.property], b, offset2 + contentOffset);\n          }\n          return vlo.encode(src, b, offset2);\n        }\n        /** Register a new variant structure within a union.  The newly\n         * created variant is returned.\n         *\n         * @param {Number} variant - initializer for {@link\n         * VariantLayout#variant|variant}.\n         *\n         * @param {Layout} layout - initializer for {@link\n         * VariantLayout#layout|layout}.\n         *\n         * @param {String} property - initializer for {@link\n         * Layout#property|property}.\n         *\n         * @return {VariantLayout} */\n        addVariant(variant, layout, property) {\n          const rv = new VariantLayout(this, variant, layout, property);\n          this.registry[variant] = rv;\n          return rv;\n        }\n        /**\n         * Get the layout associated with a registered variant.\n         *\n         * If `vb` does not produce a registered variant the function returns\n         * `undefined`.\n         *\n         * @param {(Number|Uint8Array)} vb - either the variant number, or a\n         * buffer from which the discriminator is to be read.\n         *\n         * @param {Number} offset - offset into `vb` for the start of the\n         * union.  Used only when `vb` is an instance of {Uint8Array}.\n         *\n         * @return {({VariantLayout}|undefined)}\n         */\n        getVariant(vb, offset2 = 0) {\n          let variant;\n          if (vb instanceof Uint8Array) {\n            variant = this.discriminator.decode(vb, offset2);\n          } else {\n            variant = vb;\n          }\n          return this.registry[variant];\n        }\n      };\n      exports3.Union = Union;\n      var VariantLayout = class extends Layout {\n        constructor(union2, variant, layout, property) {\n          if (!(union2 instanceof Union)) {\n            throw new TypeError(\"union must be a Union\");\n          }\n          if (!Number.isInteger(variant) || 0 > variant) {\n            throw new TypeError(\"variant must be a (non-negative) integer\");\n          }\n          if (\"string\" === typeof layout && void 0 === property) {\n            property = layout;\n            layout = null;\n          }\n          if (layout) {\n            if (!(layout instanceof Layout)) {\n              throw new TypeError(\"layout must be a Layout\");\n            }\n            if (null !== union2.defaultLayout && 0 <= layout.span && layout.span > union2.defaultLayout.span) {\n              throw new Error(\"variant span exceeds span of containing union\");\n            }\n            if (\"string\" !== typeof property) {\n              throw new TypeError(\"variant must have a String property\");\n            }\n          }\n          let span = union2.span;\n          if (0 > union2.span) {\n            span = layout ? layout.span : 0;\n            if (0 <= span && union2.usesPrefixDiscriminator) {\n              span += union2.discriminator.layout.span;\n            }\n          }\n          super(span, property);\n          this.union = union2;\n          this.variant = variant;\n          this.layout = layout || null;\n        }\n        /** @override */\n        getSpan(b, offset2 = 0) {\n          if (0 <= this.span) {\n            return this.span;\n          }\n          let contentOffset = 0;\n          if (this.union.usesPrefixDiscriminator) {\n            contentOffset = this.union.discriminator.layout.span;\n          }\n          let span = 0;\n          if (this.layout) {\n            span = this.layout.getSpan(b, offset2 + contentOffset);\n          }\n          return contentOffset + span;\n        }\n        /** @override */\n        decode(b, offset2 = 0) {\n          const dest = this.makeDestinationObject();\n          if (this !== this.union.getVariant(b, offset2)) {\n            throw new Error(\"variant mismatch\");\n          }\n          let contentOffset = 0;\n          if (this.union.usesPrefixDiscriminator) {\n            contentOffset = this.union.discriminator.layout.span;\n          }\n          if (this.layout) {\n            dest[this.property] = this.layout.decode(b, offset2 + contentOffset);\n          } else if (this.property) {\n            dest[this.property] = true;\n          } else if (this.union.usesPrefixDiscriminator) {\n            dest[this.union.discriminator.property] = this.variant;\n          }\n          return dest;\n        }\n        /** @override */\n        encode(src, b, offset2 = 0) {\n          let contentOffset = 0;\n          if (this.union.usesPrefixDiscriminator) {\n            contentOffset = this.union.discriminator.layout.span;\n          }\n          if (this.layout && !Object.prototype.hasOwnProperty.call(src, this.property)) {\n            throw new TypeError(\"variant lacks property \" + this.property);\n          }\n          this.union.discriminator.encode(this.variant, b, offset2);\n          let span = contentOffset;\n          if (this.layout) {\n            this.layout.encode(src[this.property], b, offset2 + contentOffset);\n            span += this.layout.getSpan(b, offset2 + contentOffset);\n            if (0 <= this.union.span && span > this.union.span) {\n              throw new Error(\"encoded variant overruns containing union\");\n            }\n          }\n          return span;\n        }\n        /** Delegate {@link Layout#fromArray|fromArray} to {@link\n         * VariantLayout#layout|layout}. */\n        fromArray(values) {\n          if (this.layout) {\n            return this.layout.fromArray(values);\n          }\n          return void 0;\n        }\n      };\n      exports3.VariantLayout = VariantLayout;\n      function fixBitwiseResult(v) {\n        if (0 > v) {\n          v += 4294967296;\n        }\n        return v;\n      }\n      var BitStructure = class extends Layout {\n        constructor(word, msb, property) {\n          if (!(word instanceof UInt || word instanceof UIntBE)) {\n            throw new TypeError(\"word must be a UInt or UIntBE layout\");\n          }\n          if (\"string\" === typeof msb && void 0 === property) {\n            property = msb;\n            msb = false;\n          }\n          if (4 < word.span) {\n            throw new RangeError(\"word cannot exceed 32 bits\");\n          }\n          super(word.span, property);\n          this.word = word;\n          this.msb = !!msb;\n          this.fields = [];\n          let value = 0;\n          this._packedSetValue = function(v) {\n            value = fixBitwiseResult(v);\n            return this;\n          };\n          this._packedGetValue = function() {\n            return value;\n          };\n        }\n        /** @override */\n        decode(b, offset2 = 0) {\n          const dest = this.makeDestinationObject();\n          const value = this.word.decode(b, offset2);\n          this._packedSetValue(value);\n          for (const fd of this.fields) {\n            if (void 0 !== fd.property) {\n              dest[fd.property] = fd.decode(b);\n            }\n          }\n          return dest;\n        }\n        /** Implement {@link Layout#encode|encode} for {@link BitStructure}.\n         *\n         * If `src` is missing a property for a member with a defined {@link\n         * Layout#property|property} the corresponding region of the packed\n         * value is left unmodified.  Unused bits are also left unmodified. */\n        encode(src, b, offset2 = 0) {\n          const value = this.word.decode(b, offset2);\n          this._packedSetValue(value);\n          for (const fd of this.fields) {\n            if (void 0 !== fd.property) {\n              const fv = src[fd.property];\n              if (void 0 !== fv) {\n                fd.encode(fv);\n              }\n            }\n          }\n          return this.word.encode(this._packedGetValue(), b, offset2);\n        }\n        /** Register a new bitfield with a containing bit structure.  The\n         * resulting bitfield is returned.\n         *\n         * @param {Number} bits - initializer for {@link BitField#bits|bits}.\n         *\n         * @param {string} property - initializer for {@link\n         * Layout#property|property}.\n         *\n         * @return {BitField} */\n        addField(bits, property) {\n          const bf = new BitField(this, bits, property);\n          this.fields.push(bf);\n          return bf;\n        }\n        /** As with {@link BitStructure#addField|addField} for single-bit\n         * fields with `boolean` value representation.\n         *\n         * @param {string} property - initializer for {@link\n         * Layout#property|property}.\n         *\n         * @return {Boolean} */\n        // `Boolean` conflicts with the native primitive type\n        // eslint-disable-next-line @typescript-eslint/ban-types\n        addBoolean(property) {\n          const bf = new Boolean2(this, property);\n          this.fields.push(bf);\n          return bf;\n        }\n        /**\n         * Get access to the bit field for a given property.\n         *\n         * @param {String} property - the bit field of interest.\n         *\n         * @return {BitField} - the field associated with `property`, or\n         * undefined if there is no such property.\n         */\n        fieldFor(property) {\n          if (\"string\" !== typeof property) {\n            throw new TypeError(\"property must be string\");\n          }\n          for (const fd of this.fields) {\n            if (fd.property === property) {\n              return fd;\n            }\n          }\n          return void 0;\n        }\n      };\n      exports3.BitStructure = BitStructure;\n      var BitField = class {\n        constructor(container, bits, property) {\n          if (!(container instanceof BitStructure)) {\n            throw new TypeError(\"container must be a BitStructure\");\n          }\n          if (!Number.isInteger(bits) || 0 >= bits) {\n            throw new TypeError(\"bits must be positive integer\");\n          }\n          const totalBits = 8 * container.span;\n          const usedBits = container.fields.reduce((sum, fd) => sum + fd.bits, 0);\n          if (bits + usedBits > totalBits) {\n            throw new Error(\"bits too long for span remainder (\" + (totalBits - usedBits) + \" of \" + totalBits + \" remain)\");\n          }\n          this.container = container;\n          this.bits = bits;\n          this.valueMask = (1 << bits) - 1;\n          if (32 === bits) {\n            this.valueMask = 4294967295;\n          }\n          this.start = usedBits;\n          if (this.container.msb) {\n            this.start = totalBits - usedBits - bits;\n          }\n          this.wordMask = fixBitwiseResult(this.valueMask << this.start);\n          this.property = property;\n        }\n        /** Store a value into the corresponding subsequence of the containing\n         * bit field. */\n        decode(b, offset2) {\n          const word = this.container._packedGetValue();\n          const wordValue = fixBitwiseResult(word & this.wordMask);\n          const value = wordValue >>> this.start;\n          return value;\n        }\n        /** Store a value into the corresponding subsequence of the containing\n         * bit field.\n         *\n         * **NOTE** This is not a specialization of {@link\n         * Layout#encode|Layout.encode} and there is no return value. */\n        encode(value) {\n          if (\"number\" !== typeof value || !Number.isInteger(value) || value !== fixBitwiseResult(value & this.valueMask)) {\n            throw new TypeError(nameWithProperty(\"BitField.encode\", this) + \" value must be integer not exceeding \" + this.valueMask);\n          }\n          const word = this.container._packedGetValue();\n          const wordValue = fixBitwiseResult(value << this.start);\n          this.container._packedSetValue(fixBitwiseResult(word & ~this.wordMask) | wordValue);\n        }\n      };\n      exports3.BitField = BitField;\n      var Boolean2 = class extends BitField {\n        constructor(container, property) {\n          super(container, 1, property);\n        }\n        /** Override {@link BitField#decode|decode} for {@link Boolean|Boolean}.\n         *\n         * @returns {boolean} */\n        decode(b, offset2) {\n          return !!super.decode(b, offset2);\n        }\n        /** @override */\n        encode(value) {\n          if (\"boolean\" === typeof value) {\n            value = +value;\n          }\n          super.encode(value);\n        }\n      };\n      exports3.Boolean = Boolean2;\n      var Blob = class extends Layout {\n        constructor(length, property) {\n          if (!(length instanceof ExternalLayout && length.isCount() || Number.isInteger(length) && 0 <= length)) {\n            throw new TypeError(\"length must be positive integer or an unsigned integer ExternalLayout\");\n          }\n          let span = -1;\n          if (!(length instanceof ExternalLayout)) {\n            span = length;\n          }\n          super(span, property);\n          this.length = length;\n        }\n        /** @override */\n        getSpan(b, offset2) {\n          let span = this.span;\n          if (0 > span) {\n            span = this.length.decode(b, offset2);\n          }\n          return span;\n        }\n        /** @override */\n        decode(b, offset2 = 0) {\n          let span = this.span;\n          if (0 > span) {\n            span = this.length.decode(b, offset2);\n          }\n          return uint8ArrayToBuffer(b).slice(offset2, offset2 + span);\n        }\n        /** Implement {@link Layout#encode|encode} for {@link Blob}.\n         *\n         * **NOTE** If {@link Layout#count|count} is an instance of {@link\n         * ExternalLayout} then the length of `src` will be encoded as the\n         * count after `src` is encoded. */\n        encode(src, b, offset2) {\n          let span = this.length;\n          if (this.length instanceof ExternalLayout) {\n            span = src.length;\n          }\n          if (!(src instanceof Uint8Array && span === src.length)) {\n            throw new TypeError(nameWithProperty(\"Blob.encode\", this) + \" requires (length \" + span + \") Uint8Array as src\");\n          }\n          if (offset2 + span > b.length) {\n            throw new RangeError(\"encoding overruns Uint8Array\");\n          }\n          const srcBuffer = uint8ArrayToBuffer(src);\n          uint8ArrayToBuffer(b).write(srcBuffer.toString(\"hex\"), offset2, span, \"hex\");\n          if (this.length instanceof ExternalLayout) {\n            this.length.encode(span, b, offset2);\n          }\n          return span;\n        }\n      };\n      exports3.Blob = Blob;\n      var CString = class extends Layout {\n        constructor(property) {\n          super(-1, property);\n        }\n        /** @override */\n        getSpan(b, offset2 = 0) {\n          checkUint8Array(b);\n          let idx = offset2;\n          while (idx < b.length && 0 !== b[idx]) {\n            idx += 1;\n          }\n          return 1 + idx - offset2;\n        }\n        /** @override */\n        decode(b, offset2 = 0) {\n          const span = this.getSpan(b, offset2);\n          return uint8ArrayToBuffer(b).slice(offset2, offset2 + span - 1).toString(\"utf-8\");\n        }\n        /** @override */\n        encode(src, b, offset2 = 0) {\n          if (\"string\" !== typeof src) {\n            src = String(src);\n          }\n          const srcb = buffer_1.Buffer.from(src, \"utf8\");\n          const span = srcb.length;\n          if (offset2 + span > b.length) {\n            throw new RangeError(\"encoding overruns Buffer\");\n          }\n          const buffer = uint8ArrayToBuffer(b);\n          srcb.copy(buffer, offset2);\n          buffer[offset2 + span] = 0;\n          return span + 1;\n        }\n      };\n      exports3.CString = CString;\n      var UTF8 = class extends Layout {\n        constructor(maxSpan, property) {\n          if (\"string\" === typeof maxSpan && void 0 === property) {\n            property = maxSpan;\n            maxSpan = void 0;\n          }\n          if (void 0 === maxSpan) {\n            maxSpan = -1;\n          } else if (!Number.isInteger(maxSpan)) {\n            throw new TypeError(\"maxSpan must be an integer\");\n          }\n          super(-1, property);\n          this.maxSpan = maxSpan;\n        }\n        /** @override */\n        getSpan(b, offset2 = 0) {\n          checkUint8Array(b);\n          return b.length - offset2;\n        }\n        /** @override */\n        decode(b, offset2 = 0) {\n          const span = this.getSpan(b, offset2);\n          if (0 <= this.maxSpan && this.maxSpan < span) {\n            throw new RangeError(\"text length exceeds maxSpan\");\n          }\n          return uint8ArrayToBuffer(b).slice(offset2, offset2 + span).toString(\"utf-8\");\n        }\n        /** @override */\n        encode(src, b, offset2 = 0) {\n          if (\"string\" !== typeof src) {\n            src = String(src);\n          }\n          const srcb = buffer_1.Buffer.from(src, \"utf8\");\n          const span = srcb.length;\n          if (0 <= this.maxSpan && this.maxSpan < span) {\n            throw new RangeError(\"text length exceeds maxSpan\");\n          }\n          if (offset2 + span > b.length) {\n            throw new RangeError(\"encoding overruns Buffer\");\n          }\n          srcb.copy(uint8ArrayToBuffer(b), offset2);\n          return span;\n        }\n      };\n      exports3.UTF8 = UTF8;\n      var Constant = class extends Layout {\n        constructor(value, property) {\n          super(0, property);\n          this.value = value;\n        }\n        /** @override */\n        decode(b, offset2) {\n          return this.value;\n        }\n        /** @override */\n        encode(src, b, offset2) {\n          return 0;\n        }\n      };\n      exports3.Constant = Constant;\n      exports3.greedy = (elementSpan, property) => new GreedyCount(elementSpan, property);\n      exports3.offset = (layout, offset2, property) => new OffsetLayout(layout, offset2, property);\n      exports3.u8 = (property) => new UInt(1, property);\n      exports3.u16 = (property) => new UInt(2, property);\n      exports3.u24 = (property) => new UInt(3, property);\n      exports3.u32 = (property) => new UInt(4, property);\n      exports3.u40 = (property) => new UInt(5, property);\n      exports3.u48 = (property) => new UInt(6, property);\n      exports3.nu64 = (property) => new NearUInt64(property);\n      exports3.u16be = (property) => new UIntBE(2, property);\n      exports3.u24be = (property) => new UIntBE(3, property);\n      exports3.u32be = (property) => new UIntBE(4, property);\n      exports3.u40be = (property) => new UIntBE(5, property);\n      exports3.u48be = (property) => new UIntBE(6, property);\n      exports3.nu64be = (property) => new NearUInt64BE(property);\n      exports3.s8 = (property) => new Int(1, property);\n      exports3.s16 = (property) => new Int(2, property);\n      exports3.s24 = (property) => new Int(3, property);\n      exports3.s32 = (property) => new Int(4, property);\n      exports3.s40 = (property) => new Int(5, property);\n      exports3.s48 = (property) => new Int(6, property);\n      exports3.ns64 = (property) => new NearInt64(property);\n      exports3.s16be = (property) => new IntBE(2, property);\n      exports3.s24be = (property) => new IntBE(3, property);\n      exports3.s32be = (property) => new IntBE(4, property);\n      exports3.s40be = (property) => new IntBE(5, property);\n      exports3.s48be = (property) => new IntBE(6, property);\n      exports3.ns64be = (property) => new NearInt64BE(property);\n      exports3.f32 = (property) => new Float(property);\n      exports3.f32be = (property) => new FloatBE(property);\n      exports3.f64 = (property) => new Double(property);\n      exports3.f64be = (property) => new DoubleBE(property);\n      exports3.struct = (fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes);\n      exports3.bits = (word, msb, property) => new BitStructure(word, msb, property);\n      exports3.seq = (elementLayout, count, property) => new Sequence(elementLayout, count, property);\n      exports3.union = (discr, defaultLayout, property) => new Union(discr, defaultLayout, property);\n      exports3.unionLayoutDiscriminator = (layout, property) => new UnionLayoutDiscriminator(layout, property);\n      exports3.blob = (length, property) => new Blob(length, property);\n      exports3.cstr = (property) => new CString(property);\n      exports3.utf8 = (maxSpan, property) => new UTF8(maxSpan, property);\n      exports3.constant = (value, property) => new Constant(value, property);\n    }\n  });\n\n  // ../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/rng.js\n  function rng() {\n    if (!getRandomValues) {\n      getRandomValues = typeof crypto !== \"undefined\" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto !== \"undefined\" && typeof msCrypto.getRandomValues === \"function\" && msCrypto.getRandomValues.bind(msCrypto);\n      if (!getRandomValues) {\n        throw new Error(\"crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported\");\n      }\n    }\n    return getRandomValues(rnds8);\n  }\n  var getRandomValues, rnds8;\n  var init_rng = __esm({\n    \"../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/rng.js\"() {\n      \"use strict\";\n      init_dirname();\n      init_buffer2();\n      init_process2();\n      rnds8 = new Uint8Array(16);\n    }\n  });\n\n  // ../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/regex.js\n  var regex_default;\n  var init_regex = __esm({\n    \"../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/regex.js\"() {\n      \"use strict\";\n      init_dirname();\n      init_buffer2();\n      init_process2();\n      regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\n    }\n  });\n\n  // ../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/validate.js\n  function validate2(uuid) {\n    return typeof uuid === \"string\" && regex_default.test(uuid);\n  }\n  var validate_default;\n  var init_validate = __esm({\n    \"../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/validate.js\"() {\n      \"use strict\";\n      init_dirname();\n      init_buffer2();\n      init_process2();\n      init_regex();\n      validate_default = validate2;\n    }\n  });\n\n  // ../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/stringify.js\n  function stringify(arr) {\n    var offset2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n    var uuid = (byteToHex[arr[offset2 + 0]] + byteToHex[arr[offset2 + 1]] + byteToHex[arr[offset2 + 2]] + byteToHex[arr[offset2 + 3]] + \"-\" + byteToHex[arr[offset2 + 4]] + byteToHex[arr[offset2 + 5]] + \"-\" + byteToHex[arr[offset2 + 6]] + byteToHex[arr[offset2 + 7]] + \"-\" + byteToHex[arr[offset2 + 8]] + byteToHex[arr[offset2 + 9]] + \"-\" + byteToHex[arr[offset2 + 10]] + byteToHex[arr[offset2 + 11]] + byteToHex[arr[offset2 + 12]] + byteToHex[arr[offset2 + 13]] + byteToHex[arr[offset2 + 14]] + byteToHex[arr[offset2 + 15]]).toLowerCase();\n    if (!validate_default(uuid)) {\n      throw TypeError(\"Stringified UUID is invalid\");\n    }\n    return uuid;\n  }\n  var byteToHex, i, stringify_default;\n  var init_stringify = __esm({\n    \"../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/stringify.js\"() {\n      \"use strict\";\n      init_dirname();\n      init_buffer2();\n      init_process2();\n      init_validate();\n      byteToHex = [];\n      for (i = 0; i < 256; ++i) {\n        byteToHex.push((i + 256).toString(16).substr(1));\n      }\n      stringify_default = stringify;\n    }\n  });\n\n  // ../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/v1.js\n  function v1(options, buf, offset2) {\n    var i = buf && offset2 || 0;\n    var b = buf || new Array(16);\n    options = options || {};\n    var node = options.node || _nodeId;\n    var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;\n    if (node == null || clockseq == null) {\n      var seedBytes = options.random || (options.rng || rng)();\n      if (node == null) {\n        node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n      }\n      if (clockseq == null) {\n        clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;\n      }\n    }\n    var msecs = options.msecs !== void 0 ? options.msecs : Date.now();\n    var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;\n    var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;\n    if (dt < 0 && options.clockseq === void 0) {\n      clockseq = clockseq + 1 & 16383;\n    }\n    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {\n      nsecs = 0;\n    }\n    if (nsecs >= 1e4) {\n      throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n    }\n    _lastMSecs = msecs;\n    _lastNSecs = nsecs;\n    _clockseq = clockseq;\n    msecs += 122192928e5;\n    var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;\n    b[i++] = tl >>> 24 & 255;\n    b[i++] = tl >>> 16 & 255;\n    b[i++] = tl >>> 8 & 255;\n    b[i++] = tl & 255;\n    var tmh = msecs / 4294967296 * 1e4 & 268435455;\n    b[i++] = tmh >>> 8 & 255;\n    b[i++] = tmh & 255;\n    b[i++] = tmh >>> 24 & 15 | 16;\n    b[i++] = tmh >>> 16 & 255;\n    b[i++] = clockseq >>> 8 | 128;\n    b[i++] = clockseq & 255;\n    for (var n = 0; n < 6; ++n) {\n      b[i + n] = node[n];\n    }\n    return buf || stringify_default(b);\n  }\n  var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;\n  var init_v1 = __esm({\n    \"../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/v1.js\"() {\n      \"use strict\";\n      init_dirname();\n      init_buffer2();\n      init_process2();\n      init_rng();\n      init_stringify();\n      _lastMSecs = 0;\n      _lastNSecs = 0;\n      v1_default = v1;\n    }\n  });\n\n  // ../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/parse.js\n  function parse(uuid) {\n    if (!validate_default(uuid)) {\n      throw TypeError(\"Invalid UUID\");\n    }\n    var v;\n    var arr = new Uint8Array(16);\n    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n    arr[1] = v >>> 16 & 255;\n    arr[2] = v >>> 8 & 255;\n    arr[3] = v & 255;\n    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n    arr[5] = v & 255;\n    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n    arr[7] = v & 255;\n    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n    arr[9] = v & 255;\n    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;\n    arr[11] = v / 4294967296 & 255;\n    arr[12] = v >>> 24 & 255;\n    arr[13] = v >>> 16 & 255;\n    arr[14] = v >>> 8 & 255;\n    arr[15] = v & 255;\n    return arr;\n  }\n  var parse_default;\n  var init_parse = __esm({\n    \"../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/parse.js\"() {\n      \"use strict\";\n      init_dirname();\n      init_buffer2();\n      init_process2();\n      init_validate();\n      parse_default = parse;\n    }\n  });\n\n  // ../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/v35.js\n  function stringToBytes(str) {\n    str = unescape(encodeURIComponent(str));\n    var bytes = [];\n    for (var i = 0; i < str.length; ++i) {\n      bytes.push(str.charCodeAt(i));\n    }\n    return bytes;\n  }\n  function v35_default(name, version2, hashfunc) {\n    function generateUUID(value, namespace, buf, offset2) {\n      if (typeof value === \"string\") {\n        value = stringToBytes(value);\n      }\n      if (typeof namespace === \"string\") {\n        namespace = parse_default(namespace);\n      }\n      if (namespace.length !== 16) {\n        throw TypeError(\"Namespace must be array-like (16 iterable integer values, 0-255)\");\n      }\n      var bytes = new Uint8Array(16 + value.length);\n      bytes.set(namespace);\n      bytes.set(value, namespace.length);\n      bytes = hashfunc(bytes);\n      bytes[6] = bytes[6] & 15 | version2;\n      bytes[8] = bytes[8] & 63 | 128;\n      if (buf) {\n        offset2 = offset2 || 0;\n        for (var i = 0; i < 16; ++i) {\n          buf[offset2 + i] = bytes[i];\n        }\n        return buf;\n      }\n      return stringify_default(bytes);\n    }\n    try {\n      generateUUID.name = name;\n    } catch (err) {\n    }\n    generateUUID.DNS = DNS;\n    generateUUID.URL = URL;\n    return generateUUID;\n  }\n  var DNS, URL;\n  var init_v35 = __esm({\n    \"../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/v35.js\"() {\n      \"use strict\";\n      init_dirname();\n      init_buffer2();\n      init_process2();\n      init_stringify();\n      init_parse();\n      DNS = \"6ba7b810-9dad-11d1-80b4-00c04fd430c8\";\n      URL = \"6ba7b811-9dad-11d1-80b4-00c04fd430c8\";\n    }\n  });\n\n  // ../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/md5.js\n  function md5(bytes) {\n    if (typeof bytes === \"string\") {\n      var msg = unescape(encodeURIComponent(bytes));\n      bytes = new Uint8Array(msg.length);\n      for (var i = 0; i < msg.length; ++i) {\n        bytes[i] = msg.charCodeAt(i);\n      }\n    }\n    return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));\n  }\n  function md5ToHexEncodedArray(input) {\n    var output = [];\n    var length32 = input.length * 32;\n    var hexTab = \"0123456789abcdef\";\n    for (var i = 0; i < length32; i += 8) {\n      var x = input[i >> 5] >>> i % 32 & 255;\n      var hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);\n      output.push(hex);\n    }\n    return output;\n  }\n  function getOutputLength(inputLength8) {\n    return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;\n  }\n  function wordsToMd5(x, len) {\n    x[len >> 5] |= 128 << len % 32;\n    x[getOutputLength(len) - 1] = len;\n    var a = 1732584193;\n    var b = -271733879;\n    var c = -1732584194;\n    var d = 271733878;\n    for (var i = 0; i < x.length; i += 16) {\n      var olda = a;\n      var oldb = b;\n      var oldc = c;\n      var oldd = d;\n      a = md5ff(a, b, c, d, x[i], 7, -680876936);\n      d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n      c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n      b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n      a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n      d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n      c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n      b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n      a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n      d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n      c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n      b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n      a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n      d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n      c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n      b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n      a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n      d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n      c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n      b = md5gg(b, c, d, a, x[i], 20, -373897302);\n      a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n      d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n      c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n      b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n      a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n      d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n      c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n      b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n      a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n      d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n      c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n      b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n      a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n      d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n      c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n      b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n      a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n      d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n      c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n      b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n      a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n      d = md5hh(d, a, b, c, x[i], 11, -358537222);\n      c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n      b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n      a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n      d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n      c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n      b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n      a = md5ii(a, b, c, d, x[i], 6, -198630844);\n      d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n      c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n      b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n      a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n      d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n      c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n      b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n      a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n      d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n      c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n      b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n      a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n      d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n      c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n      b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n      a = safeAdd(a, olda);\n      b = safeAdd(b, oldb);\n      c = safeAdd(c, oldc);\n      d = safeAdd(d, oldd);\n    }\n    return [a, b, c, d];\n  }\n  function bytesToWords(input) {\n    if (input.length === 0) {\n      return [];\n    }\n    var length8 = input.length * 8;\n    var output = new Uint32Array(getOutputLength(length8));\n    for (var i = 0; i < length8; i += 8) {\n      output[i >> 5] |= (input[i / 8] & 255) << i % 32;\n    }\n    return output;\n  }\n  function safeAdd(x, y) {\n    var lsw = (x & 65535) + (y & 65535);\n    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n    return msw << 16 | lsw & 65535;\n  }\n  function bitRotateLeft(num, cnt) {\n    return num << cnt | num >>> 32 - cnt;\n  }\n  function md5cmn(q, a, b, x, s, t) {\n    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);\n  }\n  function md5ff(a, b, c, d, x, s, t) {\n    return md5cmn(b & c | ~b & d, a, b, x, s, t);\n  }\n  function md5gg(a, b, c, d, x, s, t) {\n    return md5cmn(b & d | c & ~d, a, b, x, s, t);\n  }\n  function md5hh(a, b, c, d, x, s, t) {\n    return md5cmn(b ^ c ^ d, a, b, x, s, t);\n  }\n  function md5ii(a, b, c, d, x, s, t) {\n    return md5cmn(c ^ (b | ~d), a, b, x, s, t);\n  }\n  var md5_default;\n  var init_md5 = __esm({\n    \"../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/md5.js\"() {\n      \"use strict\";\n      init_dirname();\n      init_buffer2();\n      init_process2();\n      md5_default = md5;\n    }\n  });\n\n  // ../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/v3.js\n  var v3, v3_default;\n  var init_v3 = __esm({\n    \"../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/v3.js\"() {\n      \"use strict\";\n      init_dirname();\n      init_buffer2();\n      init_process2();\n      init_v35();\n      init_md5();\n      v3 = v35_default(\"v3\", 48, md5_default);\n      v3_default = v3;\n    }\n  });\n\n  // ../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/v4.js\n  function v4(options, buf, offset2) {\n    options = options || {};\n    var rnds = options.random || (options.rng || rng)();\n    rnds[6] = rnds[6] & 15 | 64;\n    rnds[8] = rnds[8] & 63 | 128;\n    if (buf) {\n      offset2 = offset2 || 0;\n      for (var i = 0; i < 16; ++i) {\n        buf[offset2 + i] = rnds[i];\n      }\n      return buf;\n    }\n    return stringify_default(rnds);\n  }\n  var v4_default;\n  var init_v4 = __esm({\n    \"../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/v4.js\"() {\n      \"use strict\";\n      init_dirname();\n      init_buffer2();\n      init_process2();\n      init_rng();\n      init_stringify();\n      v4_default = v4;\n    }\n  });\n\n  // ../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/sha1.js\n  function f(s, x, y, z) {\n    switch (s) {\n      case 0:\n        return x & y ^ ~x & z;\n      case 1:\n        return x ^ y ^ z;\n      case 2:\n        return x & y ^ x & z ^ y & z;\n      case 3:\n        return x ^ y ^ z;\n    }\n  }\n  function ROTL(x, n) {\n    return x << n | x >>> 32 - n;\n  }\n  function sha1(bytes) {\n    var K = [1518500249, 1859775393, 2400959708, 3395469782];\n    var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];\n    if (typeof bytes === \"string\") {\n      var msg = unescape(encodeURIComponent(bytes));\n      bytes = [];\n      for (var i = 0; i < msg.length; ++i) {\n        bytes.push(msg.charCodeAt(i));\n      }\n    } else if (!Array.isArray(bytes)) {\n      bytes = Array.prototype.slice.call(bytes);\n    }\n    bytes.push(128);\n    var l = bytes.length / 4 + 2;\n    var N = Math.ceil(l / 16);\n    var M = new Array(N);\n    for (var _i = 0; _i < N; ++_i) {\n      var arr = new Uint32Array(16);\n      for (var j = 0; j < 16; ++j) {\n        arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];\n      }\n      M[_i] = arr;\n    }\n    M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n    M[N - 1][14] = Math.floor(M[N - 1][14]);\n    M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;\n    for (var _i2 = 0; _i2 < N; ++_i2) {\n      var W = new Uint32Array(80);\n      for (var t = 0; t < 16; ++t) {\n        W[t] = M[_i2][t];\n      }\n      for (var _t = 16; _t < 80; ++_t) {\n        W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);\n      }\n      var a = H[0];\n      var b = H[1];\n      var c = H[2];\n      var d = H[3];\n      var e = H[4];\n      for (var _t2 = 0; _t2 < 80; ++_t2) {\n        var s = Math.floor(_t2 / 20);\n        var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;\n        e = d;\n        d = c;\n        c = ROTL(b, 30) >>> 0;\n        b = a;\n        a = T;\n      }\n      H[0] = H[0] + a >>> 0;\n      H[1] = H[1] + b >>> 0;\n      H[2] = H[2] + c >>> 0;\n      H[3] = H[3] + d >>> 0;\n      H[4] = H[4] + e >>> 0;\n    }\n    return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];\n  }\n  var sha1_default;\n  var init_sha1 = __esm({\n    \"../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/sha1.js\"() {\n      \"use strict\";\n      init_dirname();\n      init_buffer2();\n      init_process2();\n      sha1_default = sha1;\n    }\n  });\n\n  // ../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/v5.js\n  var v5, v5_default;\n  var init_v5 = __esm({\n    \"../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/v5.js\"() {\n      \"use strict\";\n      init_dirname();\n      init_buffer2();\n      init_process2();\n      init_v35();\n      init_sha1();\n      v5 = v35_default(\"v5\", 80, sha1_default);\n      v5_default = v5;\n    }\n  });\n\n  // ../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/nil.js\n  var nil_default;\n  var init_nil = __esm({\n    \"../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/nil.js\"() {\n      \"use strict\";\n      init_dirname();\n      init_buffer2();\n      init_process2();\n      nil_default = \"00000000-0000-0000-0000-000000000000\";\n    }\n  });\n\n  // ../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/version.js\n  function version(uuid) {\n    if (!validate_default(uuid)) {\n      throw TypeError(\"Invalid UUID\");\n    }\n    return parseInt(uuid.substr(14, 1), 16);\n  }\n  var version_default;\n  var init_version = __esm({\n    \"../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/version.js\"() {\n      \"use strict\";\n      init_dirname();\n      init_buffer2();\n      init_process2();\n      init_validate();\n      version_default = version;\n    }\n  });\n\n  // ../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/index.js\n  var esm_browser_exports = {};\n  __export(esm_browser_exports, {\n    NIL: () => nil_default,\n    parse: () => parse_default,\n    stringify: () => stringify_default,\n    v1: () => v1_default,\n    v3: () => v3_default,\n    v4: () => v4_default,\n    v5: () => v5_default,\n    validate: () => validate_default,\n    version: () => version_default\n  });\n  var init_esm_browser = __esm({\n    \"../../../node_modules/.pnpm/uuid@8.3.2/node_modules/uuid/dist/esm-browser/index.js\"() {\n      \"use strict\";\n      init_dirname();\n      init_buffer2();\n      init_process2();\n      init_v1();\n      init_v3();\n      init_v4();\n      init_v5();\n      init_nil();\n      init_version();\n      init_validate();\n      init_stringify();\n      init_parse();\n    }\n  });\n\n  // ../../../node_modules/.pnpm/jayson@4.2.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/jayson/lib/generateRequest.js\n  var require_generateRequest = __commonJS({\n    \"../../../node_modules/.pnpm/jayson@4.2.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/jayson/lib/generateRequest.js\"(exports3, module) {\n      \"use strict\";\n      init_dirname();\n      init_buffer2();\n      init_process2();\n      var uuid = (init_esm_browser(), __toCommonJS(esm_browser_exports)).v4;\n      var generateRequest = function(method, params, id, options) {\n        if (typeof method !== \"string\") {\n          throw new TypeError(method + \" must be a string\");\n        }\n        options = options || {};\n        const version2 = typeof options.version === \"number\" ? options.version : 2;\n        if (version2 !== 1 && version2 !== 2) {\n          throw new TypeError(version2 + \" must be 1 or 2\");\n        }\n        const request = {\n          method\n        };\n        if (version2 === 2) {\n          request.jsonrpc = \"2.0\";\n        }\n        if (params) {\n          if (typeof params !== \"object\" && !Array.isArray(params)) {\n            throw new TypeError(params + \" must be an object, array or omitted\");\n          }\n          request.params = params;\n        }\n        if (typeof id === \"undefined\") {\n          const generator = typeof options.generator === \"function\" ? options.generator : function() {\n            return uuid();\n          };\n          request.id = generator(request, options);\n        } else if (version2 === 2 && id === null) {\n          if (options.notificationIdNull) {\n            request.id = null;\n          }\n        } else {\n          request.id = id;\n        }\n        return request;\n      };\n      module.exports = generateRequest;\n    }\n  });\n\n  // ../../../node_modules/.pnpm/jayson@4.2.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/jayson/lib/client/browser/index.js\n  var require_browser = __commonJS({\n    \"../../../node_modules/.pnpm/jayson@4.2.0_bufferutil@4.0.9_utf-8-validate@5.0.10/node_modules/jayson/lib/client/browser/index.js\"(exports3, module) {\n      \"use strict\";\n      init_dirname();\n      init_buffer2();\n      init_process2();\n      var uuid = (init_esm_browser(), __toCommonJS(esm_browser_exports)).v4;\n      var generateRequest = require_generateRequest();\n      var ClientBrowser = function(callServer, options) {\n        if (!(this instanceof ClientBrowser)) {\n          return new ClientBrowser(callServer, options);\n        }\n        if (!options) {\n          options = {};\n        }\n        this.options = {\n          reviver: typeof options.reviver !== \"undefined\" ? options.reviver : null,\n          replacer: typeof options.replacer !== \"undefined\" ? options.replacer : null,\n          generator: typeof options.generator !== \"undefined\" ? options.generator : function() {\n            return uuid();\n          },\n          version: typeof options.version !== \"undefined\" ? options.version : 2,\n          notificationIdNull: typeof options.notificationIdNull === \"boolean\" ? options.notificationIdNull : false\n        };\n        this.callServer = callServer;\n      };\n      module.exports = ClientBrowser;\n      ClientBrowser.prototype.request = function(method, params, id, callback) {\n        const self = this;\n        let request = null;\n        const isBatch = Array.isArray(method) && typeof params === \"function\";\n        if (this.options.version === 1 && isBatch) {\n          throw new TypeError(\"JSON-RPC 1.0 does not support batching\");\n        }\n        const isRaw = !isBatch && method && typeof method === \"object\" && typeof params === \"function\";\n        if (isBatch || isRaw) {\n          callback = params;\n          request = method;\n        } else {\n          if (typeof id === \"function\") {\n            callback = id;\n            id = void 0;\n          }\n          const hasCallback = typeof callback === \"function\";\n          try {\n            request = generateRequest(method, params, id, {\n              generator: this.options.generator,\n              version: this.options.version,\n              notificationIdNull: this.options.notificationIdNull\n            });\n          } catch (err) {\n            if (hasCallback) {\n              return callback(err);\n            }\n            throw err;\n          }\n          if (!hasCallback) {\n            return request;\n          }\n        }\n        let message;\n        try {\n          message = JSON.stringify(request, this.options.replacer);\n        } catch (err) {\n          return callback(err);\n        }\n        this.callServer(message, function(err, response) {\n          self._parseResponse(err, response, callback);\n        });\n        return request;\n      };\n      ClientBrowser.prototype._parseResponse = function(err, responseText, callback) {\n        if (err) {\n          callback(err);\n          return;\n        }\n        if (!responseText) {\n          return callback();\n        }\n        let response;\n        try {\n          response = JSON.parse(responseText, this.options.reviver);\n        } catch (err2) {\n          return callback(err2);\n        }\n        if (callback.length === 3) {\n          if (Array.isArray(response)) {\n            const isError = function(res) {\n              return typeof res.error !== \"undefined\";\n            };\n            const isNotError = function(res) {\n              return !isError(res);\n            };\n            return callback(null, response.filter(isError), response.filter(isNotError));\n          } else {\n            return callback(null, response.error, response.result);\n          }\n        }\n        callback(null, response);\n      };\n    }\n  });\n\n  // ../../../node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.js\n  var require_eventemitter3 = __commonJS({\n    \"../../../node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.js\"(exports3, module) {\n      \"use strict\";\n      init_dirname();\n      init_buffer2();\n      init_process2();\n      var has = Object.prototype.hasOwnProperty;\n      var prefix = \"~\";\n      function Events() {\n      }\n      if (Object.create) {\n        Events.prototype = /* @__PURE__ */ Object.create(null);\n        if (!new Events().__proto__)\n          prefix = false;\n      }\n      function EE(fn, context, once) {\n        this.fn = fn;\n        this.context = context;\n        this.once = once || false;\n      }\n      function addListener(emitter, event, fn, context, once) {\n        if (typeof fn !== \"function\") {\n          throw new TypeError(\"The listener must be a function\");\n        }\n        var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;\n        if (!emitter._events[evt])\n          emitter._events[evt] = listener, emitter._eventsCount++;\n        else if (!emitter._events[evt].fn)\n          emitter._events[evt].push(listener);\n        else\n          emitter._events[evt] = [emitter._events[evt], listener];\n        return emitter;\n      }\n      function clearEvent(emitter, evt) {\n        if (--emitter._eventsCount === 0)\n          emitter._events = new Events();\n        else\n          delete emitter._events[evt];\n      }\n      function EventEmitter2() {\n        this._events = new Events();\n        this._eventsCount = 0;\n      }\n      EventEmitter2.prototype.eventNames = function eventNames() {\n        var names = [], events, name;\n        if (this._eventsCount === 0)\n          return names;\n        for (name in events = this._events) {\n          if (has.call(events, name))\n            names.push(prefix ? name.slice(1) : name);\n        }\n        if (Object.getOwnPropertySymbols) {\n          return names.concat(Object.getOwnPropertySymbols(events));\n        }\n        return names;\n      };\n      EventEmitter2.prototype.listeners = function listeners(event) {\n        var evt = prefix ? prefix + event : event, handlers = this._events[evt];\n        if (!handlers)\n          return [];\n        if (handlers.fn)\n          return [handlers.fn];\n        for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n          ee[i] = handlers[i].fn;\n        }\n        return ee;\n      };\n      EventEmitter2.prototype.listenerCount = function listenerCount(event) {\n        var evt = prefix ? prefix + event : event, listeners = this._events[evt];\n        if (!listeners)\n          return 0;\n        if (listeners.fn)\n          return 1;\n        return listeners.length;\n      };\n      EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n        var evt = prefix ? prefix + event : event;\n        if (!this._events[evt])\n          return false;\n        var listeners = this._events[evt], len = arguments.length, args, i;\n        if (listeners.fn) {\n          if (listeners.once)\n            this.removeListener(event, listeners.fn, void 0, true);\n          switch (len) {\n            case 1:\n              return listeners.fn.call(listeners.context), true;\n            case 2:\n              return listeners.fn.call(listeners.context, a1), true;\n            case 3:\n              return listeners.fn.call(listeners.context, a1, a2), true;\n            case 4:\n              return listeners.fn.call(listeners.context, a1, a2, a3), true;\n            case 5:\n              return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n            case 6:\n              return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n          }\n          for (i = 1, args = new Array(len - 1); i < len; i++) {\n            args[i - 1] = arguments[i];\n          }\n          listeners.fn.apply(listeners.context, args);\n        } else {\n          var length = listeners.length, j;\n          for (i = 0; i < length; i++) {\n            if (listeners[i].once)\n              this.removeListener(event, listeners[i].fn, void 0, true);\n            switch (len) {\n              case 1:\n                listeners[i].fn.call(listeners[i].context);\n                break;\n              case 2:\n                listeners[i].fn.call(listeners[i].context, a1);\n                break;\n              case 3:\n                listeners[i].fn.call(listeners[i].context, a1, a2);\n                break;\n              case 4:\n                listeners[i].fn.call(listeners[i].context, a1, a2, a3);\n                break;\n              default:\n                if (!args)\n                  for (j = 1, args = new Array(len - 1); j < len; j++) {\n                    args[j - 1] = arguments[j];\n                  }\n                listeners[i].fn.apply(listeners[i].context, args);\n            }\n          }\n        }\n        return true;\n      };\n      EventEmitter2.prototype.on = function on(event, fn, context) {\n        return addListener(this, event, fn, context, false);\n      };\n      EventEmitter2.prototype.once = function once(event, fn, context) {\n        return addListener(this, event, fn, context, true);\n      };\n      EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {\n        var evt = prefix ? prefix + event : event;\n        if (!this._events[evt])\n          return this;\n        if (!fn) {\n          clearEvent(this, evt);\n          return this;\n        }\n        var listeners = this._events[evt];\n        if (listeners.fn) {\n          if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {\n            clearEvent(this, evt);\n          }\n        } else {\n          for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n            if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {\n              events.push(listeners[i]);\n            }\n          }\n          if (events.length)\n            this._events[evt] = events.length === 1 ? events[0] : events;\n          else\n            clearEvent(this, evt);\n        }\n        return this;\n      };\n      EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {\n        var evt;\n        if (event) {\n          evt = prefix ? prefix + event : event;\n          if (this._events[evt])\n            clearEvent(this, evt);\n        } else {\n          this._events = new Events();\n          this._eventsCount = 0;\n        }\n        return this;\n      };\n      EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;\n      EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;\n      EventEmitter2.prefixed = prefix;\n      EventEmitter2.EventEmitter = EventEmitter2;\n      if (\"undefined\" !== typeof module) {\n        module.exports = EventEmitter2;\n      }\n    }\n  });\n\n  // src/lib/lit-actions/self-executing-actions/solana/generateEncryptedSolanaPrivateKey.ts\n  init_dirname();\n  init_buffer2();\n  init_process2();\n\n  // src/lib/lit-actions/litActionHandler.ts\n  init_dirname();\n  init_buffer2();\n  init_process2();\n\n  // src/lib/lit-actions/abortError.ts\n  init_dirname();\n  init_buffer2();\n  init_process2();\n  var AbortError = class extends Error {\n    name = \"AbortError\";\n  };\n\n  // src/lib/lit-actions/litActionHandler.ts\n  async function litActionHandler(actionFunc) {\n    try {\n      const litActionResult = await actionFunc();\n      const response = typeof litActionResult === \"string\" ? litActionResult : JSON.stringify(litActionResult);\n      Lit.Actions.setResponse({ response });\n    } catch (err) {\n      if (err instanceof AbortError) {\n        return;\n      }\n      Lit.Actions.setResponse({ response: `Error: ${err.message}` });\n    }\n  }\n\n  // src/lib/lit-actions/raw-action-functions/solana/generateEncryptedSolanaPrivateKey.ts\n  init_dirname();\n  init_buffer2();\n  init_process2();\n\n  // src/lib/lit-actions/internal/common/encryptKey.ts\n  init_dirname();\n  init_buffer2();\n  init_process2();\n\n  // src/lib/constants.ts\n  init_dirname();\n  init_buffer2();\n  init_process2();\n  var LIT_PREFIX = \"lit_\";\n\n  // src/lib/lit-actions/internal/common/encryptKey.ts\n  async function encryptPrivateKey({\n    accessControlConditions: accessControlConditions2,\n    privateKey,\n    publicKey: publicKey2\n  }) {\n    const { ciphertext, dataToEncryptHash } = await Lit.Actions.encrypt({\n      accessControlConditions: accessControlConditions2,\n      to_encrypt: new TextEncoder().encode(LIT_PREFIX + privateKey)\n    });\n    return {\n      ciphertext,\n      dataToEncryptHash,\n      publicKey: publicKey2\n    };\n  }\n\n  // src/lib/lit-actions/internal/solana/generatePrivateKey.ts\n  init_dirname();\n  init_buffer2();\n  init_process2();\n\n  // ../../../node_modules/.pnpm/@solana+web3.js@1.98.4_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10/node_modules/@solana/web3.js/lib/index.browser.esm.js\n  init_dirname();\n  init_buffer2();\n  init_process2();\n  init_buffer();\n\n  // ../../../node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/ed25519.js\n  init_dirname();\n  init_buffer2();\n  init_process2();\n\n  // ../../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/sha2.js\n  init_dirname();\n  init_buffer2();\n  init_process2();\n\n  // ../../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/_md.js\n  init_dirname();\n  init_buffer2();\n  init_process2();\n\n  // ../../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/utils.js\n  init_dirname();\n  init_buffer2();\n  init_process2();\n\n  // ../../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/crypto.js\n  init_dirname();\n  init_buffer2();\n  init_process2();\n  var crypto2 = typeof globalThis === \"object\" && \"crypto\" in globalThis ? globalThis.crypto : void 0;\n\n  // ../../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/utils.js\n  function isBytes(a) {\n    return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === \"Uint8Array\";\n  }\n  function anumber(n) {\n    if (!Number.isSafeInteger(n) || n < 0)\n      throw new Error(\"positive integer expected, got \" + n);\n  }\n  function abytes(b, ...lengths) {\n    if (!isBytes(b))\n      throw new Error(\"Uint8Array expected\");\n    if (lengths.length > 0 && !lengths.includes(b.length))\n      throw new Error(\"Uint8Array expected of length \" + lengths + \", got length=\" + b.length);\n  }\n  function ahash(h) {\n    if (typeof h !== \"function\" || typeof h.create !== \"function\")\n      throw new Error(\"Hash should be wrapped by utils.createHasher\");\n    anumber(h.outputLen);\n    anumber(h.blockLen);\n  }\n  function aexists(instance2, checkFinished = true) {\n    if (instance2.destroyed)\n      throw new Error(\"Hash instance has been destroyed\");\n    if (checkFinished && instance2.finished)\n      throw new Error(\"Hash#digest() has already been called\");\n  }\n  function aoutput(out, instance2) {\n    abytes(out);\n    const min = instance2.outputLen;\n    if (out.length < min) {\n      throw new Error(\"digestInto() expects output buffer of length at least \" + min);\n    }\n  }\n  function u32(arr) {\n    return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n  }\n  function clean(...arrays) {\n    for (let i = 0; i < arrays.length; i++) {\n      arrays[i].fill(0);\n    }\n  }\n  function createView(arr) {\n    return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n  }\n  function rotr(word, shift) {\n    return word << 32 - shift | word >>> shift;\n  }\n  var isLE = /* @__PURE__ */ (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();\n  function byteSwap(word) {\n    return word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;\n  }\n  function byteSwap32(arr) {\n    for (let i = 0; i < arr.length; i++) {\n      arr[i] = byteSwap(arr[i]);\n    }\n    return arr;\n  }\n  var swap32IfBE = isLE ? (u) => u : byteSwap32;\n  var hasHexBuiltin = /* @__PURE__ */ (() => (\n    // @ts-ignore\n    typeof Uint8Array.from([]).toHex === \"function\" && typeof Uint8Array.fromHex === \"function\"\n  ))();\n  var hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, \"0\"));\n  function bytesToHex(bytes) {\n    abytes(bytes);\n    if (hasHexBuiltin)\n      return bytes.toHex();\n    let hex = \"\";\n    for (let i = 0; i < bytes.length; i++) {\n      hex += hexes[bytes[i]];\n    }\n    return hex;\n  }\n  var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };\n  function asciiToBase16(ch) {\n    if (ch >= asciis._0 && ch <= asciis._9)\n      return ch - asciis._0;\n    if (ch >= asciis.A && ch <= asciis.F)\n      return ch - (asciis.A - 10);\n    if (ch >= asciis.a && ch <= asciis.f)\n      return ch - (asciis.a - 10);\n    return;\n  }\n  function hexToBytes(hex) {\n    if (typeof hex !== \"string\")\n      throw new Error(\"hex string expected, got \" + typeof hex);\n    if (hasHexBuiltin)\n      return Uint8Array.fromHex(hex);\n    const hl = hex.length;\n    const al = hl / 2;\n    if (hl % 2)\n      throw new Error(\"hex string expected, got unpadded hex of length \" + hl);\n    const array2 = new Uint8Array(al);\n    for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n      const n1 = asciiToBase16(hex.charCodeAt(hi));\n      const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n      if (n1 === void 0 || n2 === void 0) {\n        const char = hex[hi] + hex[hi + 1];\n        throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n      }\n      array2[ai] = n1 * 16 + n2;\n    }\n    return array2;\n  }\n  function utf8ToBytes(str) {\n    if (typeof str !== \"string\")\n      throw new Error(\"string expected\");\n    return new Uint8Array(new TextEncoder().encode(str));\n  }\n  function toBytes(data) {\n    if (typeof data === \"string\")\n      data = utf8ToBytes(data);\n    abytes(data);\n    return data;\n  }\n  function concatBytes(...arrays) {\n    let sum = 0;\n    for (let i = 0; i < arrays.length; i++) {\n      const a = arrays[i];\n      abytes(a);\n      sum += a.length;\n    }\n    const res = new Uint8Array(sum);\n    for (let i = 0, pad = 0; i < arrays.length; i++) {\n      const a = arrays[i];\n      res.set(a, pad);\n      pad += a.length;\n    }\n    return res;\n  }\n  var Hash = class {\n  };\n  function createHasher(hashCons) {\n    const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n    const tmp = hashCons();\n    hashC.outputLen = tmp.outputLen;\n    hashC.blockLen = tmp.blockLen;\n    hashC.create = () => hashCons();\n    return hashC;\n  }\n  function randomBytes(bytesLength = 32) {\n    if (crypto2 && typeof crypto2.getRandomValues === \"function\") {\n      return crypto2.getRandomValues(new Uint8Array(bytesLength));\n    }\n    if (crypto2 && typeof crypto2.randomBytes === \"function\") {\n      return Uint8Array.from(crypto2.randomBytes(bytesLength));\n    }\n    throw new Error(\"crypto.getRandomValues must be defined\");\n  }\n\n  // ../../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/_md.js\n  function setBigUint64(view, byteOffset, value, isLE2) {\n    if (typeof view.setBigUint64 === \"function\")\n      return view.setBigUint64(byteOffset, value, isLE2);\n    const _32n2 = BigInt(32);\n    const _u32_max = BigInt(4294967295);\n    const wh = Number(value >> _32n2 & _u32_max);\n    const wl = Number(value & _u32_max);\n    const h = isLE2 ? 4 : 0;\n    const l = isLE2 ? 0 : 4;\n    view.setUint32(byteOffset + h, wh, isLE2);\n    view.setUint32(byteOffset + l, wl, isLE2);\n  }\n  function Chi(a, b, c) {\n    return a & b ^ ~a & c;\n  }\n  function Maj(a, b, c) {\n    return a & b ^ a & c ^ b & c;\n  }\n  var HashMD = class extends Hash {\n    constructor(blockLen, outputLen, padOffset, isLE2) {\n      super();\n      this.finished = false;\n      this.length = 0;\n      this.pos = 0;\n      this.destroyed = false;\n      this.blockLen = blockLen;\n      this.outputLen = outputLen;\n      this.padOffset = padOffset;\n      this.isLE = isLE2;\n      this.buffer = new Uint8Array(blockLen);\n      this.view = createView(this.buffer);\n    }\n    update(data) {\n      aexists(this);\n      data = toBytes(data);\n      abytes(data);\n      const { view, buffer, blockLen } = this;\n      const len = data.length;\n      for (let pos = 0; pos < len; ) {\n        const take = Math.min(blockLen - this.pos, len - pos);\n        if (take === blockLen) {\n          const dataView = createView(data);\n          for (; blockLen <= len - pos; pos += blockLen)\n            this.process(dataView, pos);\n          continue;\n        }\n        buffer.set(data.subarray(pos, pos + take), this.pos);\n        this.pos += take;\n        pos += take;\n        if (this.pos === blockLen) {\n          this.process(view, 0);\n          this.pos = 0;\n        }\n      }\n      this.length += data.length;\n      this.roundClean();\n      return this;\n    }\n    digestInto(out) {\n      aexists(this);\n      aoutput(out, this);\n      this.finished = true;\n      const { buffer, view, blockLen, isLE: isLE2 } = this;\n      let { pos } = this;\n      buffer[pos++] = 128;\n      clean(this.buffer.subarray(pos));\n      if (this.padOffset > blockLen - pos) {\n        this.process(view, 0);\n        pos = 0;\n      }\n      for (let i = pos; i < blockLen; i++)\n        buffer[i] = 0;\n      setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);\n      this.process(view, 0);\n      const oview = createView(out);\n      const len = this.outputLen;\n      if (len % 4)\n        throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n      const outLen = len / 4;\n      const state = this.get();\n      if (outLen > state.length)\n        throw new Error(\"_sha2: outputLen bigger than state\");\n      for (let i = 0; i < outLen; i++)\n        oview.setUint32(4 * i, state[i], isLE2);\n    }\n    digest() {\n      const { buffer, outputLen } = this;\n      this.digestInto(buffer);\n      const res = buffer.slice(0, outputLen);\n      this.destroy();\n      return res;\n    }\n    _cloneInto(to) {\n      to || (to = new this.constructor());\n      to.set(...this.get());\n      const { blockLen, buffer, length, finished, destroyed, pos } = this;\n      to.destroyed = destroyed;\n      to.finished = finished;\n      to.length = length;\n      to.pos = pos;\n      if (length % blockLen)\n        to.buffer.set(buffer);\n      return to;\n    }\n    clone() {\n      return this._cloneInto();\n    }\n  };\n  var SHA256_IV = /* @__PURE__ */ Uint32Array.from([\n    1779033703,\n    3144134277,\n    1013904242,\n    2773480762,\n    1359893119,\n    2600822924,\n    528734635,\n    1541459225\n  ]);\n  var SHA512_IV = /* @__PURE__ */ Uint32Array.from([\n    1779033703,\n    4089235720,\n    3144134277,\n    2227873595,\n    1013904242,\n    4271175723,\n    2773480762,\n    1595750129,\n    1359893119,\n    2917565137,\n    2600822924,\n    725511199,\n    528734635,\n    4215389547,\n    1541459225,\n    327033209\n  ]);\n\n  // ../../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/_u64.js\n  init_dirname();\n  init_buffer2();\n  init_process2();\n  var U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\n  var _32n = /* @__PURE__ */ BigInt(32);\n  function fromBig(n, le = false) {\n    if (le)\n      return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };\n    return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n  }\n  function split(lst, le = false) {\n    const len = lst.length;\n    let Ah = new Uint32Array(len);\n    let Al = new Uint32Array(len);\n    for (let i = 0; i < len; i++) {\n      const { h, l } = fromBig(lst[i], le);\n      [Ah[i], Al[i]] = [h, l];\n    }\n    return [Ah, Al];\n  }\n  var shrSH = (h, _l, s) => h >>> s;\n  var shrSL = (h, l, s) => h << 32 - s | l >>> s;\n  var rotrSH = (h, l, s) => h >>> s | l << 32 - s;\n  var rotrSL = (h, l, s) => h << 32 - s | l >>> s;\n  var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;\n  var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;\n  var rotlSH = (h, l, s) => h << s | l >>> 32 - s;\n  var rotlSL = (h, l, s) => l << s | h >>> 32 - s;\n  var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;\n  var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;\n  function add(Ah, Al, Bh, Bl) {\n    const l = (Al >>> 0) + (Bl >>> 0);\n    return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };\n  }\n  var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\n  var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;\n  var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\n  var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;\n  var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\n  var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;\n\n  // ../../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/sha2.js\n  var SHA256_K = /* @__PURE__ */ Uint32Array.from([\n    1116352408,\n    1899447441,\n    3049323471,\n    3921009573,\n    961987163,\n    1508970993,\n    2453635748,\n    2870763221,\n    3624381080,\n    310598401,\n    607225278,\n    1426881987,\n    1925078388,\n    2162078206,\n    2614888103,\n    3248222580,\n    3835390401,\n    4022224774,\n    264347078,\n    604807628,\n    770255983,\n    1249150122,\n    1555081692,\n    1996064986,\n    2554220882,\n    2821834349,\n    2952996808,\n    3210313671,\n    3336571891,\n    3584528711,\n    113926993,\n    338241895,\n    666307205,\n    773529912,\n    1294757372,\n    1396182291,\n    1695183700,\n    1986661051,\n    2177026350,\n    2456956037,\n    2730485921,\n    2820302411,\n    3259730800,\n    3345764771,\n    3516065817,\n    3600352804,\n    4094571909,\n    275423344,\n    430227734,\n    506948616,\n    659060556,\n    883997877,\n    958139571,\n    1322822218,\n    1537002063,\n    1747873779,\n    1955562222,\n    2024104815,\n    2227730452,\n    2361852424,\n    2428436474,\n    2756734187,\n    3204031479,\n    3329325298\n  ]);\n  var SHA256_W = /* @__PURE__ */ new Uint32Array(64);\n  var SHA256 = class extends HashMD {\n    constructor(outputLen = 32) {\n      super(64, outputLen, 8, false);\n      this.A = SHA256_IV[0] | 0;\n      this.B = SHA256_IV[1] | 0;\n      this.C = SHA256_IV[2] | 0;\n      this.D = SHA256_IV[3] | 0;\n      this.E = SHA256_IV[4] | 0;\n      this.F = SHA256_IV[5] | 0;\n      this.G = SHA256_IV[6] | 0;\n      this.H = SHA256_IV[7] | 0;\n    }\n    get() {\n      const { A, B, C, D, E, F, G, H } = this;\n      return [A, B, C, D, E, F, G, H];\n    }\n    // prettier-ignore\n    set(A, B, C, D, E, F, G, H) {\n      this.A = A | 0;\n      this.B = B | 0;\n      this.C = C | 0;\n      this.D = D | 0;\n      this.E = E | 0;\n      this.F = F | 0;\n      this.G = G | 0;\n      this.H = H | 0;\n    }\n    process(view, offset2) {\n      for (let i = 0; i < 16; i++, offset2 += 4)\n        SHA256_W[i] = view.getUint32(offset2, false);\n      for (let i = 16; i < 64; i++) {\n        const W15 = SHA256_W[i - 15];\n        const W2 = SHA256_W[i - 2];\n        const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;\n        const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;\n        SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;\n      }\n      let { A, B, C, D, E, F, G, H } = this;\n      for (let i = 0; i < 64; i++) {\n        const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n        const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;\n        const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n        const T2 = sigma0 + Maj(A, B, C) | 0;\n        H = G;\n        G = F;\n        F = E;\n        E = D + T1 | 0;\n        D = C;\n        C = B;\n        B = A;\n        A = T1 + T2 | 0;\n      }\n      A = A + this.A | 0;\n      B = B + this.B | 0;\n      C = C + this.C | 0;\n      D = D + this.D | 0;\n      E = E + this.E | 0;\n      F = F + this.F | 0;\n      G = G + this.G | 0;\n      H = H + this.H | 0;\n      this.set(A, B, C, D, E, F, G, H);\n    }\n    roundClean() {\n      clean(SHA256_W);\n    }\n    destroy() {\n      this.set(0, 0, 0, 0, 0, 0, 0, 0);\n      clean(this.buffer);\n    }\n  };\n  var K512 = /* @__PURE__ */ (() => split([\n    \"0x428a2f98d728ae22\",\n    \"0x7137449123ef65cd\",\n    \"0xb5c0fbcfec4d3b2f\",\n    \"0xe9b5dba58189dbbc\",\n    \"0x3956c25bf348b538\",\n    \"0x59f111f1b605d019\",\n    \"0x923f82a4af194f9b\",\n    \"0xab1c5ed5da6d8118\",\n    \"0xd807aa98a3030242\",\n    \"0x12835b0145706fbe\",\n    \"0x243185be4ee4b28c\",\n    \"0x550c7dc3d5ffb4e2\",\n    \"0x72be5d74f27b896f\",\n    \"0x80deb1fe3b1696b1\",\n    \"0x9bdc06a725c71235\",\n    \"0xc19bf174cf692694\",\n    \"0xe49b69c19ef14ad2\",\n    \"0xefbe4786384f25e3\",\n    \"0x0fc19dc68b8cd5b5\",\n    \"0x240ca1cc77ac9c65\",\n    \"0x2de92c6f592b0275\",\n    \"0x4a7484aa6ea6e483\",\n    \"0x5cb0a9dcbd41fbd4\",\n    \"0x76f988da831153b5\",\n    \"0x983e5152ee66dfab\",\n    \"0xa831c66d2db43210\",\n    \"0xb00327c898fb213f\",\n    \"0xbf597fc7beef0ee4\",\n    \"0xc6e00bf33da88fc2\",\n    \"0xd5a79147930aa725\",\n    \"0x06ca6351e003826f\",\n    \"0x142929670a0e6e70\",\n    \"0x27b70a8546d22ffc\",\n    \"0x2e1b21385c26c926\",\n    \"0x4d2c6dfc5ac42aed\",\n    \"0x53380d139d95b3df\",\n    \"0x650a73548baf63de\",\n    \"0x766a0abb3c77b2a8\",\n    \"0x81c2c92e47edaee6\",\n    \"0x92722c851482353b\",\n    \"0xa2bfe8a14cf10364\",\n    \"0xa81a664bbc423001\",\n    \"0xc24b8b70d0f89791\",\n    \"0xc76c51a30654be30\",\n    \"0xd192e819d6ef5218\",\n    \"0xd69906245565a910\",\n    \"0xf40e35855771202a\",\n    \"0x106aa07032bbd1b8\",\n    \"0x19a4c116b8d2d0c8\",\n    \"0x1e376c085141ab53\",\n    \"0x2748774cdf8eeb99\",\n    \"0x34b0bcb5e19b48a8\",\n    \"0x391c0cb3c5c95a63\",\n    \"0x4ed8aa4ae3418acb\",\n    \"0x5b9cca4f7763e373\",\n    \"0x682e6ff3d6b2b8a3\",\n    \"0x748f82ee5defb2fc\",\n    \"0x78a5636f43172f60\",\n    \"0x84c87814a1f0ab72\",\n    \"0x8cc702081a6439ec\",\n    \"0x90befffa23631e28\",\n    \"0xa4506cebde82bde9\",\n    \"0xbef9a3f7b2c67915\",\n    \"0xc67178f2e372532b\",\n    \"0xca273eceea26619c\",\n    \"0xd186b8c721c0c207\",\n    \"0xeada7dd6cde0eb1e\",\n    \"0xf57d4f7fee6ed178\",\n    \"0x06f067aa72176fba\",\n    \"0x0a637dc5a2c898a6\",\n    \"0x113f9804bef90dae\",\n    \"0x1b710b35131c471b\",\n    \"0x28db77f523047d84\",\n    \"0x32caab7b40c72493\",\n    \"0x3c9ebe0a15c9bebc\",\n    \"0x431d67c49c100d4c\",\n    \"0x4cc5d4becb3e42b6\",\n    \"0x597f299cfc657e2a\",\n    \"0x5fcb6fab3ad6faec\",\n    \"0x6c44198c4a475817\"\n  ].map((n) => BigInt(n))))();\n  var SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\n  var SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n  var SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\n  var SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\n  var SHA512 = class extends HashMD {\n    constructor(outputLen = 64) {\n      super(128, outputLen, 16, false);\n      this.Ah = SHA512_IV[0] | 0;\n      this.Al = SHA512_IV[1] | 0;\n      this.Bh = SHA512_IV[2] | 0;\n      this.Bl = SHA512_IV[3] | 0;\n      this.Ch = SHA512_IV[4] | 0;\n      this.Cl = SHA512_IV[5] | 0;\n      this.Dh = SHA512_IV[6] | 0;\n      this.Dl = SHA512_IV[7] | 0;\n      this.Eh = SHA512_IV[8] | 0;\n      this.El = SHA512_IV[9] | 0;\n      this.Fh = SHA512_IV[10] | 0;\n      this.Fl = SHA512_IV[11] | 0;\n      this.Gh = SHA512_IV[12] | 0;\n      this.Gl = SHA512_IV[13] | 0;\n      this.Hh = SHA512_IV[14] | 0;\n      this.Hl = SHA512_IV[15] | 0;\n    }\n    // prettier-ignore\n    get() {\n      const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n      return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n    }\n    // prettier-ignore\n    set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {\n      this.Ah = Ah | 0;\n      this.Al = Al | 0;\n      this.Bh = Bh | 0;\n      this.Bl = Bl | 0;\n      this.Ch = Ch | 0;\n      this.Cl = Cl | 0;\n      this.Dh = Dh | 0;\n      this.Dl = Dl | 0;\n      this.Eh = Eh | 0;\n      this.El = El | 0;\n      this.Fh = Fh | 0;\n      this.Fl = Fl | 0;\n      this.Gh = Gh | 0;\n      this.Gl = Gl | 0;\n      this.Hh = Hh | 0;\n      this.Hl = Hl | 0;\n    }\n    process(view, offset2) {\n      for (let i = 0; i < 16; i++, offset2 += 4) {\n        SHA512_W_H[i] = view.getUint32(offset2);\n        SHA512_W_L[i] = view.getUint32(offset2 += 4);\n      }\n      for (let i = 16; i < 80; i++) {\n        const W15h = SHA512_W_H[i - 15] | 0;\n        const W15l = SHA512_W_L[i - 15] | 0;\n        const s0h = rotrSH(W15h, W15l, 1) ^ rotrSH(W15h, W15l, 8) ^ shrSH(W15h, W15l, 7);\n        const s0l = rotrSL(W15h, W15l, 1) ^ rotrSL(W15h, W15l, 8) ^ shrSL(W15h, W15l, 7);\n        const W2h = SHA512_W_H[i - 2] | 0;\n        const W2l = SHA512_W_L[i - 2] | 0;\n        const s1h = rotrSH(W2h, W2l, 19) ^ rotrBH(W2h, W2l, 61) ^ shrSH(W2h, W2l, 6);\n        const s1l = rotrSL(W2h, W2l, 19) ^ rotrBL(W2h, W2l, 61) ^ shrSL(W2h, W2l, 6);\n        const SUMl = add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n        const SUMh = add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n        SHA512_W_H[i] = SUMh | 0;\n        SHA512_W_L[i] = SUMl | 0;\n      }\n      let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n      for (let i = 0; i < 80; i++) {\n        const sigma1h = rotrSH(Eh, El, 14) ^ rotrSH(Eh, El, 18) ^ rotrBH(Eh, El, 41);\n        const sigma1l = rotrSL(Eh, El, 14) ^ rotrSL(Eh, El, 18) ^ rotrBL(Eh, El, 41);\n        const CHIh = Eh & Fh ^ ~Eh & Gh;\n        const CHIl = El & Fl ^ ~El & Gl;\n        const T1ll = add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n        const T1h = add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n        const T1l = T1ll | 0;\n        const sigma0h = rotrSH(Ah, Al, 28) ^ rotrBH(Ah, Al, 34) ^ rotrBH(Ah, Al, 39);\n        const sigma0l = rotrSL(Ah, Al, 28) ^ rotrBL(Ah, Al, 34) ^ rotrBL(Ah, Al, 39);\n        const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;\n        const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;\n        Hh = Gh | 0;\n        Hl = Gl | 0;\n        Gh = Fh | 0;\n        Gl = Fl | 0;\n        Fh = Eh | 0;\n        Fl = El | 0;\n        ({ h: Eh, l: El } = add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n        Dh = Ch | 0;\n        Dl = Cl | 0;\n        Ch = Bh | 0;\n        Cl = Bl | 0;\n        Bh = Ah | 0;\n        Bl = Al | 0;\n        const All = add3L(T1l, sigma0l, MAJl);\n        Ah = add3H(All, T1h, sigma0h, MAJh);\n        Al = All | 0;\n      }\n      ({ h: Ah, l: Al } = add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n      ({ h: Bh, l: Bl } = add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n      ({ h: Ch, l: Cl } = add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n      ({ h: Dh, l: Dl } = add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n      ({ h: Eh, l: El } = add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n      ({ h: Fh, l: Fl } = add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n      ({ h: Gh, l: Gl } = add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n      ({ h: Hh, l: Hl } = add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n      this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n    }\n    roundClean() {\n      clean(SHA512_W_H, SHA512_W_L);\n    }\n    destroy() {\n      clean(this.buffer);\n      this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n    }\n  };\n  var sha256 = /* @__PURE__ */ createHasher(() => new SHA256());\n  var sha512 = /* @__PURE__ */ createHasher(() => new SHA512());\n\n  // ../../../node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/curve.js\n  init_dirname();\n  init_buffer2();\n  init_process2();\n\n  // ../../../node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/utils.js\n  init_dirname();\n  init_buffer2();\n  init_process2();\n  var _0n = /* @__PURE__ */ BigInt(0);\n  var _1n = /* @__PURE__ */ BigInt(1);\n  function _abool2(value, title = \"\") {\n    if (typeof value !== \"boolean\") {\n      const prefix = title && `\"${title}\"`;\n      throw new Error(prefix + \"expected boolean, got type=\" + typeof value);\n    }\n    return value;\n  }\n  function _abytes2(value, length, title = \"\") {\n    const bytes = isBytes(value);\n    const len = value?.length;\n    const needsLen = length !== void 0;\n    if (!bytes || needsLen && len !== length) {\n      const prefix = title && `\"${title}\" `;\n      const ofLen = needsLen ? ` of length ${length}` : \"\";\n      const got = bytes ? `length=${len}` : `type=${typeof value}`;\n      throw new Error(prefix + \"expected Uint8Array\" + ofLen + \", got \" + got);\n    }\n    return value;\n  }\n  function numberToHexUnpadded(num) {\n    const hex = num.toString(16);\n    return hex.length & 1 ? \"0\" + hex : hex;\n  }\n  function hexToNumber(hex) {\n    if (typeof hex !== \"string\")\n      throw new Error(\"hex string expected, got \" + typeof hex);\n    return hex === \"\" ? _0n : BigInt(\"0x\" + hex);\n  }\n  function bytesToNumberBE(bytes) {\n    return hexToNumber(bytesToHex(bytes));\n  }\n  function bytesToNumberLE(bytes) {\n    abytes(bytes);\n    return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n  }\n  function numberToBytesBE(n, len) {\n    return hexToBytes(n.toString(16).padStart(len * 2, \"0\"));\n  }\n  function numberToBytesLE(n, len) {\n    return numberToBytesBE(n, len).reverse();\n  }\n  function ensureBytes(title, hex, expectedLength) {\n    let res;\n    if (typeof hex === \"string\") {\n      try {\n        res = hexToBytes(hex);\n      } catch (e) {\n        throw new Error(title + \" must be hex string or Uint8Array, cause: \" + e);\n      }\n    } else if (isBytes(hex)) {\n      res = Uint8Array.from(hex);\n    } else {\n      throw new Error(title + \" must be hex string or Uint8Array\");\n    }\n    const len = res.length;\n    if (typeof expectedLength === \"number\" && len !== expectedLength)\n      throw new Error(title + \" of length \" + expectedLength + \" expected, got \" + len);\n    return res;\n  }\n  function equalBytes(a, b) {\n    if (a.length !== b.length)\n      return false;\n    let diff = 0;\n    for (let i = 0; i < a.length; i++)\n      diff |= a[i] ^ b[i];\n    return diff === 0;\n  }\n  function copyBytes(bytes) {\n    return Uint8Array.from(bytes);\n  }\n  var isPosBig = (n) => typeof n === \"bigint\" && _0n <= n;\n  function inRange(n, min, max) {\n    return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n  }\n  function aInRange(title, n, min, max) {\n    if (!inRange(n, min, max))\n      throw new Error(\"expected valid \" + title + \": \" + min + \" <= n < \" + max + \", got \" + n);\n  }\n  function bitLen(n) {\n    let len;\n    for (len = 0; n > _0n; n >>= _1n, len += 1)\n      ;\n    return len;\n  }\n  var bitMask = (n) => (_1n << BigInt(n)) - _1n;\n  function createHmacDrbg(hashLen, qByteLen, hmacFn) {\n    if (typeof hashLen !== \"number\" || hashLen < 2)\n      throw new Error(\"hashLen must be a number\");\n    if (typeof qByteLen !== \"number\" || qByteLen < 2)\n      throw new Error(\"qByteLen must be a number\");\n    if (typeof hmacFn !== \"function\")\n      throw new Error(\"hmacFn must be a function\");\n    const u8n = (len) => new Uint8Array(len);\n    const u8of = (byte) => Uint8Array.of(byte);\n    let v = u8n(hashLen);\n    let k = u8n(hashLen);\n    let i = 0;\n    const reset = () => {\n      v.fill(1);\n      k.fill(0);\n      i = 0;\n    };\n    const h = (...b) => hmacFn(k, v, ...b);\n    const reseed = (seed = u8n(0)) => {\n      k = h(u8of(0), seed);\n      v = h();\n      if (seed.length === 0)\n        return;\n      k = h(u8of(1), seed);\n      v = h();\n    };\n    const gen2 = () => {\n      if (i++ >= 1e3)\n        throw new Error(\"drbg: tried 1000 values\");\n      let len = 0;\n      const out = [];\n      while (len < qByteLen) {\n        v = h();\n        const sl = v.slice();\n        out.push(sl);\n        len += v.length;\n      }\n      return concatBytes(...out);\n    };\n    const genUntil = (seed, pred) => {\n      reset();\n      reseed(seed);\n      let res = void 0;\n      while (!(res = pred(gen2())))\n        reseed();\n      reset();\n      return res;\n    };\n    return genUntil;\n  }\n  function _validateObject(object, fields, optFields = {}) {\n    if (!object || typeof object !== \"object\")\n      throw new Error(\"expected valid options object\");\n    function checkField(fieldName, expectedType, isOpt) {\n      const val = object[fieldName];\n      if (isOpt && val === void 0)\n        return;\n      const current = typeof val;\n      if (current !== expectedType || val === null)\n        throw new Error(`param \"${fieldName}\" is invalid: expected ${expectedType}, got ${current}`);\n    }\n    Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));\n    Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));\n  }\n  var notImplemented = () => {\n    throw new Error(\"not implemented\");\n  };\n  function memoized(fn) {\n    const map = /* @__PURE__ */ new WeakMap();\n    return (arg, ...args) => {\n      const val = map.get(arg);\n      if (val !== void 0)\n        return val;\n      const computed = fn(arg, ...args);\n      map.set(arg, computed);\n      return computed;\n    };\n  }\n\n  // ../../../node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/modular.js\n  init_dirname();\n  init_buffer2();\n  init_process2();\n  var _0n2 = BigInt(0);\n  var _1n2 = BigInt(1);\n  var _2n = /* @__PURE__ */ BigInt(2);\n  var _3n = /* @__PURE__ */ BigInt(3);\n  var _4n = /* @__PURE__ */ BigInt(4);\n  var _5n = /* @__PURE__ */ BigInt(5);\n  var _7n = /* @__PURE__ */ BigInt(7);\n  var _8n = /* @__PURE__ */ BigInt(8);\n  var _9n = /* @__PURE__ */ BigInt(9);\n  var _16n = /* @__PURE__ */ BigInt(16);\n  function mod(a, b) {\n    const result = a % b;\n    return result >= _0n2 ? result : b + result;\n  }\n  function pow2(x, power, modulo) {\n    let res = x;\n    while (power-- > _0n2) {\n      res *= res;\n      res %= modulo;\n    }\n    return res;\n  }\n  function invert(number2, modulo) {\n    if (number2 === _0n2)\n      throw new Error(\"invert: expected non-zero number\");\n    if (modulo <= _0n2)\n      throw new Error(\"invert: expected positive modulus, got \" + modulo);\n    let a = mod(number2, modulo);\n    let b = modulo;\n    let x = _0n2, y = _1n2, u = _1n2, v = _0n2;\n    while (a !== _0n2) {\n      const q = b / a;\n      const r = b % a;\n      const m = x - u * q;\n      const n = y - v * q;\n      b = a, a = r, x = u, y = v, u = m, v = n;\n    }\n    const gcd = b;\n    if (gcd !== _1n2)\n      throw new Error(\"invert: does not exist\");\n    return mod(x, modulo);\n  }\n  function assertIsSquare(Fp2, root, n) {\n    if (!Fp2.eql(Fp2.sqr(root), n))\n      throw new Error(\"Cannot find square root\");\n  }\n  function sqrt3mod4(Fp2, n) {\n    const p1div4 = (Fp2.ORDER + _1n2) / _4n;\n    const root = Fp2.pow(n, p1div4);\n    assertIsSquare(Fp2, root, n);\n    return root;\n  }\n  function sqrt5mod8(Fp2, n) {\n    const p5div8 = (Fp2.ORDER - _5n) / _8n;\n    const n2 = Fp2.mul(n, _2n);\n    const v = Fp2.pow(n2, p5div8);\n    const nv = Fp2.mul(n, v);\n    const i = Fp2.mul(Fp2.mul(nv, _2n), v);\n    const root = Fp2.mul(nv, Fp2.sub(i, Fp2.ONE));\n    assertIsSquare(Fp2, root, n);\n    return root;\n  }\n  function sqrt9mod16(P) {\n    const Fp_ = Field(P);\n    const tn = tonelliShanks(P);\n    const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));\n    const c2 = tn(Fp_, c1);\n    const c3 = tn(Fp_, Fp_.neg(c1));\n    const c4 = (P + _7n) / _16n;\n    return (Fp2, n) => {\n      let tv1 = Fp2.pow(n, c4);\n      let tv2 = Fp2.mul(tv1, c1);\n      const tv3 = Fp2.mul(tv1, c2);\n      const tv4 = Fp2.mul(tv1, c3);\n      const e1 = Fp2.eql(Fp2.sqr(tv2), n);\n      const e2 = Fp2.eql(Fp2.sqr(tv3), n);\n      tv1 = Fp2.cmov(tv1, tv2, e1);\n      tv2 = Fp2.cmov(tv4, tv3, e2);\n      const e3 = Fp2.eql(Fp2.sqr(tv2), n);\n      const root = Fp2.cmov(tv1, tv2, e3);\n      assertIsSquare(Fp2, root, n);\n      return root;\n    };\n  }\n  function tonelliShanks(P) {\n    if (P < _3n)\n      throw new Error(\"sqrt is not defined for small field\");\n    let Q = P - _1n2;\n    let S = 0;\n    while (Q % _2n === _0n2) {\n      Q /= _2n;\n      S++;\n    }\n    let Z = _2n;\n    const _Fp = Field(P);\n    while (FpLegendre(_Fp, Z) === 1) {\n      if (Z++ > 1e3)\n        throw new Error(\"Cannot find square root: probably non-prime P\");\n    }\n    if (S === 1)\n      return sqrt3mod4;\n    let cc = _Fp.pow(Z, Q);\n    const Q1div2 = (Q + _1n2) / _2n;\n    return function tonelliSlow(Fp2, n) {\n      if (Fp2.is0(n))\n        return n;\n      if (FpLegendre(Fp2, n) !== 1)\n        throw new Error(\"Cannot find square root\");\n      let M = S;\n      let c = Fp2.mul(Fp2.ONE, cc);\n      let t = Fp2.pow(n, Q);\n      let R = Fp2.pow(n, Q1div2);\n      while (!Fp2.eql(t, Fp2.ONE)) {\n        if (Fp2.is0(t))\n          return Fp2.ZERO;\n        let i = 1;\n        let t_tmp = Fp2.sqr(t);\n        while (!Fp2.eql(t_tmp, Fp2.ONE)) {\n          i++;\n          t_tmp = Fp2.sqr(t_tmp);\n          if (i === M)\n            throw new Error(\"Cannot find square root\");\n        }\n        const exponent = _1n2 << BigInt(M - i - 1);\n        const b = Fp2.pow(c, exponent);\n        M = i;\n        c = Fp2.sqr(b);\n        t = Fp2.mul(t, c);\n        R = Fp2.mul(R, b);\n      }\n      return R;\n    };\n  }\n  function FpSqrt(P) {\n    if (P % _4n === _3n)\n      return sqrt3mod4;\n    if (P % _8n === _5n)\n      return sqrt5mod8;\n    if (P % _16n === _9n)\n      return sqrt9mod16(P);\n    return tonelliShanks(P);\n  }\n  var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n2) === _1n2;\n  var FIELD_FIELDS = [\n    \"create\",\n    \"isValid\",\n    \"is0\",\n    \"neg\",\n    \"inv\",\n    \"sqrt\",\n    \"sqr\",\n    \"eql\",\n    \"add\",\n    \"sub\",\n    \"mul\",\n    \"pow\",\n    \"div\",\n    \"addN\",\n    \"subN\",\n    \"mulN\",\n    \"sqrN\"\n  ];\n  function validateField(field) {\n    const initial = {\n      ORDER: \"bigint\",\n      MASK: \"bigint\",\n      BYTES: \"number\",\n      BITS: \"number\"\n    };\n    const opts = FIELD_FIELDS.reduce((map, val) => {\n      map[val] = \"function\";\n      return map;\n    }, initial);\n    _validateObject(field, opts);\n    return field;\n  }\n  function FpPow(Fp2, num, power) {\n    if (power < _0n2)\n      throw new Error(\"invalid exponent, negatives unsupported\");\n    if (power === _0n2)\n      return Fp2.ONE;\n    if (power === _1n2)\n      return num;\n    let p = Fp2.ONE;\n    let d = num;\n    while (power > _0n2) {\n      if (power & _1n2)\n        p = Fp2.mul(p, d);\n      d = Fp2.sqr(d);\n      power >>= _1n2;\n    }\n    return p;\n  }\n  function FpInvertBatch(Fp2, nums, passZero = false) {\n    const inverted = new Array(nums.length).fill(passZero ? Fp2.ZERO : void 0);\n    const multipliedAcc = nums.reduce((acc, num, i) => {\n      if (Fp2.is0(num))\n        return acc;\n      inverted[i] = acc;\n      return Fp2.mul(acc, num);\n    }, Fp2.ONE);\n    const invertedAcc = Fp2.inv(multipliedAcc);\n    nums.reduceRight((acc, num, i) => {\n      if (Fp2.is0(num))\n        return acc;\n      inverted[i] = Fp2.mul(acc, inverted[i]);\n      return Fp2.mul(acc, num);\n    }, invertedAcc);\n    return inverted;\n  }\n  function FpLegendre(Fp2, n) {\n    const p1mod2 = (Fp2.ORDER - _1n2) / _2n;\n    const powered = Fp2.pow(n, p1mod2);\n    const yes = Fp2.eql(powered, Fp2.ONE);\n    const zero = Fp2.eql(powered, Fp2.ZERO);\n    const no = Fp2.eql(powered, Fp2.neg(Fp2.ONE));\n    if (!yes && !zero && !no)\n      throw new Error(\"invalid Legendre symbol result\");\n    return yes ? 1 : zero ? 0 : -1;\n  }\n  function nLength(n, nBitLength) {\n    if (nBitLength !== void 0)\n      anumber(nBitLength);\n    const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;\n    const nByteLength = Math.ceil(_nBitLength / 8);\n    return { nBitLength: _nBitLength, nByteLength };\n  }\n  function Field(ORDER, bitLenOrOpts, isLE2 = false, opts = {}) {\n    if (ORDER <= _0n2)\n      throw new Error(\"invalid field: expected ORDER > 0, got \" + ORDER);\n    let _nbitLength = void 0;\n    let _sqrt = void 0;\n    let modFromBytes = false;\n    let allowedLengths = void 0;\n    if (typeof bitLenOrOpts === \"object\" && bitLenOrOpts != null) {\n      if (opts.sqrt || isLE2)\n        throw new Error(\"cannot specify opts in two arguments\");\n      const _opts = bitLenOrOpts;\n      if (_opts.BITS)\n        _nbitLength = _opts.BITS;\n      if (_opts.sqrt)\n        _sqrt = _opts.sqrt;\n      if (typeof _opts.isLE === \"boolean\")\n        isLE2 = _opts.isLE;\n      if (typeof _opts.modFromBytes === \"boolean\")\n        modFromBytes = _opts.modFromBytes;\n      allowedLengths = _opts.allowedLengths;\n    } else {\n      if (typeof bitLenOrOpts === \"number\")\n        _nbitLength = bitLenOrOpts;\n      if (opts.sqrt)\n        _sqrt = opts.sqrt;\n    }\n    const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);\n    if (BYTES > 2048)\n      throw new Error(\"invalid field: expected ORDER of <= 2048 bytes\");\n    let sqrtP;\n    const f2 = Object.freeze({\n      ORDER,\n      isLE: isLE2,\n      BITS,\n      BYTES,\n      MASK: bitMask(BITS),\n      ZERO: _0n2,\n      ONE: _1n2,\n      allowedLengths,\n      create: (num) => mod(num, ORDER),\n      isValid: (num) => {\n        if (typeof num !== \"bigint\")\n          throw new Error(\"invalid field element: expected bigint, got \" + typeof num);\n        return _0n2 <= num && num < ORDER;\n      },\n      is0: (num) => num === _0n2,\n      // is valid and invertible\n      isValidNot0: (num) => !f2.is0(num) && f2.isValid(num),\n      isOdd: (num) => (num & _1n2) === _1n2,\n      neg: (num) => mod(-num, ORDER),\n      eql: (lhs, rhs) => lhs === rhs,\n      sqr: (num) => mod(num * num, ORDER),\n      add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n      sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n      mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n      pow: (num, power) => FpPow(f2, num, power),\n      div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n      // Same as above, but doesn't normalize\n      sqrN: (num) => num * num,\n      addN: (lhs, rhs) => lhs + rhs,\n      subN: (lhs, rhs) => lhs - rhs,\n      mulN: (lhs, rhs) => lhs * rhs,\n      inv: (num) => invert(num, ORDER),\n      sqrt: _sqrt || ((n) => {\n        if (!sqrtP)\n          sqrtP = FpSqrt(ORDER);\n        return sqrtP(f2, n);\n      }),\n      toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),\n      fromBytes: (bytes, skipValidation = true) => {\n        if (allowedLengths) {\n          if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {\n            throw new Error(\"Field.fromBytes: expected \" + allowedLengths + \" bytes, got \" + bytes.length);\n          }\n          const padded = new Uint8Array(BYTES);\n          padded.set(bytes, isLE2 ? 0 : padded.length - bytes.length);\n          bytes = padded;\n        }\n        if (bytes.length !== BYTES)\n          throw new Error(\"Field.fromBytes: expected \" + BYTES + \" bytes, got \" + bytes.length);\n        let scalar = isLE2 ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n        if (modFromBytes)\n          scalar = mod(scalar, ORDER);\n        if (!skipValidation) {\n          if (!f2.isValid(scalar))\n            throw new Error(\"invalid field element: outside of range 0..ORDER\");\n        }\n        return scalar;\n      },\n      // TODO: we don't need it here, move out to separate fn\n      invertBatch: (lst) => FpInvertBatch(f2, lst),\n      // We can't move this out because Fp6, Fp12 implement it\n      // and it's unclear what to return in there.\n      cmov: (a, b, c) => c ? b : a\n    });\n    return Object.freeze(f2);\n  }\n  function getFieldBytesLength(fieldOrder) {\n    if (typeof fieldOrder !== \"bigint\")\n      throw new Error(\"field order must be bigint\");\n    const bitLength = fieldOrder.toString(2).length;\n    return Math.ceil(bitLength / 8);\n  }\n  function getMinHashLength(fieldOrder) {\n    const length = getFieldBytesLength(fieldOrder);\n    return length + Math.ceil(length / 2);\n  }\n  function mapHashToField(key, fieldOrder, isLE2 = false) {\n    const len = key.length;\n    const fieldLen = getFieldBytesLength(fieldOrder);\n    const minLen = getMinHashLength(fieldOrder);\n    if (len < 16 || len < minLen || len > 1024)\n      throw new Error(\"expected \" + minLen + \"-1024 bytes of input, got \" + len);\n    const num = isLE2 ? bytesToNumberLE(key) : bytesToNumberBE(key);\n    const reduced = mod(num, fieldOrder - _1n2) + _1n2;\n    return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n  }\n\n  // ../../../node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/curve.js\n  var _0n3 = BigInt(0);\n  var _1n3 = BigInt(1);\n  function negateCt(condition, item) {\n    const neg = item.negate();\n    return condition ? neg : item;\n  }\n  function normalizeZ(c, points) {\n    const invertedZs = FpInvertBatch(c.Fp, points.map((p) => p.Z));\n    return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));\n  }\n  function validateW(W, bits) {\n    if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n      throw new Error(\"invalid window size, expected [1..\" + bits + \"], got W=\" + W);\n  }\n  function calcWOpts(W, scalarBits) {\n    validateW(W, scalarBits);\n    const windows = Math.ceil(scalarBits / W) + 1;\n    const windowSize = 2 ** (W - 1);\n    const maxNumber = 2 ** W;\n    const mask2 = bitMask(W);\n    const shiftBy = BigInt(W);\n    return { windows, windowSize, mask: mask2, maxNumber, shiftBy };\n  }\n  function calcOffsets(n, window2, wOpts) {\n    const { windowSize, mask: mask2, maxNumber, shiftBy } = wOpts;\n    let wbits = Number(n & mask2);\n    let nextN = n >> shiftBy;\n    if (wbits > windowSize) {\n      wbits -= maxNumber;\n      nextN += _1n3;\n    }\n    const offsetStart = window2 * windowSize;\n    const offset2 = offsetStart + Math.abs(wbits) - 1;\n    const isZero = wbits === 0;\n    const isNeg = wbits < 0;\n    const isNegF = window2 % 2 !== 0;\n    const offsetF = offsetStart;\n    return { nextN, offset: offset2, isZero, isNeg, isNegF, offsetF };\n  }\n  function validateMSMPoints(points, c) {\n    if (!Array.isArray(points))\n      throw new Error(\"array expected\");\n    points.forEach((p, i) => {\n      if (!(p instanceof c))\n        throw new Error(\"invalid point at index \" + i);\n    });\n  }\n  function validateMSMScalars(scalars, field) {\n    if (!Array.isArray(scalars))\n      throw new Error(\"array of scalars expected\");\n    scalars.forEach((s, i) => {\n      if (!field.isValid(s))\n        throw new Error(\"invalid scalar at index \" + i);\n    });\n  }\n  var pointPrecomputes = /* @__PURE__ */ new WeakMap();\n  var pointWindowSizes = /* @__PURE__ */ new WeakMap();\n  function getW(P) {\n    return pointWindowSizes.get(P) || 1;\n  }\n  function assert0(n) {\n    if (n !== _0n3)\n      throw new Error(\"invalid wNAF\");\n  }\n  var wNAF = class {\n    // Parametrized with a given Point class (not individual point)\n    constructor(Point, bits) {\n      this.BASE = Point.BASE;\n      this.ZERO = Point.ZERO;\n      this.Fn = Point.Fn;\n      this.bits = bits;\n    }\n    // non-const time multiplication ladder\n    _unsafeLadder(elm, n, p = this.ZERO) {\n      let d = elm;\n      while (n > _0n3) {\n        if (n & _1n3)\n          p = p.add(d);\n        d = d.double();\n        n >>= _1n3;\n      }\n      return p;\n    }\n    /**\n     * Creates a wNAF precomputation window. Used for caching.\n     * Default window size is set by `utils.precompute()` and is equal to 8.\n     * Number of precomputed points depends on the curve size:\n     * 2^(1) * (Math.ceil( / ) + 1), where:\n     * -  is the window size\n     * -  is the bitlength of the curve order.\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n     * @param point Point instance\n     * @param W window size\n     * @returns precomputed point tables flattened to a single array\n     */\n    precomputeWindow(point, W) {\n      const { windows, windowSize } = calcWOpts(W, this.bits);\n      const points = [];\n      let p = point;\n      let base = p;\n      for (let window2 = 0; window2 < windows; window2++) {\n        base = p;\n        points.push(base);\n        for (let i = 1; i < windowSize; i++) {\n          base = base.add(p);\n          points.push(base);\n        }\n        p = base.double();\n      }\n      return points;\n    }\n    /**\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n     * More compact implementation:\n     * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\n     * @returns real and fake (for const-time) points\n     */\n    wNAF(W, precomputes, n) {\n      if (!this.Fn.isValid(n))\n        throw new Error(\"invalid scalar\");\n      let p = this.ZERO;\n      let f2 = this.BASE;\n      const wo = calcWOpts(W, this.bits);\n      for (let window2 = 0; window2 < wo.windows; window2++) {\n        const { nextN, offset: offset2, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window2, wo);\n        n = nextN;\n        if (isZero) {\n          f2 = f2.add(negateCt(isNegF, precomputes[offsetF]));\n        } else {\n          p = p.add(negateCt(isNeg, precomputes[offset2]));\n        }\n      }\n      assert0(n);\n      return { p, f: f2 };\n    }\n    /**\n     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param acc accumulator point to add result of multiplication\n     * @returns point\n     */\n    wNAFUnsafe(W, precomputes, n, acc = this.ZERO) {\n      const wo = calcWOpts(W, this.bits);\n      for (let window2 = 0; window2 < wo.windows; window2++) {\n        if (n === _0n3)\n          break;\n        const { nextN, offset: offset2, isZero, isNeg } = calcOffsets(n, window2, wo);\n        n = nextN;\n        if (isZero) {\n          continue;\n        } else {\n          const item = precomputes[offset2];\n          acc = acc.add(isNeg ? item.negate() : item);\n        }\n      }\n      assert0(n);\n      return acc;\n    }\n    getPrecomputes(W, point, transform) {\n      let comp = pointPrecomputes.get(point);\n      if (!comp) {\n        comp = this.precomputeWindow(point, W);\n        if (W !== 1) {\n          if (typeof transform === \"function\")\n            comp = transform(comp);\n          pointPrecomputes.set(point, comp);\n        }\n      }\n      return comp;\n    }\n    cached(point, scalar, transform) {\n      const W = getW(point);\n      return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);\n    }\n    unsafe(point, scalar, transform, prev) {\n      const W = getW(point);\n      if (W === 1)\n        return this._unsafeLadder(point, scalar, prev);\n      return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);\n    }\n    // We calculate precomputes for elliptic curve point multiplication\n    // using windowed method. This specifies window size and\n    // stores precomputed values. Usually only base point would be precomputed.\n    createCache(P, W) {\n      validateW(W, this.bits);\n      pointWindowSizes.set(P, W);\n      pointPrecomputes.delete(P);\n    }\n    hasCache(elm) {\n      return getW(elm) !== 1;\n    }\n  };\n  function mulEndoUnsafe(Point, point, k1, k2) {\n    let acc = point;\n    let p1 = Point.ZERO;\n    let p2 = Point.ZERO;\n    while (k1 > _0n3 || k2 > _0n3) {\n      if (k1 & _1n3)\n        p1 = p1.add(acc);\n      if (k2 & _1n3)\n        p2 = p2.add(acc);\n      acc = acc.double();\n      k1 >>= _1n3;\n      k2 >>= _1n3;\n    }\n    return { p1, p2 };\n  }\n  function pippenger(c, fieldN, points, scalars) {\n    validateMSMPoints(points, c);\n    validateMSMScalars(scalars, fieldN);\n    const plength = points.length;\n    const slength = scalars.length;\n    if (plength !== slength)\n      throw new Error(\"arrays of points and scalars must have equal length\");\n    const zero = c.ZERO;\n    const wbits = bitLen(BigInt(plength));\n    let windowSize = 1;\n    if (wbits > 12)\n      windowSize = wbits - 3;\n    else if (wbits > 4)\n      windowSize = wbits - 2;\n    else if (wbits > 0)\n      windowSize = 2;\n    const MASK = bitMask(windowSize);\n    const buckets = new Array(Number(MASK) + 1).fill(zero);\n    const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n    let sum = zero;\n    for (let i = lastBits; i >= 0; i -= windowSize) {\n      buckets.fill(zero);\n      for (let j = 0; j < slength; j++) {\n        const scalar = scalars[j];\n        const wbits2 = Number(scalar >> BigInt(i) & MASK);\n        buckets[wbits2] = buckets[wbits2].add(points[j]);\n      }\n      let resI = zero;\n      for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n        sumI = sumI.add(buckets[j]);\n        resI = resI.add(sumI);\n      }\n      sum = sum.add(resI);\n      if (i !== 0)\n        for (let j = 0; j < windowSize; j++)\n          sum = sum.double();\n    }\n    return sum;\n  }\n  function createField(order, field, isLE2) {\n    if (field) {\n      if (field.ORDER !== order)\n        throw new Error(\"Field.ORDER must match order: Fp == p, Fn == n\");\n      validateField(field);\n      return field;\n    } else {\n      return Field(order, { isLE: isLE2 });\n    }\n  }\n  function _createCurveFields(type2, CURVE, curveOpts = {}, FpFnLE) {\n    if (FpFnLE === void 0)\n      FpFnLE = type2 === \"edwards\";\n    if (!CURVE || typeof CURVE !== \"object\")\n      throw new Error(`expected valid ${type2} CURVE object`);\n    for (const p of [\"p\", \"n\", \"h\"]) {\n      const val = CURVE[p];\n      if (!(typeof val === \"bigint\" && val > _0n3))\n        throw new Error(`CURVE.${p} must be positive bigint`);\n    }\n    const Fp2 = createField(CURVE.p, curveOpts.Fp, FpFnLE);\n    const Fn2 = createField(CURVE.n, curveOpts.Fn, FpFnLE);\n    const _b = type2 === \"weierstrass\" ? \"b\" : \"d\";\n    const params = [\"Gx\", \"Gy\", \"a\", _b];\n    for (const p of params) {\n      if (!Fp2.isValid(CURVE[p]))\n        throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);\n    }\n    CURVE = Object.freeze(Object.assign({}, CURVE));\n    return { CURVE, Fp: Fp2, Fn: Fn2 };\n  }\n\n  // ../../../node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/edwards.js\n  init_dirname();\n  init_buffer2();\n  init_process2();\n  var _0n4 = BigInt(0);\n  var _1n4 = BigInt(1);\n  var _2n2 = BigInt(2);\n  var _8n2 = BigInt(8);\n  function isEdValidXY(Fp2, CURVE, x, y) {\n    const x2 = Fp2.sqr(x);\n    const y2 = Fp2.sqr(y);\n    const left = Fp2.add(Fp2.mul(CURVE.a, x2), y2);\n    const right = Fp2.add(Fp2.ONE, Fp2.mul(CURVE.d, Fp2.mul(x2, y2)));\n    return Fp2.eql(left, right);\n  }\n  function edwards(params, extraOpts = {}) {\n    const validated = _createCurveFields(\"edwards\", params, extraOpts, extraOpts.FpFnLE);\n    const { Fp: Fp2, Fn: Fn2 } = validated;\n    let CURVE = validated.CURVE;\n    const { h: cofactor } = CURVE;\n    _validateObject(extraOpts, {}, { uvRatio: \"function\" });\n    const MASK = _2n2 << BigInt(Fn2.BYTES * 8) - _1n4;\n    const modP = (n) => Fp2.create(n);\n    const uvRatio2 = extraOpts.uvRatio || ((u, v) => {\n      try {\n        return { isValid: true, value: Fp2.sqrt(Fp2.div(u, v)) };\n      } catch (e) {\n        return { isValid: false, value: _0n4 };\n      }\n    });\n    if (!isEdValidXY(Fp2, CURVE, CURVE.Gx, CURVE.Gy))\n      throw new Error(\"bad curve params: generator point\");\n    function acoord(title, n, banZero = false) {\n      const min = banZero ? _1n4 : _0n4;\n      aInRange(\"coordinate \" + title, n, min, MASK);\n      return n;\n    }\n    function aextpoint(other) {\n      if (!(other instanceof Point))\n        throw new Error(\"ExtendedPoint expected\");\n    }\n    const toAffineMemo = memoized((p, iz) => {\n      const { X, Y, Z } = p;\n      const is0 = p.is0();\n      if (iz == null)\n        iz = is0 ? _8n2 : Fp2.inv(Z);\n      const x = modP(X * iz);\n      const y = modP(Y * iz);\n      const zz = Fp2.mul(Z, iz);\n      if (is0)\n        return { x: _0n4, y: _1n4 };\n      if (zz !== _1n4)\n        throw new Error(\"invZ was invalid\");\n      return { x, y };\n    });\n    const assertValidMemo = memoized((p) => {\n      const { a, d } = CURVE;\n      if (p.is0())\n        throw new Error(\"bad point: ZERO\");\n      const { X, Y, Z, T } = p;\n      const X2 = modP(X * X);\n      const Y2 = modP(Y * Y);\n      const Z2 = modP(Z * Z);\n      const Z4 = modP(Z2 * Z2);\n      const aX2 = modP(X2 * a);\n      const left = modP(Z2 * modP(aX2 + Y2));\n      const right = modP(Z4 + modP(d * modP(X2 * Y2)));\n      if (left !== right)\n        throw new Error(\"bad point: equation left != right (1)\");\n      const XY = modP(X * Y);\n      const ZT = modP(Z * T);\n      if (XY !== ZT)\n        throw new Error(\"bad point: equation left != right (2)\");\n      return true;\n    });\n    class Point {\n      constructor(X, Y, Z, T) {\n        this.X = acoord(\"x\", X);\n        this.Y = acoord(\"y\", Y);\n        this.Z = acoord(\"z\", Z, true);\n        this.T = acoord(\"t\", T);\n        Object.freeze(this);\n      }\n      static CURVE() {\n        return CURVE;\n      }\n      static fromAffine(p) {\n        if (p instanceof Point)\n          throw new Error(\"extended point not allowed\");\n        const { x, y } = p || {};\n        acoord(\"x\", x);\n        acoord(\"y\", y);\n        return new Point(x, y, _1n4, modP(x * y));\n      }\n      // Uses algo from RFC8032 5.1.3.\n      static fromBytes(bytes, zip215 = false) {\n        const len = Fp2.BYTES;\n        const { a, d } = CURVE;\n        bytes = copyBytes(_abytes2(bytes, len, \"point\"));\n        _abool2(zip215, \"zip215\");\n        const normed = copyBytes(bytes);\n        const lastByte = bytes[len - 1];\n        normed[len - 1] = lastByte & ~128;\n        const y = bytesToNumberLE(normed);\n        const max = zip215 ? MASK : Fp2.ORDER;\n        aInRange(\"point.y\", y, _0n4, max);\n        const y2 = modP(y * y);\n        const u = modP(y2 - _1n4);\n        const v = modP(d * y2 - a);\n        let { isValid, value: x } = uvRatio2(u, v);\n        if (!isValid)\n          throw new Error(\"bad point: invalid y coordinate\");\n        const isXOdd = (x & _1n4) === _1n4;\n        const isLastByteOdd = (lastByte & 128) !== 0;\n        if (!zip215 && x === _0n4 && isLastByteOdd)\n          throw new Error(\"bad point: x=0 and x_0=1\");\n        if (isLastByteOdd !== isXOdd)\n          x = modP(-x);\n        return Point.fromAffine({ x, y });\n      }\n      static fromHex(bytes, zip215 = false) {\n        return Point.fromBytes(ensureBytes(\"point\", bytes), zip215);\n      }\n      get x() {\n        return this.toAffine().x;\n      }\n      get y() {\n        return this.toAffine().y;\n      }\n      precompute(windowSize = 8, isLazy = true) {\n        wnaf.createCache(this, windowSize);\n        if (!isLazy)\n          this.multiply(_2n2);\n        return this;\n      }\n      // Useful in fromAffine() - not for fromBytes(), which always created valid points.\n      assertValidity() {\n        assertValidMemo(this);\n      }\n      // Compare one point to another.\n      equals(other) {\n        aextpoint(other);\n        const { X: X1, Y: Y1, Z: Z1 } = this;\n        const { X: X2, Y: Y2, Z: Z2 } = other;\n        const X1Z2 = modP(X1 * Z2);\n        const X2Z1 = modP(X2 * Z1);\n        const Y1Z2 = modP(Y1 * Z2);\n        const Y2Z1 = modP(Y2 * Z1);\n        return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n      }\n      is0() {\n        return this.equals(Point.ZERO);\n      }\n      negate() {\n        return new Point(modP(-this.X), this.Y, this.Z, modP(-this.T));\n      }\n      // Fast algo for doubling Extended Point.\n      // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n      // Cost: 4M + 4S + 1*a + 6add + 1*2.\n      double() {\n        const { a } = CURVE;\n        const { X: X1, Y: Y1, Z: Z1 } = this;\n        const A = modP(X1 * X1);\n        const B = modP(Y1 * Y1);\n        const C = modP(_2n2 * modP(Z1 * Z1));\n        const D = modP(a * A);\n        const x1y1 = X1 + Y1;\n        const E = modP(modP(x1y1 * x1y1) - A - B);\n        const G = D + B;\n        const F = G - C;\n        const H = D - B;\n        const X3 = modP(E * F);\n        const Y3 = modP(G * H);\n        const T3 = modP(E * H);\n        const Z3 = modP(F * G);\n        return new Point(X3, Y3, Z3, T3);\n      }\n      // Fast algo for adding 2 Extended Points.\n      // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n      // Cost: 9M + 1*a + 1*d + 7add.\n      add(other) {\n        aextpoint(other);\n        const { a, d } = CURVE;\n        const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;\n        const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;\n        const A = modP(X1 * X2);\n        const B = modP(Y1 * Y2);\n        const C = modP(T1 * d * T2);\n        const D = modP(Z1 * Z2);\n        const E = modP((X1 + Y1) * (X2 + Y2) - A - B);\n        const F = D - C;\n        const G = D + C;\n        const H = modP(B - a * A);\n        const X3 = modP(E * F);\n        const Y3 = modP(G * H);\n        const T3 = modP(E * H);\n        const Z3 = modP(F * G);\n        return new Point(X3, Y3, Z3, T3);\n      }\n      subtract(other) {\n        return this.add(other.negate());\n      }\n      // Constant-time multiplication.\n      multiply(scalar) {\n        if (!Fn2.isValidNot0(scalar))\n          throw new Error(\"invalid scalar: expected 1 <= sc < curve.n\");\n        const { p, f: f2 } = wnaf.cached(this, scalar, (p2) => normalizeZ(Point, p2));\n        return normalizeZ(Point, [p, f2])[0];\n      }\n      // Non-constant-time multiplication. Uses double-and-add algorithm.\n      // It's faster, but should only be used when you don't care about\n      // an exposed private key e.g. sig verification.\n      // Does NOT allow scalars higher than CURVE.n.\n      // Accepts optional accumulator to merge with multiply (important for sparse scalars)\n      multiplyUnsafe(scalar, acc = Point.ZERO) {\n        if (!Fn2.isValid(scalar))\n          throw new Error(\"invalid scalar: expected 0 <= sc < curve.n\");\n        if (scalar === _0n4)\n          return Point.ZERO;\n        if (this.is0() || scalar === _1n4)\n          return this;\n        return wnaf.unsafe(this, scalar, (p) => normalizeZ(Point, p), acc);\n      }\n      // Checks if point is of small order.\n      // If you add something to small order point, you will have \"dirty\"\n      // point with torsion component.\n      // Multiplies point by cofactor and checks if the result is 0.\n      isSmallOrder() {\n        return this.multiplyUnsafe(cofactor).is0();\n      }\n      // Multiplies point by curve order and checks if the result is 0.\n      // Returns `false` is the point is dirty.\n      isTorsionFree() {\n        return wnaf.unsafe(this, CURVE.n).is0();\n      }\n      // Converts Extended point to default (x, y) coordinates.\n      // Can accept precomputed Z^-1 - for example, from invertBatch.\n      toAffine(invertedZ) {\n        return toAffineMemo(this, invertedZ);\n      }\n      clearCofactor() {\n        if (cofactor === _1n4)\n          return this;\n        return this.multiplyUnsafe(cofactor);\n      }\n      toBytes() {\n        const { x, y } = this.toAffine();\n        const bytes = Fp2.toBytes(y);\n        bytes[bytes.length - 1] |= x & _1n4 ? 128 : 0;\n        return bytes;\n      }\n      toHex() {\n        return bytesToHex(this.toBytes());\n      }\n      toString() {\n        return `<Point ${this.is0() ? \"ZERO\" : this.toHex()}>`;\n      }\n      // TODO: remove\n      get ex() {\n        return this.X;\n      }\n      get ey() {\n        return this.Y;\n      }\n      get ez() {\n        return this.Z;\n      }\n      get et() {\n        return this.T;\n      }\n      static normalizeZ(points) {\n        return normalizeZ(Point, points);\n      }\n      static msm(points, scalars) {\n        return pippenger(Point, Fn2, points, scalars);\n      }\n      _setWindowSize(windowSize) {\n        this.precompute(windowSize);\n      }\n      toRawBytes() {\n        return this.toBytes();\n      }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n4, modP(CURVE.Gx * CURVE.Gy));\n    Point.ZERO = new Point(_0n4, _1n4, _1n4, _0n4);\n    Point.Fp = Fp2;\n    Point.Fn = Fn2;\n    const wnaf = new wNAF(Point, Fn2.BITS);\n    Point.BASE.precompute(8);\n    return Point;\n  }\n  var PrimeEdwardsPoint = class {\n    constructor(ep) {\n      this.ep = ep;\n    }\n    // Static methods that must be implemented by subclasses\n    static fromBytes(_bytes) {\n      notImplemented();\n    }\n    static fromHex(_hex) {\n      notImplemented();\n    }\n    get x() {\n      return this.toAffine().x;\n    }\n    get y() {\n      return this.toAffine().y;\n    }\n    // Common implementations\n    clearCofactor() {\n      return this;\n    }\n    assertValidity() {\n      this.ep.assertValidity();\n    }\n    toAffine(invertedZ) {\n      return this.ep.toAffine(invertedZ);\n    }\n    toHex() {\n      return bytesToHex(this.toBytes());\n    }\n    toString() {\n      return this.toHex();\n    }\n    isTorsionFree() {\n      return true;\n    }\n    isSmallOrder() {\n      return false;\n    }\n    add(other) {\n      this.assertSame(other);\n      return this.init(this.ep.add(other.ep));\n    }\n    subtract(other) {\n      this.assertSame(other);\n      return this.init(this.ep.subtract(other.ep));\n    }\n    multiply(scalar) {\n      return this.init(this.ep.multiply(scalar));\n    }\n    multiplyUnsafe(scalar) {\n      return this.init(this.ep.multiplyUnsafe(scalar));\n    }\n    double() {\n      return this.init(this.ep.double());\n    }\n    negate() {\n      return this.init(this.ep.negate());\n    }\n    precompute(windowSize, isLazy) {\n      return this.init(this.ep.precompute(windowSize, isLazy));\n    }\n    /** @deprecated use `toBytes` */\n    toRawBytes() {\n      return this.toBytes();\n    }\n  };\n  function eddsa(Point, cHash, eddsaOpts = {}) {\n    if (typeof cHash !== \"function\")\n      throw new Error('\"hash\" function param is required');\n    _validateObject(eddsaOpts, {}, {\n      adjustScalarBytes: \"function\",\n      randomBytes: \"function\",\n      domain: \"function\",\n      prehash: \"function\",\n      mapToCurve: \"function\"\n    });\n    const { prehash } = eddsaOpts;\n    const { BASE, Fp: Fp2, Fn: Fn2 } = Point;\n    const randomBytes2 = eddsaOpts.randomBytes || randomBytes;\n    const adjustScalarBytes2 = eddsaOpts.adjustScalarBytes || ((bytes) => bytes);\n    const domain = eddsaOpts.domain || ((data, ctx, phflag) => {\n      _abool2(phflag, \"phflag\");\n      if (ctx.length || phflag)\n        throw new Error(\"Contexts/pre-hash are not supported\");\n      return data;\n    });\n    function modN_LE(hash) {\n      return Fn2.create(bytesToNumberLE(hash));\n    }\n    function getPrivateScalar(key) {\n      const len = lengths.secretKey;\n      key = ensureBytes(\"private key\", key, len);\n      const hashed = ensureBytes(\"hashed private key\", cHash(key), 2 * len);\n      const head = adjustScalarBytes2(hashed.slice(0, len));\n      const prefix = hashed.slice(len, 2 * len);\n      const scalar = modN_LE(head);\n      return { head, prefix, scalar };\n    }\n    function getExtendedPublicKey(secretKey) {\n      const { head, prefix, scalar } = getPrivateScalar(secretKey);\n      const point = BASE.multiply(scalar);\n      const pointBytes = point.toBytes();\n      return { head, prefix, scalar, point, pointBytes };\n    }\n    function getPublicKey2(secretKey) {\n      return getExtendedPublicKey(secretKey).pointBytes;\n    }\n    function hashDomainToScalar(context = Uint8Array.of(), ...msgs) {\n      const msg = concatBytes(...msgs);\n      return modN_LE(cHash(domain(msg, ensureBytes(\"context\", context), !!prehash)));\n    }\n    function sign2(msg, secretKey, options = {}) {\n      msg = ensureBytes(\"message\", msg);\n      if (prehash)\n        msg = prehash(msg);\n      const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);\n      const r = hashDomainToScalar(options.context, prefix, msg);\n      const R = BASE.multiply(r).toBytes();\n      const k = hashDomainToScalar(options.context, R, pointBytes, msg);\n      const s = Fn2.create(r + k * scalar);\n      if (!Fn2.isValid(s))\n        throw new Error(\"sign failed: invalid s\");\n      const rs = concatBytes(R, Fn2.toBytes(s));\n      return _abytes2(rs, lengths.signature, \"result\");\n    }\n    const verifyOpts = { zip215: true };\n    function verify2(sig, msg, publicKey2, options = verifyOpts) {\n      const { context, zip215 } = options;\n      const len = lengths.signature;\n      sig = ensureBytes(\"signature\", sig, len);\n      msg = ensureBytes(\"message\", msg);\n      publicKey2 = ensureBytes(\"publicKey\", publicKey2, lengths.publicKey);\n      if (zip215 !== void 0)\n        _abool2(zip215, \"zip215\");\n      if (prehash)\n        msg = prehash(msg);\n      const mid = len / 2;\n      const r = sig.subarray(0, mid);\n      const s = bytesToNumberLE(sig.subarray(mid, len));\n      let A, R, SB;\n      try {\n        A = Point.fromBytes(publicKey2, zip215);\n        R = Point.fromBytes(r, zip215);\n        SB = BASE.multiplyUnsafe(s);\n      } catch (error) {\n        return false;\n      }\n      if (!zip215 && A.isSmallOrder())\n        return false;\n      const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);\n      const RkA = R.add(A.multiplyUnsafe(k));\n      return RkA.subtract(SB).clearCofactor().is0();\n    }\n    const _size = Fp2.BYTES;\n    const lengths = {\n      secretKey: _size,\n      publicKey: _size,\n      signature: 2 * _size,\n      seed: _size\n    };\n    function randomSecretKey(seed = randomBytes2(lengths.seed)) {\n      return _abytes2(seed, lengths.seed, \"seed\");\n    }\n    function keygen(seed) {\n      const secretKey = utils.randomSecretKey(seed);\n      return { secretKey, publicKey: getPublicKey2(secretKey) };\n    }\n    function isValidSecretKey(key) {\n      return isBytes(key) && key.length === Fn2.BYTES;\n    }\n    function isValidPublicKey(key, zip215) {\n      try {\n        return !!Point.fromBytes(key, zip215);\n      } catch (error) {\n        return false;\n      }\n    }\n    const utils = {\n      getExtendedPublicKey,\n      randomSecretKey,\n      isValidSecretKey,\n      isValidPublicKey,\n      /**\n       * Converts ed public key to x public key. Uses formula:\n       * - ed25519:\n       *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n       *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n       * - ed448:\n       *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`\n       *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`\n       */\n      toMontgomery(publicKey2) {\n        const { y } = Point.fromBytes(publicKey2);\n        const size = lengths.publicKey;\n        const is25519 = size === 32;\n        if (!is25519 && size !== 57)\n          throw new Error(\"only defined for 25519 and 448\");\n        const u = is25519 ? Fp2.div(_1n4 + y, _1n4 - y) : Fp2.div(y - _1n4, y + _1n4);\n        return Fp2.toBytes(u);\n      },\n      toMontgomerySecret(secretKey) {\n        const size = lengths.secretKey;\n        _abytes2(secretKey, size);\n        const hashed = cHash(secretKey.subarray(0, size));\n        return adjustScalarBytes2(hashed).subarray(0, size);\n      },\n      /** @deprecated */\n      randomPrivateKey: randomSecretKey,\n      /** @deprecated */\n      precompute(windowSize = 8, point = Point.BASE) {\n        return point.precompute(windowSize, false);\n      }\n    };\n    return Object.freeze({\n      keygen,\n      getPublicKey: getPublicKey2,\n      sign: sign2,\n      verify: verify2,\n      utils,\n      Point,\n      lengths\n    });\n  }\n  function _eddsa_legacy_opts_to_new(c) {\n    const CURVE = {\n      a: c.a,\n      d: c.d,\n      p: c.Fp.ORDER,\n      n: c.n,\n      h: c.h,\n      Gx: c.Gx,\n      Gy: c.Gy\n    };\n    const Fp2 = c.Fp;\n    const Fn2 = Field(CURVE.n, c.nBitLength, true);\n    const curveOpts = { Fp: Fp2, Fn: Fn2, uvRatio: c.uvRatio };\n    const eddsaOpts = {\n      randomBytes: c.randomBytes,\n      adjustScalarBytes: c.adjustScalarBytes,\n      domain: c.domain,\n      prehash: c.prehash,\n      mapToCurve: c.mapToCurve\n    };\n    return { CURVE, curveOpts, hash: c.hash, eddsaOpts };\n  }\n  function _eddsa_new_output_to_legacy(c, eddsa2) {\n    const Point = eddsa2.Point;\n    const legacy = Object.assign({}, eddsa2, {\n      ExtendedPoint: Point,\n      CURVE: c,\n      nBitLength: Point.Fn.BITS,\n      nByteLength: Point.Fn.BYTES\n    });\n    return legacy;\n  }\n  function twistedEdwards(c) {\n    const { CURVE, curveOpts, hash, eddsaOpts } = _eddsa_legacy_opts_to_new(c);\n    const Point = edwards(CURVE, curveOpts);\n    const EDDSA = eddsa(Point, hash, eddsaOpts);\n    return _eddsa_new_output_to_legacy(c, EDDSA);\n  }\n\n  // ../../../node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/ed25519.js\n  var _0n5 = /* @__PURE__ */ BigInt(0);\n  var _1n5 = BigInt(1);\n  var _2n3 = BigInt(2);\n  var _3n2 = BigInt(3);\n  var _5n2 = BigInt(5);\n  var _8n3 = BigInt(8);\n  var ed25519_CURVE_p = BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed\");\n  var ed25519_CURVE = /* @__PURE__ */ (() => ({\n    p: ed25519_CURVE_p,\n    n: BigInt(\"0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed\"),\n    h: _8n3,\n    a: BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec\"),\n    d: BigInt(\"0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3\"),\n    Gx: BigInt(\"0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a\"),\n    Gy: BigInt(\"0x6666666666666666666666666666666666666666666666666666666666666658\")\n  }))();\n  function ed25519_pow_2_252_3(x) {\n    const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\n    const P = ed25519_CURVE_p;\n    const x2 = x * x % P;\n    const b2 = x2 * x % P;\n    const b4 = pow2(b2, _2n3, P) * b2 % P;\n    const b5 = pow2(b4, _1n5, P) * x % P;\n    const b10 = pow2(b5, _5n2, P) * b5 % P;\n    const b20 = pow2(b10, _10n, P) * b10 % P;\n    const b40 = pow2(b20, _20n, P) * b20 % P;\n    const b80 = pow2(b40, _40n, P) * b40 % P;\n    const b160 = pow2(b80, _80n, P) * b80 % P;\n    const b240 = pow2(b160, _80n, P) * b80 % P;\n    const b250 = pow2(b240, _10n, P) * b10 % P;\n    const pow_p_5_8 = pow2(b250, _2n3, P) * x % P;\n    return { pow_p_5_8, b2 };\n  }\n  function adjustScalarBytes(bytes) {\n    bytes[0] &= 248;\n    bytes[31] &= 127;\n    bytes[31] |= 64;\n    return bytes;\n  }\n  var ED25519_SQRT_M1 = /* @__PURE__ */ BigInt(\"19681161376707505956807079304988542015446066515923890162744021073123829784752\");\n  function uvRatio(u, v) {\n    const P = ed25519_CURVE_p;\n    const v32 = mod(v * v * v, P);\n    const v7 = mod(v32 * v32 * v, P);\n    const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n    let x = mod(u * v32 * pow, P);\n    const vx2 = mod(v * x * x, P);\n    const root1 = x;\n    const root2 = mod(x * ED25519_SQRT_M1, P);\n    const useRoot1 = vx2 === u;\n    const useRoot2 = vx2 === mod(-u, P);\n    const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P);\n    if (useRoot1)\n      x = root1;\n    if (useRoot2 || noRoot)\n      x = root2;\n    if (isNegativeLE(x, P))\n      x = mod(-x, P);\n    return { isValid: useRoot1 || useRoot2, value: x };\n  }\n  var Fp = /* @__PURE__ */ (() => Field(ed25519_CURVE.p, { isLE: true }))();\n  var Fn = /* @__PURE__ */ (() => Field(ed25519_CURVE.n, { isLE: true }))();\n  var ed25519Defaults = /* @__PURE__ */ (() => ({\n    ...ed25519_CURVE,\n    Fp,\n    hash: sha512,\n    adjustScalarBytes,\n    // dom2\n    // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.\n    // Constant-time, u/v\n    uvRatio\n  }))();\n  var ed25519 = /* @__PURE__ */ (() => twistedEdwards(ed25519Defaults))();\n  var SQRT_M1 = ED25519_SQRT_M1;\n  var SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt(\"25063068953384623474111414158702152701244531502492656460079210482610430750235\");\n  var INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt(\"54469307008909316920995813868745141605393597292927456921205312896311721017578\");\n  var ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt(\"1159843021668779879193775521855586647937357759715417654439879720876111806838\");\n  var D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt(\"40440834346308536858101042469323190826248399146238708352240133220865137265952\");\n  var invertSqrt = (number2) => uvRatio(_1n5, number2);\n  var MAX_255B = /* @__PURE__ */ BigInt(\"0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n  var bytes255ToNumberLE = (bytes) => ed25519.Point.Fp.create(bytesToNumberLE(bytes) & MAX_255B);\n  function calcElligatorRistrettoMap(r0) {\n    const { d } = ed25519_CURVE;\n    const P = ed25519_CURVE_p;\n    const mod2 = (n) => Fp.create(n);\n    const r = mod2(SQRT_M1 * r0 * r0);\n    const Ns = mod2((r + _1n5) * ONE_MINUS_D_SQ);\n    let c = BigInt(-1);\n    const D = mod2((c - d * r) * mod2(r + d));\n    let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);\n    let s_ = mod2(s * r0);\n    if (!isNegativeLE(s_, P))\n      s_ = mod2(-s_);\n    if (!Ns_D_is_sq)\n      s = s_;\n    if (!Ns_D_is_sq)\n      c = r;\n    const Nt = mod2(c * (r - _1n5) * D_MINUS_ONE_SQ - D);\n    const s2 = s * s;\n    const W0 = mod2((s + s) * D);\n    const W1 = mod2(Nt * SQRT_AD_MINUS_ONE);\n    const W2 = mod2(_1n5 - s2);\n    const W3 = mod2(_1n5 + s2);\n    return new ed25519.Point(mod2(W0 * W3), mod2(W2 * W1), mod2(W1 * W3), mod2(W0 * W2));\n  }\n  function ristretto255_map(bytes) {\n    abytes(bytes, 64);\n    const r1 = bytes255ToNumberLE(bytes.subarray(0, 32));\n    const R1 = calcElligatorRistrettoMap(r1);\n    const r2 = bytes255ToNumberLE(bytes.subarray(32, 64));\n    const R2 = calcElligatorRistrettoMap(r2);\n    return new _RistrettoPoint(R1.add(R2));\n  }\n  var _RistrettoPoint = class __RistrettoPoint extends PrimeEdwardsPoint {\n    constructor(ep) {\n      super(ep);\n    }\n    static fromAffine(ap) {\n      return new __RistrettoPoint(ed25519.Point.fromAffine(ap));\n    }\n    assertSame(other) {\n      if (!(other instanceof __RistrettoPoint))\n        throw new Error(\"RistrettoPoint expected\");\n    }\n    init(ep) {\n      return new __RistrettoPoint(ep);\n    }\n    /** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */\n    static hashToCurve(hex) {\n      return ristretto255_map(ensureBytes(\"ristrettoHash\", hex, 64));\n    }\n    static fromBytes(bytes) {\n      abytes(bytes, 32);\n      const { a, d } = ed25519_CURVE;\n      const P = ed25519_CURVE_p;\n      const mod2 = (n) => Fp.create(n);\n      const s = bytes255ToNumberLE(bytes);\n      if (!equalBytes(Fp.toBytes(s), bytes) || isNegativeLE(s, P))\n        throw new Error(\"invalid ristretto255 encoding 1\");\n      const s2 = mod2(s * s);\n      const u1 = mod2(_1n5 + a * s2);\n      const u2 = mod2(_1n5 - a * s2);\n      const u1_2 = mod2(u1 * u1);\n      const u2_2 = mod2(u2 * u2);\n      const v = mod2(a * d * u1_2 - u2_2);\n      const { isValid, value: I } = invertSqrt(mod2(v * u2_2));\n      const Dx = mod2(I * u2);\n      const Dy = mod2(I * Dx * v);\n      let x = mod2((s + s) * Dx);\n      if (isNegativeLE(x, P))\n        x = mod2(-x);\n      const y = mod2(u1 * Dy);\n      const t = mod2(x * y);\n      if (!isValid || isNegativeLE(t, P) || y === _0n5)\n        throw new Error(\"invalid ristretto255 encoding 2\");\n      return new __RistrettoPoint(new ed25519.Point(x, y, _1n5, t));\n    }\n    /**\n     * Converts ristretto-encoded string to ristretto point.\n     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).\n     * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n     */\n    static fromHex(hex) {\n      return __RistrettoPoint.fromBytes(ensureBytes(\"ristrettoHex\", hex, 32));\n    }\n    static msm(points, scalars) {\n      return pippenger(__RistrettoPoint, ed25519.Point.Fn, points, scalars);\n    }\n    /**\n     * Encodes ristretto point to Uint8Array.\n     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).\n     */\n    toBytes() {\n      let { X, Y, Z, T } = this.ep;\n      const P = ed25519_CURVE_p;\n      const mod2 = (n) => Fp.create(n);\n      const u1 = mod2(mod2(Z + Y) * mod2(Z - Y));\n      const u2 = mod2(X * Y);\n      const u2sq = mod2(u2 * u2);\n      const { value: invsqrt } = invertSqrt(mod2(u1 * u2sq));\n      const D1 = mod2(invsqrt * u1);\n      const D2 = mod2(invsqrt * u2);\n      const zInv = mod2(D1 * D2 * T);\n      let D;\n      if (isNegativeLE(T * zInv, P)) {\n        let _x = mod2(Y * SQRT_M1);\n        let _y = mod2(X * SQRT_M1);\n        X = _x;\n        Y = _y;\n        D = mod2(D1 * INVSQRT_A_MINUS_D);\n      } else {\n        D = D2;\n      }\n      if (isNegativeLE(X * zInv, P))\n        Y = mod2(-Y);\n      let s = mod2((Z - Y) * D);\n      if (isNegativeLE(s, P))\n        s = mod2(-s);\n      return Fp.toBytes(s);\n    }\n    /**\n     * Compares two Ristretto points.\n     * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).\n     */\n    equals(other) {\n      this.assertSame(other);\n      const { X: X1, Y: Y1 } = this.ep;\n      const { X: X2, Y: Y2 } = other.ep;\n      const mod2 = (n) => Fp.create(n);\n      const one = mod2(X1 * Y2) === mod2(Y1 * X2);\n      const two = mod2(Y1 * Y2) === mod2(X1 * X2);\n      return one || two;\n    }\n    is0() {\n      return this.equals(__RistrettoPoint.ZERO);\n    }\n  };\n  _RistrettoPoint.BASE = /* @__PURE__ */ (() => new _RistrettoPoint(ed25519.Point.BASE))();\n  _RistrettoPoint.ZERO = /* @__PURE__ */ (() => new _RistrettoPoint(ed25519.Point.ZERO))();\n  _RistrettoPoint.Fp = /* @__PURE__ */ (() => Fp)();\n  _RistrettoPoint.Fn = /* @__PURE__ */ (() => Fn)();\n\n  // ../../../node_modules/.pnpm/@solana+web3.js@1.98.4_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10/node_modules/@solana/web3.js/lib/index.browser.esm.js\n  var import_bn = __toESM(require_bn());\n  var import_bs58 = __toESM(require_bs58());\n\n  // ../../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/sha256.js\n  init_dirname();\n  init_buffer2();\n  init_process2();\n  var sha2562 = sha256;\n\n  // ../../../node_modules/.pnpm/@solana+web3.js@1.98.4_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10/node_modules/@solana/web3.js/lib/index.browser.esm.js\n  var import_borsh = __toESM(require_lib());\n  var BufferLayout = __toESM(require_Layout());\n  var import_buffer_layout = __toESM(require_Layout());\n\n  // ../../../node_modules/.pnpm/@solana+codecs-numbers@2.3.0_typescript@5.8.3/node_modules/@solana/codecs-numbers/dist/index.browser.mjs\n  init_dirname();\n  init_buffer2();\n  init_process2();\n\n  // ../../../node_modules/.pnpm/@solana+errors@2.3.0_typescript@5.8.3/node_modules/@solana/errors/dist/index.browser.mjs\n  init_dirname();\n  init_buffer2();\n  init_process2();\n  var SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED = 1;\n  var SOLANA_ERROR__INVALID_NONCE = 2;\n  var SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND = 3;\n  var SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE = 4;\n  var SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH = 5;\n  var SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE = 6;\n  var SOLANA_ERROR__MALFORMED_BIGINT_STRING = 7;\n  var SOLANA_ERROR__MALFORMED_NUMBER_STRING = 8;\n  var SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE = 9;\n  var SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR = 10;\n  var SOLANA_ERROR__JSON_RPC__PARSE_ERROR = -32700;\n  var SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR = -32603;\n  var SOLANA_ERROR__JSON_RPC__INVALID_PARAMS = -32602;\n  var SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND = -32601;\n  var SOLANA_ERROR__JSON_RPC__INVALID_REQUEST = -32600;\n  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED = -32016;\n  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION = -32015;\n  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET = -32014;\n  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH = -32013;\n  var SOLANA_ERROR__JSON_RPC__SCAN_ERROR = -32012;\n  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE = -32011;\n  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX = -32010;\n  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED = -32009;\n  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT = -32008;\n  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED = -32007;\n  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE = -32006;\n  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY = -32005;\n  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE = -32004;\n  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE = -32003;\n  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE = -32002;\n  var SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP = -32001;\n  var SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH = 28e5;\n  var SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE = 2800001;\n  var SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS = 2800002;\n  var SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY = 2800003;\n  var SOLANA_ERROR__ADDRESSES__MALFORMED_PDA = 2800004;\n  var SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE = 2800005;\n  var SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED = 2800006;\n  var SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED = 2800007;\n  var SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE = 2800008;\n  var SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED = 2800009;\n  var SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER = 2800010;\n  var SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS = 2800011;\n  var SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND = 323e4;\n  var SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND = 32300001;\n  var SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT = 3230002;\n  var SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT = 3230003;\n  var SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED = 3230004;\n  var SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT = 361e4;\n  var SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED = 3610001;\n  var SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED = 3610002;\n  var SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED = 3610003;\n  var SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED = 3610004;\n  var SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED = 3610005;\n  var SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED = 3610006;\n  var SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY = 3610007;\n  var SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED = 3611e3;\n  var SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH = 3704e3;\n  var SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH = 3704001;\n  var SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH = 3704002;\n  var SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE = 3704003;\n  var SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY = 3704004;\n  var SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS = 4128e3;\n  var SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA = 4128001;\n  var SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH = 4128002;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN = 4615e3;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR = 4615001;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT = 4615002;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA = 4615003;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA = 4615004;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL = 4615005;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS = 4615006;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID = 4615007;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE = 4615008;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED = 4615009;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT = 4615010;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION = 4615011;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID = 4615012;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND = 4615013;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED = 4615014;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE = 4615015;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED = 4615016;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX = 4615017;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED = 4615018;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED = 4615019;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS = 4615020;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED = 4615021;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE = 4615022;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED = 4615023;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 4615024;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC = 4615025;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM = 4615026;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR = 4615027;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED = 4615028;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE = 4615029;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT = 4615030;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID = 4615031;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH = 4615032;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT = 4615033;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED = 4615034;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED = 4615035;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS = 4615036;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC = 4615037;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED = 4615038;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION = 4615039;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE = 4615040;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE = 4615041;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE = 4615042;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE = 4615043;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY = 4615044;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR = 4615045;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT = 4615046;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER = 4615047;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW = 4615048;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR = 4615049;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER = 4615050;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED = 4615051;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED = 4615052;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED = 4615053;\n  var SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS = 4615054;\n  var SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS = 5508e3;\n  var SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER = 5508001;\n  var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER = 5508002;\n  var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER = 5508003;\n  var SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER = 5508004;\n  var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER = 5508005;\n  var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER = 5508006;\n  var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER = 5508007;\n  var SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER = 5508008;\n  var SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS = 5508009;\n  var SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING = 5508010;\n  var SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED = 5508011;\n  var SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES = 5663e3;\n  var SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE = 5663001;\n  var SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME = 5663002;\n  var SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME = 5663003;\n  var SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE = 5663004;\n  var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING = 5663005;\n  var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE = 5663006;\n  var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND = 5663007;\n  var SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING = 5663008;\n  var SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING = 5663009;\n  var SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING = 5663010;\n  var SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING = 5663011;\n  var SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING = 5663012;\n  var SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING = 5663013;\n  var SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE = 5663014;\n  var SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION = 5663015;\n  var SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES = 5663016;\n  var SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH = 5663017;\n  var SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT = 5663018;\n  var SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT = 5663019;\n  var SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT = 5663020;\n  var SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN = 705e4;\n  var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE = 7050001;\n  var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE = 7050002;\n  var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND = 7050003;\n  var SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND = 7050004;\n  var SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE = 7050005;\n  var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE = 7050006;\n  var SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED = 7050007;\n  var SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND = 7050008;\n  var SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP = 7050009;\n  var SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE = 7050010;\n  var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX = 7050011;\n  var SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE = 7050012;\n  var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION = 7050013;\n  var SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE = 7050014;\n  var SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE = 7050015;\n  var SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING = 7050016;\n  var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT = 7050017;\n  var SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION = 7050018;\n  var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT = 7050019;\n  var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT = 7050020;\n  var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT = 7050021;\n  var SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS = 7050022;\n  var SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND = 7050023;\n  var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER = 7050024;\n  var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA = 7050025;\n  var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX = 7050026;\n  var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT = 7050027;\n  var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT = 7050028;\n  var SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT = 7050029;\n  var SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION = 7050030;\n  var SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT = 7050031;\n  var SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED = 7050032;\n  var SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT = 7050033;\n  var SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED = 7050034;\n  var SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED = 7050035;\n  var SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION = 7050036;\n  var SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY = 8078e3;\n  var SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH = 8078001;\n  var SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH = 8078002;\n  var SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH = 8078003;\n  var SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH = 8078004;\n  var SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH = 8078005;\n  var SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH = 8078006;\n  var SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS = 8078007;\n  var SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE = 8078008;\n  var SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT = 8078009;\n  var SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT = 8078010;\n  var SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE = 8078011;\n  var SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE = 8078012;\n  var SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH = 8078013;\n  var SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE = 8078014;\n  var SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT = 8078015;\n  var SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE = 8078016;\n  var SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE = 8078017;\n  var SOLANA_ERROR__CODECS__INVALID_CONSTANT = 8078018;\n  var SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE = 8078019;\n  var SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL = 8078020;\n  var SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES = 8078021;\n  var SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS = 8078022;\n  var SOLANA_ERROR__RPC__INTEGER_OVERFLOW = 81e5;\n  var SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN = 8100001;\n  var SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR = 8100002;\n  var SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD = 8100003;\n  var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN = 819e4;\n  var SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID = 8190001;\n  var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED = 8190002;\n  var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED = 8190003;\n  var SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT = 8190004;\n  var SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING = 99e5;\n  var SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE = 9900001;\n  var SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING = 9900002;\n  var SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE = 9900003;\n  var SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED = 9900004;\n  var SolanaErrorMessages = {\n    [SOLANA_ERROR__ACCOUNTS__ACCOUNT_NOT_FOUND]: \"Account not found at address: $address\",\n    [SOLANA_ERROR__ACCOUNTS__EXPECTED_ALL_ACCOUNTS_TO_BE_DECODED]: \"Not all accounts were decoded. Encoded accounts found at addresses: $addresses.\",\n    [SOLANA_ERROR__ACCOUNTS__EXPECTED_DECODED_ACCOUNT]: \"Expected decoded account at address: $address\",\n    [SOLANA_ERROR__ACCOUNTS__FAILED_TO_DECODE_ACCOUNT]: \"Failed to decode account data at address: $address\",\n    [SOLANA_ERROR__ACCOUNTS__ONE_OR_MORE_ACCOUNTS_NOT_FOUND]: \"Accounts not found at addresses: $addresses\",\n    [SOLANA_ERROR__ADDRESSES__FAILED_TO_FIND_VIABLE_PDA_BUMP_SEED]: \"Unable to find a viable program address bump seed.\",\n    [SOLANA_ERROR__ADDRESSES__INVALID_BASE58_ENCODED_ADDRESS]: \"$putativeAddress is not a base58-encoded address.\",\n    [SOLANA_ERROR__ADDRESSES__INVALID_BYTE_LENGTH]: \"Expected base58 encoded address to decode to a byte array of length 32. Actual length: $actualLength.\",\n    [SOLANA_ERROR__ADDRESSES__INVALID_ED25519_PUBLIC_KEY]: \"The `CryptoKey` must be an `Ed25519` public key.\",\n    [SOLANA_ERROR__ADDRESSES__INVALID_OFF_CURVE_ADDRESS]: \"$putativeOffCurveAddress is not a base58-encoded off-curve address.\",\n    [SOLANA_ERROR__ADDRESSES__INVALID_SEEDS_POINT_ON_CURVE]: \"Invalid seeds; point must fall off the Ed25519 curve.\",\n    [SOLANA_ERROR__ADDRESSES__MALFORMED_PDA]: \"Expected given program derived address to have the following format: [Address, ProgramDerivedAddressBump].\",\n    [SOLANA_ERROR__ADDRESSES__MAX_NUMBER_OF_PDA_SEEDS_EXCEEDED]: \"A maximum of $maxSeeds seeds, including the bump seed, may be supplied when creating an address. Received: $actual.\",\n    [SOLANA_ERROR__ADDRESSES__MAX_PDA_SEED_LENGTH_EXCEEDED]: \"The seed at index $index with length $actual exceeds the maximum length of $maxSeedLength bytes.\",\n    [SOLANA_ERROR__ADDRESSES__PDA_BUMP_SEED_OUT_OF_RANGE]: \"Expected program derived address bump to be in the range [0, 255], got: $bump.\",\n    [SOLANA_ERROR__ADDRESSES__PDA_ENDS_WITH_PDA_MARKER]: \"Program address cannot end with PDA marker.\",\n    [SOLANA_ERROR__ADDRESSES__STRING_LENGTH_OUT_OF_RANGE]: \"Expected base58-encoded address string of length in the range [32, 44]. Actual length: $actualLength.\",\n    [SOLANA_ERROR__BLOCKHASH_STRING_LENGTH_OUT_OF_RANGE]: \"Expected base58-encoded blockash string of length in the range [32, 44]. Actual length: $actualLength.\",\n    [SOLANA_ERROR__BLOCK_HEIGHT_EXCEEDED]: \"The network has progressed past the last block for which this transaction could have been committed.\",\n    [SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY]: \"Codec [$codecDescription] cannot decode empty byte arrays.\",\n    [SOLANA_ERROR__CODECS__CANNOT_USE_LEXICAL_VALUES_AS_ENUM_DISCRIMINATORS]: \"Enum codec cannot use lexical values [$stringValues] as discriminators. Either remove all lexical values or set `useValuesAsDiscriminators` to `false`.\",\n    [SOLANA_ERROR__CODECS__ENCODED_BYTES_MUST_NOT_INCLUDE_SENTINEL]: \"Sentinel [$hexSentinel] must not be present in encoded bytes [$hexEncodedBytes].\",\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH]: \"Encoder and decoder must have the same fixed size, got [$encoderFixedSize] and [$decoderFixedSize].\",\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH]: \"Encoder and decoder must have the same max size, got [$encoderMaxSize] and [$decoderMaxSize].\",\n    [SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH]: \"Encoder and decoder must either both be fixed-size or variable-size.\",\n    [SOLANA_ERROR__CODECS__ENUM_DISCRIMINATOR_OUT_OF_RANGE]: \"Enum discriminator out of range. Expected a number in [$formattedValidDiscriminators], got $discriminator.\",\n    [SOLANA_ERROR__CODECS__EXPECTED_FIXED_LENGTH]: \"Expected a fixed-size codec, got a variable-size one.\",\n    [SOLANA_ERROR__CODECS__EXPECTED_POSITIVE_BYTE_LENGTH]: \"Codec [$codecDescription] expected a positive byte length, got $bytesLength.\",\n    [SOLANA_ERROR__CODECS__EXPECTED_VARIABLE_LENGTH]: \"Expected a variable-size codec, got a fixed-size one.\",\n    [SOLANA_ERROR__CODECS__EXPECTED_ZERO_VALUE_TO_MATCH_ITEM_FIXED_SIZE]: \"Codec [$codecDescription] expected zero-value [$hexZeroValue] to have the same size as the provided fixed-size item [$expectedSize bytes].\",\n    [SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH]: \"Codec [$codecDescription] expected $expected bytes, got $bytesLength.\",\n    [SOLANA_ERROR__CODECS__INVALID_CONSTANT]: \"Expected byte array constant [$hexConstant] to be present in data [$hexData] at offset [$offset].\",\n    [SOLANA_ERROR__CODECS__INVALID_DISCRIMINATED_UNION_VARIANT]: \"Invalid discriminated union variant. Expected one of [$variants], got $value.\",\n    [SOLANA_ERROR__CODECS__INVALID_ENUM_VARIANT]: \"Invalid enum variant. Expected one of [$stringValues] or a number in [$formattedNumericalValues], got $variant.\",\n    [SOLANA_ERROR__CODECS__INVALID_LITERAL_UNION_VARIANT]: \"Invalid literal union variant. Expected one of [$variants], got $value.\",\n    [SOLANA_ERROR__CODECS__INVALID_NUMBER_OF_ITEMS]: \"Expected [$codecDescription] to have $expected items, got $actual.\",\n    [SOLANA_ERROR__CODECS__INVALID_STRING_FOR_BASE]: \"Invalid value $value for base $base with alphabet $alphabet.\",\n    [SOLANA_ERROR__CODECS__LITERAL_UNION_DISCRIMINATOR_OUT_OF_RANGE]: \"Literal union discriminator out of range. Expected a number between $minRange and $maxRange, got $discriminator.\",\n    [SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE]: \"Codec [$codecDescription] expected number to be in the range [$min, $max], got $value.\",\n    [SOLANA_ERROR__CODECS__OFFSET_OUT_OF_RANGE]: \"Codec [$codecDescription] expected offset to be in the range [0, $bytesLength], got $offset.\",\n    [SOLANA_ERROR__CODECS__SENTINEL_MISSING_IN_DECODED_BYTES]: \"Expected sentinel [$hexSentinel] to be present in decoded bytes [$hexDecodedBytes].\",\n    [SOLANA_ERROR__CODECS__UNION_VARIANT_OUT_OF_RANGE]: \"Union variant out of range. Expected an index between $minRange and $maxRange, got $variant.\",\n    [SOLANA_ERROR__CRYPTO__RANDOM_VALUES_FUNCTION_UNIMPLEMENTED]: \"No random values implementation could be found.\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_ALREADY_INITIALIZED]: \"instruction requires an uninitialized account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_FAILED]: \"instruction tries to borrow reference for an account which is already borrowed\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: \"instruction left account with an outstanding borrowed reference\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_SIZE_CHANGED]: \"program other than the account's owner changed the size of the account data\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_DATA_TOO_SMALL]: \"account data too small for instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_EXECUTABLE]: \"instruction expected an executable account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ACCOUNT_NOT_RENT_EXEMPT]: \"An account does not have enough lamports to be rent-exempt\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ARITHMETIC_OVERFLOW]: \"Program arithmetic overflowed\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__BORSH_IO_ERROR]: \"Failed to serialize or deserialize account data: $encodedData\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__BUILTIN_PROGRAMS_MUST_CONSUME_COMPUTE_UNITS]: \"Builtin programs must consume compute units\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__CALL_DEPTH]: \"Cross-program invocation call depth too deep\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__COMPUTATIONAL_BUDGET_EXCEEDED]: \"Computational budget exceeded\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__CUSTOM]: \"custom program error: #$code\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_INDEX]: \"instruction contains duplicate accounts\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__DUPLICATE_ACCOUNT_OUT_OF_SYNC]: \"instruction modifications of multiply-passed account differ\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_ACCOUNT_NOT_RENT_EXEMPT]: \"executable accounts must be rent exempt\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_DATA_MODIFIED]: \"instruction changed executable accounts data\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_LAMPORT_CHANGE]: \"instruction changed the balance of an executable account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXECUTABLE_MODIFIED]: \"instruction changed executable bit of an account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_DATA_MODIFIED]: \"instruction modified data of an account it does not own\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__EXTERNAL_ACCOUNT_LAMPORT_SPEND]: \"instruction spent from the balance of an account it does not own\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__GENERIC_ERROR]: \"generic instruction error\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__ILLEGAL_OWNER]: \"Provided owner is not allowed\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__IMMUTABLE]: \"Account is immutable\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_AUTHORITY]: \"Incorrect authority provided\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INCORRECT_PROGRAM_ID]: \"incorrect program id for instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INSUFFICIENT_FUNDS]: \"insufficient funds for instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_DATA]: \"invalid account data for instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ACCOUNT_OWNER]: \"Invalid account owner\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ARGUMENT]: \"invalid program argument\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_ERROR]: \"program returned invalid error code\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_INSTRUCTION_DATA]: \"invalid instruction data\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_REALLOC]: \"Failed to reallocate account data\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__INVALID_SEEDS]: \"Provided seeds do not result in a valid address\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_DATA_ALLOCATIONS_EXCEEDED]: \"Accounts data allocations exceeded the maximum allowed per transaction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_ACCOUNTS_EXCEEDED]: \"Max accounts exceeded\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_INSTRUCTION_TRACE_LENGTH_EXCEEDED]: \"Max instruction trace length exceeded\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MAX_SEED_LENGTH_EXCEEDED]: \"Length of the seed is too long for address generation\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_ACCOUNT]: \"An account required by the instruction is missing\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MISSING_REQUIRED_SIGNATURE]: \"missing required signature for instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__MODIFIED_PROGRAM_ID]: \"instruction illegally modified the program id of an account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__NOT_ENOUGH_ACCOUNT_KEYS]: \"insufficient account keys for instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PRIVILEGE_ESCALATION]: \"Cross-program invocation with unauthorized signer or writable account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_ENVIRONMENT_SETUP_FAILURE]: \"Failed to create program execution environment\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPILE]: \"Program failed to compile\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__PROGRAM_FAILED_TO_COMPLETE]: \"Program failed to complete\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_DATA_MODIFIED]: \"instruction modified data of a read-only account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__READONLY_LAMPORT_CHANGE]: \"instruction changed the balance of a read-only account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__REENTRANCY_NOT_ALLOWED]: \"Cross-program invocation reentrancy not allowed for this instruction\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__RENT_EPOCH_MODIFIED]: \"instruction modified rent epoch of an account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNBALANCED_INSTRUCTION]: \"sum of account balances before and after instruction do not match\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNINITIALIZED_ACCOUNT]: \"instruction requires an initialized account\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNKNOWN]: \"\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_PROGRAM_ID]: \"Unsupported program id\",\n    [SOLANA_ERROR__INSTRUCTION_ERROR__UNSUPPORTED_SYSVAR]: \"Unsupported sysvar\",\n    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_ACCOUNTS]: \"The instruction does not have any accounts.\",\n    [SOLANA_ERROR__INSTRUCTION__EXPECTED_TO_HAVE_DATA]: \"The instruction does not have any data.\",\n    [SOLANA_ERROR__INSTRUCTION__PROGRAM_ID_MISMATCH]: \"Expected instruction to have progress address $expectedProgramAddress, got $actualProgramAddress.\",\n    [SOLANA_ERROR__INVALID_BLOCKHASH_BYTE_LENGTH]: \"Expected base58 encoded blockhash to decode to a byte array of length 32. Actual length: $actualLength.\",\n    [SOLANA_ERROR__INVALID_NONCE]: \"The nonce `$expectedNonceValue` is no longer valid. It has advanced to `$actualNonceValue`\",\n    [SOLANA_ERROR__INVARIANT_VIOLATION__CACHED_ABORTABLE_ITERABLE_CACHE_ENTRY_MISSING]: \"Invariant violation: Found no abortable iterable cache entry for key `$cacheKey`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant\",\n    [SOLANA_ERROR__INVARIANT_VIOLATION__DATA_PUBLISHER_CHANNEL_UNIMPLEMENTED]: \"Invariant violation: This data publisher does not publish to the channel named `$channelName`. Supported channels include $supportedChannelNames.\",\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_MUST_NOT_POLL_BEFORE_RESOLVING_EXISTING_MESSAGE_PROMISE]: \"Invariant violation: WebSocket message iterator state is corrupt; iterated without first resolving existing message promise. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant\",\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SUBSCRIPTION_ITERATOR_STATE_MISSING]: \"Invariant violation: WebSocket message iterator is missing state storage. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant\",\n    [SOLANA_ERROR__INVARIANT_VIOLATION__SWITCH_MUST_BE_EXHAUSTIVE]: \"Invariant violation: Switch statement non-exhaustive. Received unexpected value `$unexpectedValue`. It should be impossible to hit this error; please file an issue at https://sola.na/web3invariant\",\n    [SOLANA_ERROR__JSON_RPC__INTERNAL_ERROR]: \"JSON-RPC error: Internal JSON-RPC error ($__serverMessage)\",\n    [SOLANA_ERROR__JSON_RPC__INVALID_PARAMS]: \"JSON-RPC error: Invalid method parameter(s) ($__serverMessage)\",\n    [SOLANA_ERROR__JSON_RPC__INVALID_REQUEST]: \"JSON-RPC error: The JSON sent is not a valid `Request` object ($__serverMessage)\",\n    [SOLANA_ERROR__JSON_RPC__METHOD_NOT_FOUND]: \"JSON-RPC error: The method does not exist / is not available ($__serverMessage)\",\n    [SOLANA_ERROR__JSON_RPC__PARSE_ERROR]: \"JSON-RPC error: An error occurred on the server while parsing the JSON text ($__serverMessage)\",\n    [SOLANA_ERROR__JSON_RPC__SCAN_ERROR]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_CLEANED_UP]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_NOT_AVAILABLE]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_BLOCK_STATUS_NOT_AVAILABLE_YET]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_KEY_EXCLUDED_FROM_SECONDARY_INDEX]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_LONG_TERM_STORAGE_SLOT_SKIPPED]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_MIN_CONTEXT_SLOT_NOT_REACHED]: \"Minimum context slot has not been reached\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NODE_UNHEALTHY]: \"Node is unhealthy; behind by $numSlotsBehind slots\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_NO_SNAPSHOT]: \"No snapshot\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SEND_TRANSACTION_PREFLIGHT_FAILURE]: \"Transaction simulation failed\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_SLOT_SKIPPED]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_HISTORY_NOT_AVAILABLE]: \"Transaction history is not available from this node\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_PRECOMPILE_VERIFICATION_FAILURE]: \"$__serverMessage\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_LEN_MISMATCH]: \"Transaction signature length mismatch\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_TRANSACTION_SIGNATURE_VERIFICATION_FAILURE]: \"Transaction signature verification failure\",\n    [SOLANA_ERROR__JSON_RPC__SERVER_ERROR_UNSUPPORTED_TRANSACTION_VERSION]: \"$__serverMessage\",\n    [SOLANA_ERROR__KEYS__INVALID_KEY_PAIR_BYTE_LENGTH]: \"Key pair bytes must be of length 64, got $byteLength.\",\n    [SOLANA_ERROR__KEYS__INVALID_PRIVATE_KEY_BYTE_LENGTH]: \"Expected private key bytes with length 32. Actual length: $actualLength.\",\n    [SOLANA_ERROR__KEYS__INVALID_SIGNATURE_BYTE_LENGTH]: \"Expected base58-encoded signature to decode to a byte array of length 64. Actual length: $actualLength.\",\n    [SOLANA_ERROR__KEYS__PUBLIC_KEY_MUST_MATCH_PRIVATE_KEY]: \"The provided private key does not match the provided public key.\",\n    [SOLANA_ERROR__KEYS__SIGNATURE_STRING_LENGTH_OUT_OF_RANGE]: \"Expected base58-encoded signature string of length in the range [64, 88]. Actual length: $actualLength.\",\n    [SOLANA_ERROR__LAMPORTS_OUT_OF_RANGE]: \"Lamports value must be in the range [0, 2e64-1]\",\n    [SOLANA_ERROR__MALFORMED_BIGINT_STRING]: \"`$value` cannot be parsed as a `BigInt`\",\n    [SOLANA_ERROR__MALFORMED_JSON_RPC_ERROR]: \"$message\",\n    [SOLANA_ERROR__MALFORMED_NUMBER_STRING]: \"`$value` cannot be parsed as a `Number`\",\n    [SOLANA_ERROR__NONCE_ACCOUNT_NOT_FOUND]: \"No nonce account could be found at address `$nonceAccountAddress`\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CANNOT_CREATE_SUBSCRIPTION_PLAN]: \"The notification name must end in 'Notifications' and the API must supply a subscription plan creator function for the notification '$notificationName'.\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CLOSED_BEFORE_MESSAGE_BUFFERED]: \"WebSocket was closed before payload could be added to the send buffer\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_CONNECTION_CLOSED]: \"WebSocket connection closed\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__CHANNEL_FAILED_TO_CONNECT]: \"WebSocket failed to connect\",\n    [SOLANA_ERROR__RPC_SUBSCRIPTIONS__EXPECTED_SERVER_SUBSCRIPTION_ID]: \"Failed to obtain a subscription id from the server\",\n    [SOLANA_ERROR__RPC__API_PLAN_MISSING_FOR_RPC_METHOD]: \"Could not find an API plan for RPC method: `$method`\",\n    [SOLANA_ERROR__RPC__INTEGER_OVERFLOW]: \"The $argumentLabel argument to the `$methodName` RPC method$optionalPathLabel was `$value`. This number is unsafe for use with the Solana JSON-RPC because it exceeds `Number.MAX_SAFE_INTEGER`.\",\n    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_ERROR]: \"HTTP error ($statusCode): $message\",\n    [SOLANA_ERROR__RPC__TRANSPORT_HTTP_HEADER_FORBIDDEN]: \"HTTP header(s) forbidden: $headers. Learn more at https://developer.mozilla.org/en-US/docs/Glossary/Forbidden_header_name.\",\n    [SOLANA_ERROR__SIGNER__ADDRESS_CANNOT_HAVE_MULTIPLE_SIGNERS]: \"Multiple distinct signers were identified for address `$address`. Please ensure that you are using the same signer instance for each address.\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_KEY_PAIR_SIGNER]: \"The provided value does not implement the `KeyPairSigner` interface\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_MODIFYING_SIGNER]: \"The provided value does not implement the `MessageModifyingSigner` interface\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_PARTIAL_SIGNER]: \"The provided value does not implement the `MessagePartialSigner` interface\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_MESSAGE_SIGNER]: \"The provided value does not implement any of the `MessageSigner` interfaces\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_MODIFYING_SIGNER]: \"The provided value does not implement the `TransactionModifyingSigner` interface\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_PARTIAL_SIGNER]: \"The provided value does not implement the `TransactionPartialSigner` interface\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SENDING_SIGNER]: \"The provided value does not implement the `TransactionSendingSigner` interface\",\n    [SOLANA_ERROR__SIGNER__EXPECTED_TRANSACTION_SIGNER]: \"The provided value does not implement any of the `TransactionSigner` interfaces\",\n    [SOLANA_ERROR__SIGNER__TRANSACTION_CANNOT_HAVE_MULTIPLE_SENDING_SIGNERS]: \"More than one `TransactionSendingSigner` was identified.\",\n    [SOLANA_ERROR__SIGNER__TRANSACTION_SENDING_SIGNER_MISSING]: \"No `TransactionSendingSigner` was identified. Please provide a valid `TransactionWithSingleSendingSigner` transaction.\",\n    [SOLANA_ERROR__SIGNER__WALLET_MULTISIGN_UNIMPLEMENTED]: \"Wallet account signers do not support signing multiple messages/transactions in a single operation\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__CANNOT_EXPORT_NON_EXTRACTABLE_KEY]: \"Cannot export a non-extractable key.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__DIGEST_UNIMPLEMENTED]: \"No digest implementation could be found.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__DISALLOWED_IN_INSECURE_CONTEXT]: \"Cryptographic operations are only allowed in secure browser contexts. Read more here: https://developer.mozilla.org/en-US/docs/Web/Security/Secure_Contexts.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__ED25519_ALGORITHM_UNIMPLEMENTED]: \"This runtime does not support the generation of Ed25519 key pairs.\\n\\nInstall @solana/webcrypto-ed25519-polyfill and call its `install` function before generating keys in environments that do not support Ed25519.\\n\\nFor a list of runtimes that currently support Ed25519 operations, visit https://github.com/WICG/webcrypto-secure-curves/issues/20.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__EXPORT_FUNCTION_UNIMPLEMENTED]: \"No signature verification implementation could be found.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__GENERATE_FUNCTION_UNIMPLEMENTED]: \"No key generation implementation could be found.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__SIGN_FUNCTION_UNIMPLEMENTED]: \"No signing implementation could be found.\",\n    [SOLANA_ERROR__SUBTLE_CRYPTO__VERIFY_FUNCTION_UNIMPLEMENTED]: \"No key export implementation could be found.\",\n    [SOLANA_ERROR__TIMESTAMP_OUT_OF_RANGE]: \"Timestamp value must be in the range [-(2n ** 63n), (2n ** 63n) - 1]. `$value` given\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_BORROW_OUTSTANDING]: \"Transaction processing left an account with an outstanding borrowed reference\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_IN_USE]: \"Account in use\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_LOADED_TWICE]: \"Account loaded twice\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ACCOUNT_NOT_FOUND]: \"Attempt to debit an account but found no record of a prior credit.\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ADDRESS_LOOKUP_TABLE_NOT_FOUND]: \"Transaction loads an address table account that doesn't exist\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__ALREADY_PROCESSED]: \"This transaction has already been processed\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__BLOCKHASH_NOT_FOUND]: \"Blockhash not found\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__CALL_CHAIN_TOO_DEEP]: \"Loader call chain is too deep\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__CLUSTER_MAINTENANCE]: \"Transactions are currently disabled due to cluster maintenance\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__DUPLICATE_INSTRUCTION]: \"Transaction contains a duplicate instruction ($index) that is not allowed\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_FEE]: \"Insufficient funds for fee\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INSUFFICIENT_FUNDS_FOR_RENT]: \"Transaction results in an account ($accountIndex) with insufficient funds for rent\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_FOR_FEE]: \"This account may not be used to pay transaction fees\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ACCOUNT_INDEX]: \"Transaction contains an invalid account reference\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_DATA]: \"Transaction loads an address table account with invalid data\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_INDEX]: \"Transaction address table lookup uses an invalid index\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_ADDRESS_LOOKUP_TABLE_OWNER]: \"Transaction loads an address table account with an invalid owner\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_LOADED_ACCOUNTS_DATA_SIZE_LIMIT]: \"LoadedAccountsDataSizeLimit set for transaction must be greater than 0.\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_PROGRAM_FOR_EXECUTION]: \"This program may not be used for executing instructions\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_RENT_PAYING_ACCOUNT]: \"Transaction leaves an account with a lower balance than rent-exempt minimum\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__INVALID_WRITABLE_ACCOUNT]: \"Transaction loads a writable account that cannot be written\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__MAX_LOADED_ACCOUNTS_DATA_SIZE_EXCEEDED]: \"Transaction exceeded max loaded accounts data size cap\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__MISSING_SIGNATURE_FOR_FEE]: \"Transaction requires a fee but has no signature present\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_ACCOUNT_NOT_FOUND]: \"Attempt to load a program that does not exist\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__PROGRAM_EXECUTION_TEMPORARILY_RESTRICTED]: \"Execution of the program referenced by account at index $accountIndex is temporarily restricted.\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__RESANITIZATION_NEEDED]: \"ResanitizationNeeded\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__SANITIZE_FAILURE]: \"Transaction failed to sanitize accounts offsets correctly\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__SIGNATURE_FAILURE]: \"Transaction did not pass signature verification\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__TOO_MANY_ACCOUNT_LOCKS]: \"Transaction locked too many accounts\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNBALANCED_TRANSACTION]: \"Sum of account balances before and after transaction do not match\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNKNOWN]: \"The transaction failed with the error `$errorName`\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__UNSUPPORTED_VERSION]: \"Transaction version is unsupported\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_BLOCK_LIMIT]: \"Transaction would exceed account data limit within the block\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_ACCOUNT_DATA_TOTAL_LIMIT]: \"Transaction would exceed total account data limit\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_ACCOUNT_COST_LIMIT]: \"Transaction would exceed max account limit within the block\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_BLOCK_COST_LIMIT]: \"Transaction would exceed max Block Cost Limit\",\n    [SOLANA_ERROR__TRANSACTION_ERROR__WOULD_EXCEED_MAX_VOTE_COST_LIMIT]: \"Transaction would exceed max Vote Cost Limit\",\n    [SOLANA_ERROR__TRANSACTION__ADDRESSES_CANNOT_SIGN_TRANSACTION]: \"Attempted to sign a transaction with an address that is not a signer for it\",\n    [SOLANA_ERROR__TRANSACTION__ADDRESS_MISSING]: \"Transaction is missing an address at index: $index.\",\n    [SOLANA_ERROR__TRANSACTION__CANNOT_ENCODE_WITH_EMPTY_SIGNATURES]: \"Transaction has no expected signers therefore it cannot be encoded\",\n    [SOLANA_ERROR__TRANSACTION__EXCEEDS_SIZE_LIMIT]: \"Transaction size $transactionSize exceeds limit of $transactionSizeLimit bytes\",\n    [SOLANA_ERROR__TRANSACTION__EXPECTED_BLOCKHASH_LIFETIME]: \"Transaction does not have a blockhash lifetime\",\n    [SOLANA_ERROR__TRANSACTION__EXPECTED_NONCE_LIFETIME]: \"Transaction is not a durable nonce transaction\",\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_CONTENTS_MISSING]: \"Contents of these address lookup tables unknown: $lookupTableAddresses\",\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_ADDRESS_LOOKUP_TABLE_INDEX_OUT_OF_RANGE]: \"Lookup of address at index $highestRequestedIndex failed for lookup table `$lookupTableAddress`. Highest known index is $highestKnownIndex. The lookup table may have been extended since its contents were retrieved\",\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_FEE_PAYER_MISSING]: \"No fee payer set in CompiledTransaction\",\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_DECOMPILE_INSTRUCTION_PROGRAM_ADDRESS_NOT_FOUND]: \"Could not find program address at index $index\",\n    [SOLANA_ERROR__TRANSACTION__FAILED_TO_ESTIMATE_COMPUTE_LIMIT]: \"Failed to estimate the compute unit consumption for this transaction message. This is likely because simulating the transaction failed. Inspect the `cause` property of this error to learn more\",\n    [SOLANA_ERROR__TRANSACTION__FAILED_WHEN_SIMULATING_TO_ESTIMATE_COMPUTE_LIMIT]: \"Transaction failed when it was simulated in order to estimate the compute unit consumption. The compute unit estimate provided is for a transaction that failed when simulated and may not be representative of the compute units this transaction would consume if successful. Inspect the `cause` property of this error to learn more\",\n    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_MISSING]: \"Transaction is missing a fee payer.\",\n    [SOLANA_ERROR__TRANSACTION__FEE_PAYER_SIGNATURE_MISSING]: \"Could not determine this transaction's signature. Make sure that the transaction has been signed by its fee payer.\",\n    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_FIRST_INSTRUCTION_MUST_BE_ADVANCE_NONCE]: \"Transaction first instruction is not advance nonce account instruction.\",\n    [SOLANA_ERROR__TRANSACTION__INVALID_NONCE_TRANSACTION_INSTRUCTIONS_MISSING]: \"Transaction with no instructions cannot be durable nonce transaction.\",\n    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_CANNOT_PAY_FEES]: \"This transaction includes an address (`$programAddress`) which is both invoked and set as the fee payer. Program addresses may not pay fees\",\n    [SOLANA_ERROR__TRANSACTION__INVOKED_PROGRAMS_MUST_NOT_BE_WRITABLE]: \"This transaction includes an address (`$programAddress`) which is both invoked and marked writable. Program addresses may not be writable\",\n    [SOLANA_ERROR__TRANSACTION__MESSAGE_SIGNATURES_MISMATCH]: \"The transaction message expected the transaction to have $signerAddressesLength signatures, got $signaturesLength.\",\n    [SOLANA_ERROR__TRANSACTION__SIGNATURES_MISSING]: \"Transaction is missing signatures for addresses: $addresses.\",\n    [SOLANA_ERROR__TRANSACTION__VERSION_NUMBER_OUT_OF_RANGE]: \"Transaction version must be in the range [0, 127]. `$actualVersion` given\"\n  };\n  var START_INDEX = \"i\";\n  var TYPE = \"t\";\n  function getHumanReadableErrorMessage(code, context = {}) {\n    const messageFormatString = SolanaErrorMessages[code];\n    if (messageFormatString.length === 0) {\n      return \"\";\n    }\n    let state;\n    function commitStateUpTo(endIndex) {\n      if (state[TYPE] === 2) {\n        const variableName = messageFormatString.slice(state[START_INDEX] + 1, endIndex);\n        fragments.push(\n          variableName in context ? (\n            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n            `${context[variableName]}`\n          ) : `$${variableName}`\n        );\n      } else if (state[TYPE] === 1) {\n        fragments.push(messageFormatString.slice(state[START_INDEX], endIndex));\n      }\n    }\n    const fragments = [];\n    messageFormatString.split(\"\").forEach((char, ii) => {\n      if (ii === 0) {\n        state = {\n          [START_INDEX]: 0,\n          [TYPE]: messageFormatString[0] === \"\\\\\" ? 0 : messageFormatString[0] === \"$\" ? 2 : 1\n          /* Text */\n        };\n        return;\n      }\n      let nextState;\n      switch (state[TYPE]) {\n        case 0:\n          nextState = {\n            [START_INDEX]: ii,\n            [TYPE]: 1\n            /* Text */\n          };\n          break;\n        case 1:\n          if (char === \"\\\\\") {\n            nextState = {\n              [START_INDEX]: ii,\n              [TYPE]: 0\n              /* EscapeSequence */\n            };\n          } else if (char === \"$\") {\n            nextState = {\n              [START_INDEX]: ii,\n              [TYPE]: 2\n              /* Variable */\n            };\n          }\n          break;\n        case 2:\n          if (char === \"\\\\\") {\n            nextState = {\n              [START_INDEX]: ii,\n              [TYPE]: 0\n              /* EscapeSequence */\n            };\n          } else if (char === \"$\") {\n            nextState = {\n              [START_INDEX]: ii,\n              [TYPE]: 2\n              /* Variable */\n            };\n          } else if (!char.match(/\\w/)) {\n            nextState = {\n              [START_INDEX]: ii,\n              [TYPE]: 1\n              /* Text */\n            };\n          }\n          break;\n      }\n      if (nextState) {\n        if (state !== nextState) {\n          commitStateUpTo(ii);\n        }\n        state = nextState;\n      }\n    });\n    commitStateUpTo();\n    return fragments.join(\"\");\n  }\n  function getErrorMessage(code, context = {}) {\n    if (true) {\n      return getHumanReadableErrorMessage(code, context);\n    } else {\n      let decodingAdviceMessage = `Solana error #${code}; Decode this error by running \\`npx @solana/errors decode -- ${code}`;\n      if (Object.keys(context).length) {\n        decodingAdviceMessage += ` '${encodeContextObject(context)}'`;\n      }\n      return `${decodingAdviceMessage}\\``;\n    }\n  }\n  var SolanaError = class extends Error {\n    /**\n     * Indicates the root cause of this {@link SolanaError}, if any.\n     *\n     * For example, a transaction error might have an instruction error as its root cause. In this\n     * case, you will be able to access the instruction error on the transaction error as `cause`.\n     */\n    cause = this.cause;\n    /**\n     * Contains context that can assist in understanding or recovering from a {@link SolanaError}.\n     */\n    context;\n    constructor(...[code, contextAndErrorOptions]) {\n      let context;\n      let errorOptions;\n      if (contextAndErrorOptions) {\n        const { cause, ...contextRest } = contextAndErrorOptions;\n        if (cause) {\n          errorOptions = { cause };\n        }\n        if (Object.keys(contextRest).length > 0) {\n          context = contextRest;\n        }\n      }\n      const message = getErrorMessage(code, context);\n      super(message, errorOptions);\n      this.context = {\n        __code: code,\n        ...context\n      };\n      this.name = \"SolanaError\";\n    }\n  };\n\n  // ../../../node_modules/.pnpm/@solana+codecs-core@2.3.0_typescript@5.8.3/node_modules/@solana/codecs-core/dist/index.browser.mjs\n  init_dirname();\n  init_buffer2();\n  init_process2();\n  function getEncodedSize(value, encoder) {\n    return \"fixedSize\" in encoder ? encoder.fixedSize : encoder.getSizeFromValue(value);\n  }\n  function createEncoder(encoder) {\n    return Object.freeze({\n      ...encoder,\n      encode: (value) => {\n        const bytes = new Uint8Array(getEncodedSize(value, encoder));\n        encoder.write(value, bytes, 0);\n        return bytes;\n      }\n    });\n  }\n  function createDecoder(decoder) {\n    return Object.freeze({\n      ...decoder,\n      decode: (bytes, offset2 = 0) => decoder.read(bytes, offset2)[0]\n    });\n  }\n  function isFixedSize(codec) {\n    return \"fixedSize\" in codec && typeof codec.fixedSize === \"number\";\n  }\n  function combineCodec(encoder, decoder) {\n    if (isFixedSize(encoder) !== isFixedSize(decoder)) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_SIZE_COMPATIBILITY_MISMATCH);\n    }\n    if (isFixedSize(encoder) && isFixedSize(decoder) && encoder.fixedSize !== decoder.fixedSize) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_FIXED_SIZE_MISMATCH, {\n        decoderFixedSize: decoder.fixedSize,\n        encoderFixedSize: encoder.fixedSize\n      });\n    }\n    if (!isFixedSize(encoder) && !isFixedSize(decoder) && encoder.maxSize !== decoder.maxSize) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__ENCODER_DECODER_MAX_SIZE_MISMATCH, {\n        decoderMaxSize: decoder.maxSize,\n        encoderMaxSize: encoder.maxSize\n      });\n    }\n    return {\n      ...decoder,\n      ...encoder,\n      decode: decoder.decode,\n      encode: encoder.encode,\n      read: decoder.read,\n      write: encoder.write\n    };\n  }\n  function assertByteArrayIsNotEmptyForCodec(codecDescription, bytes, offset2 = 0) {\n    if (bytes.length - offset2 <= 0) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__CANNOT_DECODE_EMPTY_BYTE_ARRAY, {\n        codecDescription\n      });\n    }\n  }\n  function assertByteArrayHasEnoughBytesForCodec(codecDescription, expected, bytes, offset2 = 0) {\n    const bytesLength = bytes.length - offset2;\n    if (bytesLength < expected) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__INVALID_BYTE_LENGTH, {\n        bytesLength,\n        codecDescription,\n        expected\n      });\n    }\n  }\n\n  // ../../../node_modules/.pnpm/@solana+codecs-numbers@2.3.0_typescript@5.8.3/node_modules/@solana/codecs-numbers/dist/index.browser.mjs\n  function assertNumberIsBetweenForCodec(codecDescription, min, max, value) {\n    if (value < min || value > max) {\n      throw new SolanaError(SOLANA_ERROR__CODECS__NUMBER_OUT_OF_RANGE, {\n        codecDescription,\n        max,\n        min,\n        value\n      });\n    }\n  }\n  function isLittleEndian(config) {\n    return config?.endian === 1 ? false : true;\n  }\n  function numberEncoderFactory(input) {\n    return createEncoder({\n      fixedSize: input.size,\n      write(value, bytes, offset2) {\n        if (input.range) {\n          assertNumberIsBetweenForCodec(input.name, input.range[0], input.range[1], value);\n        }\n        const arrayBuffer = new ArrayBuffer(input.size);\n        input.set(new DataView(arrayBuffer), value, isLittleEndian(input.config));\n        bytes.set(new Uint8Array(arrayBuffer), offset2);\n        return offset2 + input.size;\n      }\n    });\n  }\n  function numberDecoderFactory(input) {\n    return createDecoder({\n      fixedSize: input.size,\n      read(bytes, offset2 = 0) {\n        assertByteArrayIsNotEmptyForCodec(input.name, bytes, offset2);\n        assertByteArrayHasEnoughBytesForCodec(input.name, input.size, bytes, offset2);\n        const view = new DataView(toArrayBuffer(bytes, offset2, input.size));\n        return [input.get(view, isLittleEndian(input.config)), offset2 + input.size];\n      }\n    });\n  }\n  function toArrayBuffer(bytes, offset2, length) {\n    const bytesOffset = bytes.byteOffset + (offset2 ?? 0);\n    const bytesLength = length ?? bytes.byteLength;\n    return bytes.buffer.slice(bytesOffset, bytesOffset + bytesLength);\n  }\n  var getU64Encoder = (config = {}) => numberEncoderFactory({\n    config,\n    name: \"u64\",\n    range: [0n, BigInt(\"0xffffffffffffffff\")],\n    set: (view, value, le) => view.setBigUint64(0, BigInt(value), le),\n    size: 8\n  });\n  var getU64Decoder = (config = {}) => numberDecoderFactory({\n    config,\n    get: (view, le) => view.getBigUint64(0, le),\n    name: \"u64\",\n    size: 8\n  });\n  var getU64Codec = (config = {}) => combineCodec(getU64Encoder(config), getU64Decoder(config));\n\n  // ../../../node_modules/.pnpm/superstruct@2.0.2/node_modules/superstruct/dist/index.mjs\n  init_dirname();\n  init_buffer2();\n  init_process2();\n  var StructError = class extends TypeError {\n    constructor(failure, failures) {\n      let cached;\n      const { message, explanation, ...rest } = failure;\n      const { path } = failure;\n      const msg = path.length === 0 ? message : `At path: ${path.join(\".\")} -- ${message}`;\n      super(explanation ?? msg);\n      if (explanation != null)\n        this.cause = msg;\n      Object.assign(this, rest);\n      this.name = this.constructor.name;\n      this.failures = () => {\n        return cached ?? (cached = [failure, ...failures()]);\n      };\n    }\n  };\n  function isIterable(x) {\n    return isObject(x) && typeof x[Symbol.iterator] === \"function\";\n  }\n  function isObject(x) {\n    return typeof x === \"object\" && x != null;\n  }\n  function isNonArrayObject(x) {\n    return isObject(x) && !Array.isArray(x);\n  }\n  function print(value) {\n    if (typeof value === \"symbol\") {\n      return value.toString();\n    }\n    return typeof value === \"string\" ? JSON.stringify(value) : `${value}`;\n  }\n  function shiftIterator(input) {\n    const { done, value } = input.next();\n    return done ? void 0 : value;\n  }\n  function toFailure(result, context, struct2, value) {\n    if (result === true) {\n      return;\n    } else if (result === false) {\n      result = {};\n    } else if (typeof result === \"string\") {\n      result = { message: result };\n    }\n    const { path, branch } = context;\n    const { type: type2 } = struct2;\n    const { refinement, message = `Expected a value of type \\`${type2}\\`${refinement ? ` with refinement \\`${refinement}\\`` : \"\"}, but received: \\`${print(value)}\\`` } = result;\n    return {\n      value,\n      type: type2,\n      refinement,\n      key: path[path.length - 1],\n      path,\n      branch,\n      ...result,\n      message\n    };\n  }\n  function* toFailures(result, context, struct2, value) {\n    if (!isIterable(result)) {\n      result = [result];\n    }\n    for (const r of result) {\n      const failure = toFailure(r, context, struct2, value);\n      if (failure) {\n        yield failure;\n      }\n    }\n  }\n  function* run(value, struct2, options = {}) {\n    const { path = [], branch = [value], coerce: coerce2 = false, mask: mask2 = false } = options;\n    const ctx = { path, branch, mask: mask2 };\n    if (coerce2) {\n      value = struct2.coercer(value, ctx);\n    }\n    let status = \"valid\";\n    for (const failure of struct2.validator(value, ctx)) {\n      failure.explanation = options.message;\n      status = \"not_valid\";\n      yield [failure, void 0];\n    }\n    for (let [k, v, s] of struct2.entries(value, ctx)) {\n      const ts = run(v, s, {\n        path: k === void 0 ? path : [...path, k],\n        branch: k === void 0 ? branch : [...branch, v],\n        coerce: coerce2,\n        mask: mask2,\n        message: options.message\n      });\n      for (const t of ts) {\n        if (t[0]) {\n          status = t[0].refinement != null ? \"not_refined\" : \"not_valid\";\n          yield [t[0], void 0];\n        } else if (coerce2) {\n          v = t[1];\n          if (k === void 0) {\n            value = v;\n          } else if (value instanceof Map) {\n            value.set(k, v);\n          } else if (value instanceof Set) {\n            value.add(v);\n          } else if (isObject(value)) {\n            if (v !== void 0 || k in value)\n              value[k] = v;\n          }\n        }\n      }\n    }\n    if (status !== \"not_valid\") {\n      for (const failure of struct2.refiner(value, ctx)) {\n        failure.explanation = options.message;\n        status = \"not_refined\";\n        yield [failure, void 0];\n      }\n    }\n    if (status === \"valid\") {\n      yield [void 0, value];\n    }\n  }\n  var Struct = class {\n    constructor(props) {\n      const { type: type2, schema, validator, refiner, coercer = (value) => value, entries = function* () {\n      } } = props;\n      this.type = type2;\n      this.schema = schema;\n      this.entries = entries;\n      this.coercer = coercer;\n      if (validator) {\n        this.validator = (value, context) => {\n          const result = validator(value, context);\n          return toFailures(result, context, this, value);\n        };\n      } else {\n        this.validator = () => [];\n      }\n      if (refiner) {\n        this.refiner = (value, context) => {\n          const result = refiner(value, context);\n          return toFailures(result, context, this, value);\n        };\n      } else {\n        this.refiner = () => [];\n      }\n    }\n    /**\n     * Assert that a value passes the struct's validation, throwing if it doesn't.\n     */\n    assert(value, message) {\n      return assert(value, this, message);\n    }\n    /**\n     * Create a value with the struct's coercion logic, then validate it.\n     */\n    create(value, message) {\n      return create(value, this, message);\n    }\n    /**\n     * Check if a value passes the struct's validation.\n     */\n    is(value) {\n      return is(value, this);\n    }\n    /**\n     * Mask a value, coercing and validating it, but returning only the subset of\n     * properties defined by the struct's schema. Masking applies recursively to\n     * props of `object` structs only.\n     */\n    mask(value, message) {\n      return mask(value, this, message);\n    }\n    /**\n     * Validate a value with the struct's validation logic, returning a tuple\n     * representing the result.\n     *\n     * You may optionally pass `true` for the `coerce` argument to coerce\n     * the value before attempting to validate it. If you do, the result will\n     * contain the coerced result when successful. Also, `mask` will turn on\n     * masking of the unknown `object` props recursively if passed.\n     */\n    validate(value, options = {}) {\n      return validate(value, this, options);\n    }\n  };\n  function assert(value, struct2, message) {\n    const result = validate(value, struct2, { message });\n    if (result[0]) {\n      throw result[0];\n    }\n  }\n  function create(value, struct2, message) {\n    const result = validate(value, struct2, { coerce: true, message });\n    if (result[0]) {\n      throw result[0];\n    } else {\n      return result[1];\n    }\n  }\n  function mask(value, struct2, message) {\n    const result = validate(value, struct2, { coerce: true, mask: true, message });\n    if (result[0]) {\n      throw result[0];\n    } else {\n      return result[1];\n    }\n  }\n  function is(value, struct2) {\n    const result = validate(value, struct2);\n    return !result[0];\n  }\n  function validate(value, struct2, options = {}) {\n    const tuples = run(value, struct2, options);\n    const tuple2 = shiftIterator(tuples);\n    if (tuple2[0]) {\n      const error = new StructError(tuple2[0], function* () {\n        for (const t of tuples) {\n          if (t[0]) {\n            yield t[0];\n          }\n        }\n      });\n      return [error, void 0];\n    } else {\n      const v = tuple2[1];\n      return [void 0, v];\n    }\n  }\n  function define(name, validator) {\n    return new Struct({ type: name, schema: null, validator });\n  }\n  function any() {\n    return define(\"any\", () => true);\n  }\n  function array(Element) {\n    return new Struct({\n      type: \"array\",\n      schema: Element,\n      *entries(value) {\n        if (Element && Array.isArray(value)) {\n          for (const [i, v] of value.entries()) {\n            yield [i, v, Element];\n          }\n        }\n      },\n      coercer(value) {\n        return Array.isArray(value) ? value.slice() : value;\n      },\n      validator(value) {\n        return Array.isArray(value) || `Expected an array value, but received: ${print(value)}`;\n      }\n    });\n  }\n  function boolean() {\n    return define(\"boolean\", (value) => {\n      return typeof value === \"boolean\";\n    });\n  }\n  function instance(Class) {\n    return define(\"instance\", (value) => {\n      return value instanceof Class || `Expected a \\`${Class.name}\\` instance, but received: ${print(value)}`;\n    });\n  }\n  function literal(constant) {\n    const description = print(constant);\n    const t = typeof constant;\n    return new Struct({\n      type: \"literal\",\n      schema: t === \"string\" || t === \"number\" || t === \"boolean\" ? constant : null,\n      validator(value) {\n        return value === constant || `Expected the literal \\`${description}\\`, but received: ${print(value)}`;\n      }\n    });\n  }\n  function never() {\n    return define(\"never\", () => false);\n  }\n  function nullable(struct2) {\n    return new Struct({\n      ...struct2,\n      validator: (value, ctx) => value === null || struct2.validator(value, ctx),\n      refiner: (value, ctx) => value === null || struct2.refiner(value, ctx)\n    });\n  }\n  function number() {\n    return define(\"number\", (value) => {\n      return typeof value === \"number\" && !isNaN(value) || `Expected a number, but received: ${print(value)}`;\n    });\n  }\n  function optional(struct2) {\n    return new Struct({\n      ...struct2,\n      validator: (value, ctx) => value === void 0 || struct2.validator(value, ctx),\n      refiner: (value, ctx) => value === void 0 || struct2.refiner(value, ctx)\n    });\n  }\n  function record(Key, Value) {\n    return new Struct({\n      type: \"record\",\n      schema: null,\n      *entries(value) {\n        if (isObject(value)) {\n          for (const k in value) {\n            const v = value[k];\n            yield [k, k, Key];\n            yield [k, v, Value];\n          }\n        }\n      },\n      validator(value) {\n        return isNonArrayObject(value) || `Expected an object, but received: ${print(value)}`;\n      },\n      coercer(value) {\n        return isNonArrayObject(value) ? { ...value } : value;\n      }\n    });\n  }\n  function string() {\n    return define(\"string\", (value) => {\n      return typeof value === \"string\" || `Expected a string, but received: ${print(value)}`;\n    });\n  }\n  function tuple(Structs) {\n    const Never = never();\n    return new Struct({\n      type: \"tuple\",\n      schema: null,\n      *entries(value) {\n        if (Array.isArray(value)) {\n          const length = Math.max(Structs.length, value.length);\n          for (let i = 0; i < length; i++) {\n            yield [i, value[i], Structs[i] || Never];\n          }\n        }\n      },\n      validator(value) {\n        return Array.isArray(value) || `Expected an array, but received: ${print(value)}`;\n      },\n      coercer(value) {\n        return Array.isArray(value) ? value.slice() : value;\n      }\n    });\n  }\n  function type(schema) {\n    const keys = Object.keys(schema);\n    return new Struct({\n      type: \"type\",\n      schema,\n      *entries(value) {\n        if (isObject(value)) {\n          for (const k of keys) {\n            yield [k, value[k], schema[k]];\n          }\n        }\n      },\n      validator(value) {\n        return isNonArrayObject(value) || `Expected an object, but received: ${print(value)}`;\n      },\n      coercer(value) {\n        return isNonArrayObject(value) ? { ...value } : value;\n      }\n    });\n  }\n  function union(Structs) {\n    const description = Structs.map((s) => s.type).join(\" | \");\n    return new Struct({\n      type: \"union\",\n      schema: null,\n      coercer(value, ctx) {\n        for (const S of Structs) {\n          const [error, coerced] = S.validate(value, {\n            coerce: true,\n            mask: ctx.mask\n          });\n          if (!error) {\n            return coerced;\n          }\n        }\n        return value;\n      },\n      validator(value, ctx) {\n        const failures = [];\n        for (const S of Structs) {\n          const [...tuples] = run(value, S, ctx);\n          const [first] = tuples;\n          if (!first[0]) {\n            return [];\n          } else {\n            for (const [failure] of tuples) {\n              if (failure) {\n                failures.push(failure);\n              }\n            }\n          }\n        }\n        return [\n          `Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(value)}`,\n          ...failures\n        ];\n      }\n    });\n  }\n  function unknown() {\n    return define(\"unknown\", () => true);\n  }\n  function coerce(struct2, condition, coercer) {\n    return new Struct({\n      ...struct2,\n      coercer: (value, ctx) => {\n        return is(value, condition) ? struct2.coercer(coercer(value, ctx), ctx) : struct2.coercer(value, ctx);\n      }\n    });\n  }\n\n  // ../../../node_modules/.pnpm/@solana+web3.js@1.98.4_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10/node_modules/@solana/web3.js/lib/index.browser.esm.js\n  var import_browser = __toESM(require_browser());\n\n  // ../../../node_modules/.pnpm/rpc-websockets@9.2.0/node_modules/rpc-websockets/dist/index.browser.mjs\n  init_dirname();\n  init_buffer2();\n  init_process2();\n  init_buffer();\n\n  // ../../../node_modules/.pnpm/eventemitter3@5.0.1/node_modules/eventemitter3/index.mjs\n  init_dirname();\n  init_buffer2();\n  init_process2();\n  var import_index = __toESM(require_eventemitter3(), 1);\n\n  // ../../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/sha3.js\n  init_dirname();\n  init_buffer2();\n  init_process2();\n  var _0n6 = BigInt(0);\n  var _1n6 = BigInt(1);\n  var _2n4 = BigInt(2);\n  var _7n2 = BigInt(7);\n  var _256n = BigInt(256);\n  var _0x71n = BigInt(113);\n  var SHA3_PI = [];\n  var SHA3_ROTL = [];\n  var _SHA3_IOTA = [];\n  for (let round = 0, R = _1n6, x = 1, y = 0; round < 24; round++) {\n    [x, y] = [y, (2 * x + 3 * y) % 5];\n    SHA3_PI.push(2 * (5 * y + x));\n    SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);\n    let t = _0n6;\n    for (let j = 0; j < 7; j++) {\n      R = (R << _1n6 ^ (R >> _7n2) * _0x71n) % _256n;\n      if (R & _2n4)\n        t ^= _1n6 << (_1n6 << /* @__PURE__ */ BigInt(j)) - _1n6;\n    }\n    _SHA3_IOTA.push(t);\n  }\n  var IOTAS = split(_SHA3_IOTA, true);\n  var SHA3_IOTA_H = IOTAS[0];\n  var SHA3_IOTA_L = IOTAS[1];\n  var rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);\n  var rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);\n  function keccakP(s, rounds = 24) {\n    const B = new Uint32Array(5 * 2);\n    for (let round = 24 - rounds; round < 24; round++) {\n      for (let x = 0; x < 10; x++)\n        B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];\n      for (let x = 0; x < 10; x += 2) {\n        const idx1 = (x + 8) % 10;\n        const idx0 = (x + 2) % 10;\n        const B0 = B[idx0];\n        const B1 = B[idx0 + 1];\n        const Th = rotlH(B0, B1, 1) ^ B[idx1];\n        const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];\n        for (let y = 0; y < 50; y += 10) {\n          s[x + y] ^= Th;\n          s[x + y + 1] ^= Tl;\n        }\n      }\n      let curH = s[2];\n      let curL = s[3];\n      for (let t = 0; t < 24; t++) {\n        const shift = SHA3_ROTL[t];\n        const Th = rotlH(curH, curL, shift);\n        const Tl = rotlL(curH, curL, shift);\n        const PI = SHA3_PI[t];\n        curH = s[PI];\n        curL = s[PI + 1];\n        s[PI] = Th;\n        s[PI + 1] = Tl;\n      }\n      for (let y = 0; y < 50; y += 10) {\n        for (let x = 0; x < 10; x++)\n          B[x] = s[y + x];\n        for (let x = 0; x < 10; x++)\n          s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];\n      }\n      s[0] ^= SHA3_IOTA_H[round];\n      s[1] ^= SHA3_IOTA_L[round];\n    }\n    clean(B);\n  }\n  var Keccak = class _Keccak extends Hash {\n    // NOTE: we accept arguments in bytes instead of bits here.\n    constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {\n      super();\n      this.pos = 0;\n      this.posOut = 0;\n      this.finished = false;\n      this.destroyed = false;\n      this.enableXOF = false;\n      this.blockLen = blockLen;\n      this.suffix = suffix;\n      this.outputLen = outputLen;\n      this.enableXOF = enableXOF;\n      this.rounds = rounds;\n      anumber(outputLen);\n      if (!(0 < blockLen && blockLen < 200))\n        throw new Error(\"only keccak-f1600 function is supported\");\n      this.state = new Uint8Array(200);\n      this.state32 = u32(this.state);\n    }\n    clone() {\n      return this._cloneInto();\n    }\n    keccak() {\n      swap32IfBE(this.state32);\n      keccakP(this.state32, this.rounds);\n      swap32IfBE(this.state32);\n      this.posOut = 0;\n      this.pos = 0;\n    }\n    update(data) {\n      aexists(this);\n      data = toBytes(data);\n      abytes(data);\n      const { blockLen, state } = this;\n      const len = data.length;\n      for (let pos = 0; pos < len; ) {\n        const take = Math.min(blockLen - this.pos, len - pos);\n        for (let i = 0; i < take; i++)\n          state[this.pos++] ^= data[pos++];\n        if (this.pos === blockLen)\n          this.keccak();\n      }\n      return this;\n    }\n    finish() {\n      if (this.finished)\n        return;\n      this.finished = true;\n      const { state, suffix, pos, blockLen } = this;\n      state[pos] ^= suffix;\n      if ((suffix & 128) !== 0 && pos === blockLen - 1)\n        this.keccak();\n      state[blockLen - 1] ^= 128;\n      this.keccak();\n    }\n    writeInto(out) {\n      aexists(this, false);\n      abytes(out);\n      this.finish();\n      const bufferOut = this.state;\n      const { blockLen } = this;\n      for (let pos = 0, len = out.length; pos < len; ) {\n        if (this.posOut >= blockLen)\n          this.keccak();\n        const take = Math.min(blockLen - this.posOut, len - pos);\n        out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);\n        this.posOut += take;\n        pos += take;\n      }\n      return out;\n    }\n    xofInto(out) {\n      if (!this.enableXOF)\n        throw new Error(\"XOF is not possible for this instance\");\n      return this.writeInto(out);\n    }\n    xof(bytes) {\n      anumber(bytes);\n      return this.xofInto(new Uint8Array(bytes));\n    }\n    digestInto(out) {\n      aoutput(out, this);\n      if (this.finished)\n        throw new Error(\"digest() was already called\");\n      this.writeInto(out);\n      this.destroy();\n      return out;\n    }\n    digest() {\n      return this.digestInto(new Uint8Array(this.outputLen));\n    }\n    destroy() {\n      this.destroyed = true;\n      clean(this.state);\n    }\n    _cloneInto(to) {\n      const { blockLen, suffix, outputLen, rounds, enableXOF } = this;\n      to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));\n      to.state32.set(this.state32);\n      to.pos = this.pos;\n      to.posOut = this.posOut;\n      to.finished = this.finished;\n      to.rounds = rounds;\n      to.suffix = suffix;\n      to.outputLen = outputLen;\n      to.enableXOF = enableXOF;\n      to.destroyed = this.destroyed;\n      return to;\n    }\n  };\n  var gen = (suffix, blockLen, outputLen) => createHasher(() => new Keccak(blockLen, suffix, outputLen));\n  var keccak_256 = /* @__PURE__ */ (() => gen(1, 136, 256 / 8))();\n\n  // ../../../node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/secp256k1.js\n  init_dirname();\n  init_buffer2();\n  init_process2();\n\n  // ../../../node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/_shortw_utils.js\n  init_dirname();\n  init_buffer2();\n  init_process2();\n\n  // ../../../node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/weierstrass.js\n  init_dirname();\n  init_buffer2();\n  init_process2();\n\n  // ../../../node_modules/.pnpm/@noble+hashes@1.8.0/node_modules/@noble/hashes/esm/hmac.js\n  init_dirname();\n  init_buffer2();\n  init_process2();\n  var HMAC = class extends Hash {\n    constructor(hash, _key) {\n      super();\n      this.finished = false;\n      this.destroyed = false;\n      ahash(hash);\n      const key = toBytes(_key);\n      this.iHash = hash.create();\n      if (typeof this.iHash.update !== \"function\")\n        throw new Error(\"Expected instance of class which extends utils.Hash\");\n      this.blockLen = this.iHash.blockLen;\n      this.outputLen = this.iHash.outputLen;\n      const blockLen = this.blockLen;\n      const pad = new Uint8Array(blockLen);\n      pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n      for (let i = 0; i < pad.length; i++)\n        pad[i] ^= 54;\n      this.iHash.update(pad);\n      this.oHash = hash.create();\n      for (let i = 0; i < pad.length; i++)\n        pad[i] ^= 54 ^ 92;\n      this.oHash.update(pad);\n      clean(pad);\n    }\n    update(buf) {\n      aexists(this);\n      this.iHash.update(buf);\n      return this;\n    }\n    digestInto(out) {\n      aexists(this);\n      abytes(out, this.outputLen);\n      this.finished = true;\n      this.iHash.digestInto(out);\n      this.oHash.update(out);\n      this.oHash.digestInto(out);\n      this.destroy();\n    }\n    digest() {\n      const out = new Uint8Array(this.oHash.outputLen);\n      this.digestInto(out);\n      return out;\n    }\n    _cloneInto(to) {\n      to || (to = Object.create(Object.getPrototypeOf(this), {}));\n      const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n      to = to;\n      to.finished = finished;\n      to.destroyed = destroyed;\n      to.blockLen = blockLen;\n      to.outputLen = outputLen;\n      to.oHash = oHash._cloneInto(to.oHash);\n      to.iHash = iHash._cloneInto(to.iHash);\n      return to;\n    }\n    clone() {\n      return this._cloneInto();\n    }\n    destroy() {\n      this.destroyed = true;\n      this.oHash.destroy();\n      this.iHash.destroy();\n    }\n  };\n  var hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();\n  hmac.create = (hash, key) => new HMAC(hash, key);\n\n  // ../../../node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/abstract/weierstrass.js\n  var divNearest = (num, den) => (num + (num >= 0 ? den : -den) / _2n5) / den;\n  function _splitEndoScalar(k, basis, n) {\n    const [[a1, b1], [a2, b2]] = basis;\n    const c1 = divNearest(b2 * k, n);\n    const c2 = divNearest(-b1 * k, n);\n    let k1 = k - c1 * a1 - c2 * a2;\n    let k2 = -c1 * b1 - c2 * b2;\n    const k1neg = k1 < _0n7;\n    const k2neg = k2 < _0n7;\n    if (k1neg)\n      k1 = -k1;\n    if (k2neg)\n      k2 = -k2;\n    const MAX_NUM = bitMask(Math.ceil(bitLen(n) / 2)) + _1n7;\n    if (k1 < _0n7 || k1 >= MAX_NUM || k2 < _0n7 || k2 >= MAX_NUM) {\n      throw new Error(\"splitScalar (endomorphism): failed, k=\" + k);\n    }\n    return { k1neg, k1, k2neg, k2 };\n  }\n  function validateSigFormat(format) {\n    if (![\"compact\", \"recovered\", \"der\"].includes(format))\n      throw new Error('Signature format must be \"compact\", \"recovered\", or \"der\"');\n    return format;\n  }\n  function validateSigOpts(opts, def) {\n    const optsn = {};\n    for (let optName of Object.keys(def)) {\n      optsn[optName] = opts[optName] === void 0 ? def[optName] : opts[optName];\n    }\n    _abool2(optsn.lowS, \"lowS\");\n    _abool2(optsn.prehash, \"prehash\");\n    if (optsn.format !== void 0)\n      validateSigFormat(optsn.format);\n    return optsn;\n  }\n  var DERErr = class extends Error {\n    constructor(m = \"\") {\n      super(m);\n    }\n  };\n  var DER = {\n    // asn.1 DER encoding utils\n    Err: DERErr,\n    // Basic building block is TLV (Tag-Length-Value)\n    _tlv: {\n      encode: (tag, data) => {\n        const { Err: E } = DER;\n        if (tag < 0 || tag > 256)\n          throw new E(\"tlv.encode: wrong tag\");\n        if (data.length & 1)\n          throw new E(\"tlv.encode: unpadded data\");\n        const dataLen = data.length / 2;\n        const len = numberToHexUnpadded(dataLen);\n        if (len.length / 2 & 128)\n          throw new E(\"tlv.encode: long form length too big\");\n        const lenLen = dataLen > 127 ? numberToHexUnpadded(len.length / 2 | 128) : \"\";\n        const t = numberToHexUnpadded(tag);\n        return t + lenLen + len + data;\n      },\n      // v - value, l - left bytes (unparsed)\n      decode(tag, data) {\n        const { Err: E } = DER;\n        let pos = 0;\n        if (tag < 0 || tag > 256)\n          throw new E(\"tlv.encode: wrong tag\");\n        if (data.length < 2 || data[pos++] !== tag)\n          throw new E(\"tlv.decode: wrong tlv\");\n        const first = data[pos++];\n        const isLong = !!(first & 128);\n        let length = 0;\n        if (!isLong)\n          length = first;\n        else {\n          const lenLen = first & 127;\n          if (!lenLen)\n            throw new E(\"tlv.decode(long): indefinite length not supported\");\n          if (lenLen > 4)\n            throw new E(\"tlv.decode(long): byte length is too big\");\n          const lengthBytes = data.subarray(pos, pos + lenLen);\n          if (lengthBytes.length !== lenLen)\n            throw new E(\"tlv.decode: length bytes not complete\");\n          if (lengthBytes[0] === 0)\n            throw new E(\"tlv.decode(long): zero leftmost byte\");\n          for (const b of lengthBytes)\n            length = length << 8 | b;\n          pos += lenLen;\n          if (length < 128)\n            throw new E(\"tlv.decode(long): not minimal encoding\");\n        }\n        const v = data.subarray(pos, pos + length);\n        if (v.length !== length)\n          throw new E(\"tlv.decode: wrong value length\");\n        return { v, l: data.subarray(pos + length) };\n      }\n    },\n    // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n    // since we always use positive integers here. It must always be empty:\n    // - add zero byte if exists\n    // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n    _int: {\n      encode(num) {\n        const { Err: E } = DER;\n        if (num < _0n7)\n          throw new E(\"integer: negative integers are not allowed\");\n        let hex = numberToHexUnpadded(num);\n        if (Number.parseInt(hex[0], 16) & 8)\n          hex = \"00\" + hex;\n        if (hex.length & 1)\n          throw new E(\"unexpected DER parsing assertion: unpadded hex\");\n        return hex;\n      },\n      decode(data) {\n        const { Err: E } = DER;\n        if (data[0] & 128)\n          throw new E(\"invalid signature integer: negative\");\n        if (data[0] === 0 && !(data[1] & 128))\n          throw new E(\"invalid signature integer: unnecessary leading zero\");\n        return bytesToNumberBE(data);\n      }\n    },\n    toSig(hex) {\n      const { Err: E, _int: int, _tlv: tlv } = DER;\n      const data = ensureBytes(\"signature\", hex);\n      const { v: seqBytes, l: seqLeftBytes } = tlv.decode(48, data);\n      if (seqLeftBytes.length)\n        throw new E(\"invalid signature: left bytes after parsing\");\n      const { v: rBytes, l: rLeftBytes } = tlv.decode(2, seqBytes);\n      const { v: sBytes, l: sLeftBytes } = tlv.decode(2, rLeftBytes);\n      if (sLeftBytes.length)\n        throw new E(\"invalid signature: left bytes after parsing\");\n      return { r: int.decode(rBytes), s: int.decode(sBytes) };\n    },\n    hexFromSig(sig) {\n      const { _tlv: tlv, _int: int } = DER;\n      const rs = tlv.encode(2, int.encode(sig.r));\n      const ss = tlv.encode(2, int.encode(sig.s));\n      const seq2 = rs + ss;\n      return tlv.encode(48, seq2);\n    }\n  };\n  var _0n7 = BigInt(0);\n  var _1n7 = BigInt(1);\n  var _2n5 = BigInt(2);\n  var _3n3 = BigInt(3);\n  var _4n2 = BigInt(4);\n  function _normFnElement(Fn2, key) {\n    const { BYTES: expected } = Fn2;\n    let num;\n    if (typeof key === \"bigint\") {\n      num = key;\n    } else {\n      let bytes = ensureBytes(\"private key\", key);\n      try {\n        num = Fn2.fromBytes(bytes);\n      } catch (error) {\n        throw new Error(`invalid private key: expected ui8a of size ${expected}, got ${typeof key}`);\n      }\n    }\n    if (!Fn2.isValidNot0(num))\n      throw new Error(\"invalid private key: out of range [1..N-1]\");\n    return num;\n  }\n  function weierstrassN(params, extraOpts = {}) {\n    const validated = _createCurveFields(\"weierstrass\", params, extraOpts);\n    const { Fp: Fp2, Fn: Fn2 } = validated;\n    let CURVE = validated.CURVE;\n    const { h: cofactor, n: CURVE_ORDER } = CURVE;\n    _validateObject(extraOpts, {}, {\n      allowInfinityPoint: \"boolean\",\n      clearCofactor: \"function\",\n      isTorsionFree: \"function\",\n      fromBytes: \"function\",\n      toBytes: \"function\",\n      endo: \"object\",\n      wrapPrivateKey: \"boolean\"\n    });\n    const { endo } = extraOpts;\n    if (endo) {\n      if (!Fp2.is0(CURVE.a) || typeof endo.beta !== \"bigint\" || !Array.isArray(endo.basises)) {\n        throw new Error('invalid endo: expected \"beta\": bigint and \"basises\": array');\n      }\n    }\n    const lengths = getWLengths(Fp2, Fn2);\n    function assertCompressionIsSupported() {\n      if (!Fp2.isOdd)\n        throw new Error(\"compression is not supported: Field does not have .isOdd()\");\n    }\n    function pointToBytes(_c, point, isCompressed) {\n      const { x, y } = point.toAffine();\n      const bx = Fp2.toBytes(x);\n      _abool2(isCompressed, \"isCompressed\");\n      if (isCompressed) {\n        assertCompressionIsSupported();\n        const hasEvenY = !Fp2.isOdd(y);\n        return concatBytes(pprefix(hasEvenY), bx);\n      } else {\n        return concatBytes(Uint8Array.of(4), bx, Fp2.toBytes(y));\n      }\n    }\n    function pointFromBytes(bytes) {\n      _abytes2(bytes, void 0, \"Point\");\n      const { publicKey: comp, publicKeyUncompressed: uncomp } = lengths;\n      const length = bytes.length;\n      const head = bytes[0];\n      const tail = bytes.subarray(1);\n      if (length === comp && (head === 2 || head === 3)) {\n        const x = Fp2.fromBytes(tail);\n        if (!Fp2.isValid(x))\n          throw new Error(\"bad point: is not on curve, wrong x\");\n        const y2 = weierstrassEquation(x);\n        let y;\n        try {\n          y = Fp2.sqrt(y2);\n        } catch (sqrtError) {\n          const err = sqrtError instanceof Error ? \": \" + sqrtError.message : \"\";\n          throw new Error(\"bad point: is not on curve, sqrt error\" + err);\n        }\n        assertCompressionIsSupported();\n        const isYOdd = Fp2.isOdd(y);\n        const isHeadOdd = (head & 1) === 1;\n        if (isHeadOdd !== isYOdd)\n          y = Fp2.neg(y);\n        return { x, y };\n      } else if (length === uncomp && head === 4) {\n        const L = Fp2.BYTES;\n        const x = Fp2.fromBytes(tail.subarray(0, L));\n        const y = Fp2.fromBytes(tail.subarray(L, L * 2));\n        if (!isValidXY(x, y))\n          throw new Error(\"bad point: is not on curve\");\n        return { x, y };\n      } else {\n        throw new Error(`bad point: got length ${length}, expected compressed=${comp} or uncompressed=${uncomp}`);\n      }\n    }\n    const encodePoint = extraOpts.toBytes || pointToBytes;\n    const decodePoint = extraOpts.fromBytes || pointFromBytes;\n    function weierstrassEquation(x) {\n      const x2 = Fp2.sqr(x);\n      const x3 = Fp2.mul(x2, x);\n      return Fp2.add(Fp2.add(x3, Fp2.mul(x, CURVE.a)), CURVE.b);\n    }\n    function isValidXY(x, y) {\n      const left = Fp2.sqr(y);\n      const right = weierstrassEquation(x);\n      return Fp2.eql(left, right);\n    }\n    if (!isValidXY(CURVE.Gx, CURVE.Gy))\n      throw new Error(\"bad curve params: generator point\");\n    const _4a3 = Fp2.mul(Fp2.pow(CURVE.a, _3n3), _4n2);\n    const _27b2 = Fp2.mul(Fp2.sqr(CURVE.b), BigInt(27));\n    if (Fp2.is0(Fp2.add(_4a3, _27b2)))\n      throw new Error(\"bad curve params: a or b\");\n    function acoord(title, n, banZero = false) {\n      if (!Fp2.isValid(n) || banZero && Fp2.is0(n))\n        throw new Error(`bad point coordinate ${title}`);\n      return n;\n    }\n    function aprjpoint(other) {\n      if (!(other instanceof Point))\n        throw new Error(\"ProjectivePoint expected\");\n    }\n    function splitEndoScalarN(k) {\n      if (!endo || !endo.basises)\n        throw new Error(\"no endo\");\n      return _splitEndoScalar(k, endo.basises, Fn2.ORDER);\n    }\n    const toAffineMemo = memoized((p, iz) => {\n      const { X, Y, Z } = p;\n      if (Fp2.eql(Z, Fp2.ONE))\n        return { x: X, y: Y };\n      const is0 = p.is0();\n      if (iz == null)\n        iz = is0 ? Fp2.ONE : Fp2.inv(Z);\n      const x = Fp2.mul(X, iz);\n      const y = Fp2.mul(Y, iz);\n      const zz = Fp2.mul(Z, iz);\n      if (is0)\n        return { x: Fp2.ZERO, y: Fp2.ZERO };\n      if (!Fp2.eql(zz, Fp2.ONE))\n        throw new Error(\"invZ was invalid\");\n      return { x, y };\n    });\n    const assertValidMemo = memoized((p) => {\n      if (p.is0()) {\n        if (extraOpts.allowInfinityPoint && !Fp2.is0(p.Y))\n          return;\n        throw new Error(\"bad point: ZERO\");\n      }\n      const { x, y } = p.toAffine();\n      if (!Fp2.isValid(x) || !Fp2.isValid(y))\n        throw new Error(\"bad point: x or y not field elements\");\n      if (!isValidXY(x, y))\n        throw new Error(\"bad point: equation left != right\");\n      if (!p.isTorsionFree())\n        throw new Error(\"bad point: not in prime-order subgroup\");\n      return true;\n    });\n    function finishEndo(endoBeta, k1p, k2p, k1neg, k2neg) {\n      k2p = new Point(Fp2.mul(k2p.X, endoBeta), k2p.Y, k2p.Z);\n      k1p = negateCt(k1neg, k1p);\n      k2p = negateCt(k2neg, k2p);\n      return k1p.add(k2p);\n    }\n    class Point {\n      /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n      constructor(X, Y, Z) {\n        this.X = acoord(\"x\", X);\n        this.Y = acoord(\"y\", Y, true);\n        this.Z = acoord(\"z\", Z);\n        Object.freeze(this);\n      }\n      static CURVE() {\n        return CURVE;\n      }\n      /** Does NOT validate if the point is valid. Use `.assertValidity()`. */\n      static fromAffine(p) {\n        const { x, y } = p || {};\n        if (!p || !Fp2.isValid(x) || !Fp2.isValid(y))\n          throw new Error(\"invalid affine point\");\n        if (p instanceof Point)\n          throw new Error(\"projective point not allowed\");\n        if (Fp2.is0(x) && Fp2.is0(y))\n          return Point.ZERO;\n        return new Point(x, y, Fp2.ONE);\n      }\n      static fromBytes(bytes) {\n        const P = Point.fromAffine(decodePoint(_abytes2(bytes, void 0, \"point\")));\n        P.assertValidity();\n        return P;\n      }\n      static fromHex(hex) {\n        return Point.fromBytes(ensureBytes(\"pointHex\", hex));\n      }\n      get x() {\n        return this.toAffine().x;\n      }\n      get y() {\n        return this.toAffine().y;\n      }\n      /**\n       *\n       * @param windowSize\n       * @param isLazy true will defer table computation until the first multiplication\n       * @returns\n       */\n      precompute(windowSize = 8, isLazy = true) {\n        wnaf.createCache(this, windowSize);\n        if (!isLazy)\n          this.multiply(_3n3);\n        return this;\n      }\n      // TODO: return `this`\n      /** A point on curve is valid if it conforms to equation. */\n      assertValidity() {\n        assertValidMemo(this);\n      }\n      hasEvenY() {\n        const { y } = this.toAffine();\n        if (!Fp2.isOdd)\n          throw new Error(\"Field doesn't support isOdd\");\n        return !Fp2.isOdd(y);\n      }\n      /** Compare one point to another. */\n      equals(other) {\n        aprjpoint(other);\n        const { X: X1, Y: Y1, Z: Z1 } = this;\n        const { X: X2, Y: Y2, Z: Z2 } = other;\n        const U1 = Fp2.eql(Fp2.mul(X1, Z2), Fp2.mul(X2, Z1));\n        const U2 = Fp2.eql(Fp2.mul(Y1, Z2), Fp2.mul(Y2, Z1));\n        return U1 && U2;\n      }\n      /** Flips point to one corresponding to (x, -y) in Affine coordinates. */\n      negate() {\n        return new Point(this.X, Fp2.neg(this.Y), this.Z);\n      }\n      // Renes-Costello-Batina exception-free doubling formula.\n      // There is 30% faster Jacobian formula, but it is not complete.\n      // https://eprint.iacr.org/2015/1060, algorithm 3\n      // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n      double() {\n        const { a, b } = CURVE;\n        const b3 = Fp2.mul(b, _3n3);\n        const { X: X1, Y: Y1, Z: Z1 } = this;\n        let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;\n        let t0 = Fp2.mul(X1, X1);\n        let t1 = Fp2.mul(Y1, Y1);\n        let t2 = Fp2.mul(Z1, Z1);\n        let t3 = Fp2.mul(X1, Y1);\n        t3 = Fp2.add(t3, t3);\n        Z3 = Fp2.mul(X1, Z1);\n        Z3 = Fp2.add(Z3, Z3);\n        X3 = Fp2.mul(a, Z3);\n        Y3 = Fp2.mul(b3, t2);\n        Y3 = Fp2.add(X3, Y3);\n        X3 = Fp2.sub(t1, Y3);\n        Y3 = Fp2.add(t1, Y3);\n        Y3 = Fp2.mul(X3, Y3);\n        X3 = Fp2.mul(t3, X3);\n        Z3 = Fp2.mul(b3, Z3);\n        t2 = Fp2.mul(a, t2);\n        t3 = Fp2.sub(t0, t2);\n        t3 = Fp2.mul(a, t3);\n        t3 = Fp2.add(t3, Z3);\n        Z3 = Fp2.add(t0, t0);\n        t0 = Fp2.add(Z3, t0);\n        t0 = Fp2.add(t0, t2);\n        t0 = Fp2.mul(t0, t3);\n        Y3 = Fp2.add(Y3, t0);\n        t2 = Fp2.mul(Y1, Z1);\n        t2 = Fp2.add(t2, t2);\n        t0 = Fp2.mul(t2, t3);\n        X3 = Fp2.sub(X3, t0);\n        Z3 = Fp2.mul(t2, t1);\n        Z3 = Fp2.add(Z3, Z3);\n        Z3 = Fp2.add(Z3, Z3);\n        return new Point(X3, Y3, Z3);\n      }\n      // Renes-Costello-Batina exception-free addition formula.\n      // There is 30% faster Jacobian formula, but it is not complete.\n      // https://eprint.iacr.org/2015/1060, algorithm 1\n      // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n      add(other) {\n        aprjpoint(other);\n        const { X: X1, Y: Y1, Z: Z1 } = this;\n        const { X: X2, Y: Y2, Z: Z2 } = other;\n        let X3 = Fp2.ZERO, Y3 = Fp2.ZERO, Z3 = Fp2.ZERO;\n        const a = CURVE.a;\n        const b3 = Fp2.mul(CURVE.b, _3n3);\n        let t0 = Fp2.mul(X1, X2);\n        let t1 = Fp2.mul(Y1, Y2);\n        let t2 = Fp2.mul(Z1, Z2);\n        let t3 = Fp2.add(X1, Y1);\n        let t4 = Fp2.add(X2, Y2);\n        t3 = Fp2.mul(t3, t4);\n        t4 = Fp2.add(t0, t1);\n        t3 = Fp2.sub(t3, t4);\n        t4 = Fp2.add(X1, Z1);\n        let t5 = Fp2.add(X2, Z2);\n        t4 = Fp2.mul(t4, t5);\n        t5 = Fp2.add(t0, t2);\n        t4 = Fp2.sub(t4, t5);\n        t5 = Fp2.add(Y1, Z1);\n        X3 = Fp2.add(Y2, Z2);\n        t5 = Fp2.mul(t5, X3);\n        X3 = Fp2.add(t1, t2);\n        t5 = Fp2.sub(t5, X3);\n        Z3 = Fp2.mul(a, t4);\n        X3 = Fp2.mul(b3, t2);\n        Z3 = Fp2.add(X3, Z3);\n        X3 = Fp2.sub(t1, Z3);\n        Z3 = Fp2.add(t1, Z3);\n        Y3 = Fp2.mul(X3, Z3);\n        t1 = Fp2.add(t0, t0);\n        t1 = Fp2.add(t1, t0);\n        t2 = Fp2.mul(a, t2);\n        t4 = Fp2.mul(b3, t4);\n        t1 = Fp2.add(t1, t2);\n        t2 = Fp2.sub(t0, t2);\n        t2 = Fp2.mul(a, t2);\n        t4 = Fp2.add(t4, t2);\n        t0 = Fp2.mul(t1, t4);\n        Y3 = Fp2.add(Y3, t0);\n        t0 = Fp2.mul(t5, t4);\n        X3 = Fp2.mul(t3, X3);\n        X3 = Fp2.sub(X3, t0);\n        t0 = Fp2.mul(t3, t1);\n        Z3 = Fp2.mul(t5, Z3);\n        Z3 = Fp2.add(Z3, t0);\n        return new Point(X3, Y3, Z3);\n      }\n      subtract(other) {\n        return this.add(other.negate());\n      }\n      is0() {\n        return this.equals(Point.ZERO);\n      }\n      /**\n       * Constant time multiplication.\n       * Uses wNAF method. Windowed method may be 10% faster,\n       * but takes 2x longer to generate and consumes 2x memory.\n       * Uses precomputes when available.\n       * Uses endomorphism for Koblitz curves.\n       * @param scalar by which the point would be multiplied\n       * @returns New point\n       */\n      multiply(scalar) {\n        const { endo: endo2 } = extraOpts;\n        if (!Fn2.isValidNot0(scalar))\n          throw new Error(\"invalid scalar: out of range\");\n        let point, fake;\n        const mul = (n) => wnaf.cached(this, n, (p) => normalizeZ(Point, p));\n        if (endo2) {\n          const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(scalar);\n          const { p: k1p, f: k1f } = mul(k1);\n          const { p: k2p, f: k2f } = mul(k2);\n          fake = k1f.add(k2f);\n          point = finishEndo(endo2.beta, k1p, k2p, k1neg, k2neg);\n        } else {\n          const { p, f: f2 } = mul(scalar);\n          point = p;\n          fake = f2;\n        }\n        return normalizeZ(Point, [point, fake])[0];\n      }\n      /**\n       * Non-constant-time multiplication. Uses double-and-add algorithm.\n       * It's faster, but should only be used when you don't care about\n       * an exposed secret key e.g. sig verification, which works over *public* keys.\n       */\n      multiplyUnsafe(sc) {\n        const { endo: endo2 } = extraOpts;\n        const p = this;\n        if (!Fn2.isValid(sc))\n          throw new Error(\"invalid scalar: out of range\");\n        if (sc === _0n7 || p.is0())\n          return Point.ZERO;\n        if (sc === _1n7)\n          return p;\n        if (wnaf.hasCache(this))\n          return this.multiply(sc);\n        if (endo2) {\n          const { k1neg, k1, k2neg, k2 } = splitEndoScalarN(sc);\n          const { p1, p2 } = mulEndoUnsafe(Point, p, k1, k2);\n          return finishEndo(endo2.beta, p1, p2, k1neg, k2neg);\n        } else {\n          return wnaf.unsafe(p, sc);\n        }\n      }\n      multiplyAndAddUnsafe(Q, a, b) {\n        const sum = this.multiplyUnsafe(a).add(Q.multiplyUnsafe(b));\n        return sum.is0() ? void 0 : sum;\n      }\n      /**\n       * Converts Projective point to affine (x, y) coordinates.\n       * @param invertedZ Z^-1 (inverted zero) - optional, precomputation is useful for invertBatch\n       */\n      toAffine(invertedZ) {\n        return toAffineMemo(this, invertedZ);\n      }\n      /**\n       * Checks whether Point is free of torsion elements (is in prime subgroup).\n       * Always torsion-free for cofactor=1 curves.\n       */\n      isTorsionFree() {\n        const { isTorsionFree } = extraOpts;\n        if (cofactor === _1n7)\n          return true;\n        if (isTorsionFree)\n          return isTorsionFree(Point, this);\n        return wnaf.unsafe(this, CURVE_ORDER).is0();\n      }\n      clearCofactor() {\n        const { clearCofactor } = extraOpts;\n        if (cofactor === _1n7)\n          return this;\n        if (clearCofactor)\n          return clearCofactor(Point, this);\n        return this.multiplyUnsafe(cofactor);\n      }\n      isSmallOrder() {\n        return this.multiplyUnsafe(cofactor).is0();\n      }\n      toBytes(isCompressed = true) {\n        _abool2(isCompressed, \"isCompressed\");\n        this.assertValidity();\n        return encodePoint(Point, this, isCompressed);\n      }\n      toHex(isCompressed = true) {\n        return bytesToHex(this.toBytes(isCompressed));\n      }\n      toString() {\n        return `<Point ${this.is0() ? \"ZERO\" : this.toHex()}>`;\n      }\n      // TODO: remove\n      get px() {\n        return this.X;\n      }\n      get py() {\n        return this.X;\n      }\n      get pz() {\n        return this.Z;\n      }\n      toRawBytes(isCompressed = true) {\n        return this.toBytes(isCompressed);\n      }\n      _setWindowSize(windowSize) {\n        this.precompute(windowSize);\n      }\n      static normalizeZ(points) {\n        return normalizeZ(Point, points);\n      }\n      static msm(points, scalars) {\n        return pippenger(Point, Fn2, points, scalars);\n      }\n      static fromPrivateKey(privateKey) {\n        return Point.BASE.multiply(_normFnElement(Fn2, privateKey));\n      }\n    }\n    Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp2.ONE);\n    Point.ZERO = new Point(Fp2.ZERO, Fp2.ONE, Fp2.ZERO);\n    Point.Fp = Fp2;\n    Point.Fn = Fn2;\n    const bits = Fn2.BITS;\n    const wnaf = new wNAF(Point, extraOpts.endo ? Math.ceil(bits / 2) : bits);\n    Point.BASE.precompute(8);\n    return Point;\n  }\n  function pprefix(hasEvenY) {\n    return Uint8Array.of(hasEvenY ? 2 : 3);\n  }\n  function getWLengths(Fp2, Fn2) {\n    return {\n      secretKey: Fn2.BYTES,\n      publicKey: 1 + Fp2.BYTES,\n      publicKeyUncompressed: 1 + 2 * Fp2.BYTES,\n      publicKeyHasPrefix: true,\n      signature: 2 * Fn2.BYTES\n    };\n  }\n  function ecdh(Point, ecdhOpts = {}) {\n    const { Fn: Fn2 } = Point;\n    const randomBytes_ = ecdhOpts.randomBytes || randomBytes;\n    const lengths = Object.assign(getWLengths(Point.Fp, Fn2), { seed: getMinHashLength(Fn2.ORDER) });\n    function isValidSecretKey(secretKey) {\n      try {\n        return !!_normFnElement(Fn2, secretKey);\n      } catch (error) {\n        return false;\n      }\n    }\n    function isValidPublicKey(publicKey2, isCompressed) {\n      const { publicKey: comp, publicKeyUncompressed } = lengths;\n      try {\n        const l = publicKey2.length;\n        if (isCompressed === true && l !== comp)\n          return false;\n        if (isCompressed === false && l !== publicKeyUncompressed)\n          return false;\n        return !!Point.fromBytes(publicKey2);\n      } catch (error) {\n        return false;\n      }\n    }\n    function randomSecretKey(seed = randomBytes_(lengths.seed)) {\n      return mapHashToField(_abytes2(seed, lengths.seed, \"seed\"), Fn2.ORDER);\n    }\n    function getPublicKey2(secretKey, isCompressed = true) {\n      return Point.BASE.multiply(_normFnElement(Fn2, secretKey)).toBytes(isCompressed);\n    }\n    function keygen(seed) {\n      const secretKey = randomSecretKey(seed);\n      return { secretKey, publicKey: getPublicKey2(secretKey) };\n    }\n    function isProbPub(item) {\n      if (typeof item === \"bigint\")\n        return false;\n      if (item instanceof Point)\n        return true;\n      const { secretKey, publicKey: publicKey2, publicKeyUncompressed } = lengths;\n      if (Fn2.allowedLengths || secretKey === publicKey2)\n        return void 0;\n      const l = ensureBytes(\"key\", item).length;\n      return l === publicKey2 || l === publicKeyUncompressed;\n    }\n    function getSharedSecret(secretKeyA, publicKeyB, isCompressed = true) {\n      if (isProbPub(secretKeyA) === true)\n        throw new Error(\"first arg must be private key\");\n      if (isProbPub(publicKeyB) === false)\n        throw new Error(\"second arg must be public key\");\n      const s = _normFnElement(Fn2, secretKeyA);\n      const b = Point.fromHex(publicKeyB);\n      return b.multiply(s).toBytes(isCompressed);\n    }\n    const utils = {\n      isValidSecretKey,\n      isValidPublicKey,\n      randomSecretKey,\n      // TODO: remove\n      isValidPrivateKey: isValidSecretKey,\n      randomPrivateKey: randomSecretKey,\n      normPrivateKeyToScalar: (key) => _normFnElement(Fn2, key),\n      precompute(windowSize = 8, point = Point.BASE) {\n        return point.precompute(windowSize, false);\n      }\n    };\n    return Object.freeze({ getPublicKey: getPublicKey2, getSharedSecret, keygen, Point, utils, lengths });\n  }\n  function ecdsa(Point, hash, ecdsaOpts = {}) {\n    ahash(hash);\n    _validateObject(ecdsaOpts, {}, {\n      hmac: \"function\",\n      lowS: \"boolean\",\n      randomBytes: \"function\",\n      bits2int: \"function\",\n      bits2int_modN: \"function\"\n    });\n    const randomBytes2 = ecdsaOpts.randomBytes || randomBytes;\n    const hmac2 = ecdsaOpts.hmac || ((key, ...msgs) => hmac(hash, key, concatBytes(...msgs)));\n    const { Fp: Fp2, Fn: Fn2 } = Point;\n    const { ORDER: CURVE_ORDER, BITS: fnBits } = Fn2;\n    const { keygen, getPublicKey: getPublicKey2, getSharedSecret, utils, lengths } = ecdh(Point, ecdsaOpts);\n    const defaultSigOpts = {\n      prehash: false,\n      lowS: typeof ecdsaOpts.lowS === \"boolean\" ? ecdsaOpts.lowS : false,\n      format: void 0,\n      //'compact' as ECDSASigFormat,\n      extraEntropy: false\n    };\n    const defaultSigOpts_format = \"compact\";\n    function isBiggerThanHalfOrder(number2) {\n      const HALF = CURVE_ORDER >> _1n7;\n      return number2 > HALF;\n    }\n    function validateRS(title, num) {\n      if (!Fn2.isValidNot0(num))\n        throw new Error(`invalid signature ${title}: out of range 1..Point.Fn.ORDER`);\n      return num;\n    }\n    function validateSigLength(bytes, format) {\n      validateSigFormat(format);\n      const size = lengths.signature;\n      const sizer = format === \"compact\" ? size : format === \"recovered\" ? size + 1 : void 0;\n      return _abytes2(bytes, sizer, `${format} signature`);\n    }\n    class Signature {\n      constructor(r, s, recovery) {\n        this.r = validateRS(\"r\", r);\n        this.s = validateRS(\"s\", s);\n        if (recovery != null)\n          this.recovery = recovery;\n        Object.freeze(this);\n      }\n      static fromBytes(bytes, format = defaultSigOpts_format) {\n        validateSigLength(bytes, format);\n        let recid;\n        if (format === \"der\") {\n          const { r: r2, s: s2 } = DER.toSig(_abytes2(bytes));\n          return new Signature(r2, s2);\n        }\n        if (format === \"recovered\") {\n          recid = bytes[0];\n          format = \"compact\";\n          bytes = bytes.subarray(1);\n        }\n        const L = Fn2.BYTES;\n        const r = bytes.subarray(0, L);\n        const s = bytes.subarray(L, L * 2);\n        return new Signature(Fn2.fromBytes(r), Fn2.fromBytes(s), recid);\n      }\n      static fromHex(hex, format) {\n        return this.fromBytes(hexToBytes(hex), format);\n      }\n      addRecoveryBit(recovery) {\n        return new Signature(this.r, this.s, recovery);\n      }\n      recoverPublicKey(messageHash) {\n        const FIELD_ORDER = Fp2.ORDER;\n        const { r, s, recovery: rec } = this;\n        if (rec == null || ![0, 1, 2, 3].includes(rec))\n          throw new Error(\"recovery id invalid\");\n        const hasCofactor = CURVE_ORDER * _2n5 < FIELD_ORDER;\n        if (hasCofactor && rec > 1)\n          throw new Error(\"recovery id is ambiguous for h>1 curve\");\n        const radj = rec === 2 || rec === 3 ? r + CURVE_ORDER : r;\n        if (!Fp2.isValid(radj))\n          throw new Error(\"recovery id 2 or 3 invalid\");\n        const x = Fp2.toBytes(radj);\n        const R = Point.fromBytes(concatBytes(pprefix((rec & 1) === 0), x));\n        const ir = Fn2.inv(radj);\n        const h = bits2int_modN(ensureBytes(\"msgHash\", messageHash));\n        const u1 = Fn2.create(-h * ir);\n        const u2 = Fn2.create(s * ir);\n        const Q = Point.BASE.multiplyUnsafe(u1).add(R.multiplyUnsafe(u2));\n        if (Q.is0())\n          throw new Error(\"point at infinify\");\n        Q.assertValidity();\n        return Q;\n      }\n      // Signatures should be low-s, to prevent malleability.\n      hasHighS() {\n        return isBiggerThanHalfOrder(this.s);\n      }\n      toBytes(format = defaultSigOpts_format) {\n        validateSigFormat(format);\n        if (format === \"der\")\n          return hexToBytes(DER.hexFromSig(this));\n        const r = Fn2.toBytes(this.r);\n        const s = Fn2.toBytes(this.s);\n        if (format === \"recovered\") {\n          if (this.recovery == null)\n            throw new Error(\"recovery bit must be present\");\n          return concatBytes(Uint8Array.of(this.recovery), r, s);\n        }\n        return concatBytes(r, s);\n      }\n      toHex(format) {\n        return bytesToHex(this.toBytes(format));\n      }\n      // TODO: remove\n      assertValidity() {\n      }\n      static fromCompact(hex) {\n        return Signature.fromBytes(ensureBytes(\"sig\", hex), \"compact\");\n      }\n      static fromDER(hex) {\n        return Signature.fromBytes(ensureBytes(\"sig\", hex), \"der\");\n      }\n      normalizeS() {\n        return this.hasHighS() ? new Signature(this.r, Fn2.neg(this.s), this.recovery) : this;\n      }\n      toDERRawBytes() {\n        return this.toBytes(\"der\");\n      }\n      toDERHex() {\n        return bytesToHex(this.toBytes(\"der\"));\n      }\n      toCompactRawBytes() {\n        return this.toBytes(\"compact\");\n      }\n      toCompactHex() {\n        return bytesToHex(this.toBytes(\"compact\"));\n      }\n    }\n    const bits2int = ecdsaOpts.bits2int || function bits2int_def(bytes) {\n      if (bytes.length > 8192)\n        throw new Error(\"input is too large\");\n      const num = bytesToNumberBE(bytes);\n      const delta = bytes.length * 8 - fnBits;\n      return delta > 0 ? num >> BigInt(delta) : num;\n    };\n    const bits2int_modN = ecdsaOpts.bits2int_modN || function bits2int_modN_def(bytes) {\n      return Fn2.create(bits2int(bytes));\n    };\n    const ORDER_MASK = bitMask(fnBits);\n    function int2octets(num) {\n      aInRange(\"num < 2^\" + fnBits, num, _0n7, ORDER_MASK);\n      return Fn2.toBytes(num);\n    }\n    function validateMsgAndHash(message, prehash) {\n      _abytes2(message, void 0, \"message\");\n      return prehash ? _abytes2(hash(message), void 0, \"prehashed message\") : message;\n    }\n    function prepSig(message, privateKey, opts) {\n      if ([\"recovered\", \"canonical\"].some((k) => k in opts))\n        throw new Error(\"sign() legacy options not supported\");\n      const { lowS, prehash, extraEntropy } = validateSigOpts(opts, defaultSigOpts);\n      message = validateMsgAndHash(message, prehash);\n      const h1int = bits2int_modN(message);\n      const d = _normFnElement(Fn2, privateKey);\n      const seedArgs = [int2octets(d), int2octets(h1int)];\n      if (extraEntropy != null && extraEntropy !== false) {\n        const e = extraEntropy === true ? randomBytes2(lengths.secretKey) : extraEntropy;\n        seedArgs.push(ensureBytes(\"extraEntropy\", e));\n      }\n      const seed = concatBytes(...seedArgs);\n      const m = h1int;\n      function k2sig(kBytes) {\n        const k = bits2int(kBytes);\n        if (!Fn2.isValidNot0(k))\n          return;\n        const ik = Fn2.inv(k);\n        const q = Point.BASE.multiply(k).toAffine();\n        const r = Fn2.create(q.x);\n        if (r === _0n7)\n          return;\n        const s = Fn2.create(ik * Fn2.create(m + r * d));\n        if (s === _0n7)\n          return;\n        let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n7);\n        let normS = s;\n        if (lowS && isBiggerThanHalfOrder(s)) {\n          normS = Fn2.neg(s);\n          recovery ^= 1;\n        }\n        return new Signature(r, normS, recovery);\n      }\n      return { seed, k2sig };\n    }\n    function sign2(message, secretKey, opts = {}) {\n      message = ensureBytes(\"message\", message);\n      const { seed, k2sig } = prepSig(message, secretKey, opts);\n      const drbg = createHmacDrbg(hash.outputLen, Fn2.BYTES, hmac2);\n      const sig = drbg(seed, k2sig);\n      return sig;\n    }\n    function tryParsingSig(sg) {\n      let sig = void 0;\n      const isHex = typeof sg === \"string\" || isBytes(sg);\n      const isObj = !isHex && sg !== null && typeof sg === \"object\" && typeof sg.r === \"bigint\" && typeof sg.s === \"bigint\";\n      if (!isHex && !isObj)\n        throw new Error(\"invalid signature, expected Uint8Array, hex string or Signature instance\");\n      if (isObj) {\n        sig = new Signature(sg.r, sg.s);\n      } else if (isHex) {\n        try {\n          sig = Signature.fromBytes(ensureBytes(\"sig\", sg), \"der\");\n        } catch (derError) {\n          if (!(derError instanceof DER.Err))\n            throw derError;\n        }\n        if (!sig) {\n          try {\n            sig = Signature.fromBytes(ensureBytes(\"sig\", sg), \"compact\");\n          } catch (error) {\n            return false;\n          }\n        }\n      }\n      if (!sig)\n        return false;\n      return sig;\n    }\n    function verify2(signature, message, publicKey2, opts = {}) {\n      const { lowS, prehash, format } = validateSigOpts(opts, defaultSigOpts);\n      publicKey2 = ensureBytes(\"publicKey\", publicKey2);\n      message = validateMsgAndHash(ensureBytes(\"message\", message), prehash);\n      if (\"strict\" in opts)\n        throw new Error(\"options.strict was renamed to lowS\");\n      const sig = format === void 0 ? tryParsingSig(signature) : Signature.fromBytes(ensureBytes(\"sig\", signature), format);\n      if (sig === false)\n        return false;\n      try {\n        const P = Point.fromBytes(publicKey2);\n        if (lowS && sig.hasHighS())\n          return false;\n        const { r, s } = sig;\n        const h = bits2int_modN(message);\n        const is2 = Fn2.inv(s);\n        const u1 = Fn2.create(h * is2);\n        const u2 = Fn2.create(r * is2);\n        const R = Point.BASE.multiplyUnsafe(u1).add(P.multiplyUnsafe(u2));\n        if (R.is0())\n          return false;\n        const v = Fn2.create(R.x);\n        return v === r;\n      } catch (e) {\n        return false;\n      }\n    }\n    function recoverPublicKey(signature, message, opts = {}) {\n      const { prehash } = validateSigOpts(opts, defaultSigOpts);\n      message = validateMsgAndHash(message, prehash);\n      return Signature.fromBytes(signature, \"recovered\").recoverPublicKey(message).toBytes();\n    }\n    return Object.freeze({\n      keygen,\n      getPublicKey: getPublicKey2,\n      getSharedSecret,\n      utils,\n      lengths,\n      Point,\n      sign: sign2,\n      verify: verify2,\n      recoverPublicKey,\n      Signature,\n      hash\n    });\n  }\n  function _weierstrass_legacy_opts_to_new(c) {\n    const CURVE = {\n      a: c.a,\n      b: c.b,\n      p: c.Fp.ORDER,\n      n: c.n,\n      h: c.h,\n      Gx: c.Gx,\n      Gy: c.Gy\n    };\n    const Fp2 = c.Fp;\n    let allowedLengths = c.allowedPrivateKeyLengths ? Array.from(new Set(c.allowedPrivateKeyLengths.map((l) => Math.ceil(l / 2)))) : void 0;\n    const Fn2 = Field(CURVE.n, {\n      BITS: c.nBitLength,\n      allowedLengths,\n      modFromBytes: c.wrapPrivateKey\n    });\n    const curveOpts = {\n      Fp: Fp2,\n      Fn: Fn2,\n      allowInfinityPoint: c.allowInfinityPoint,\n      endo: c.endo,\n      isTorsionFree: c.isTorsionFree,\n      clearCofactor: c.clearCofactor,\n      fromBytes: c.fromBytes,\n      toBytes: c.toBytes\n    };\n    return { CURVE, curveOpts };\n  }\n  function _ecdsa_legacy_opts_to_new(c) {\n    const { CURVE, curveOpts } = _weierstrass_legacy_opts_to_new(c);\n    const ecdsaOpts = {\n      hmac: c.hmac,\n      randomBytes: c.randomBytes,\n      lowS: c.lowS,\n      bits2int: c.bits2int,\n      bits2int_modN: c.bits2int_modN\n    };\n    return { CURVE, curveOpts, hash: c.hash, ecdsaOpts };\n  }\n  function _ecdsa_new_output_to_legacy(c, _ecdsa) {\n    const Point = _ecdsa.Point;\n    return Object.assign({}, _ecdsa, {\n      ProjectivePoint: Point,\n      CURVE: Object.assign({}, c, nLength(Point.Fn.ORDER, Point.Fn.BITS))\n    });\n  }\n  function weierstrass(c) {\n    const { CURVE, curveOpts, hash, ecdsaOpts } = _ecdsa_legacy_opts_to_new(c);\n    const Point = weierstrassN(CURVE, curveOpts);\n    const signs = ecdsa(Point, hash, ecdsaOpts);\n    return _ecdsa_new_output_to_legacy(c, signs);\n  }\n\n  // ../../../node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/_shortw_utils.js\n  function createCurve(curveDef, defHash) {\n    const create2 = (hash) => weierstrass({ ...curveDef, hash });\n    return { ...create2(defHash), create: create2 };\n  }\n\n  // ../../../node_modules/.pnpm/@noble+curves@1.9.7/node_modules/@noble/curves/esm/secp256k1.js\n  var secp256k1_CURVE = {\n    p: BigInt(\"0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f\"),\n    n: BigInt(\"0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\"),\n    h: BigInt(1),\n    a: BigInt(0),\n    b: BigInt(7),\n    Gx: BigInt(\"0x79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798\"),\n    Gy: BigInt(\"0x483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8\")\n  };\n  var secp256k1_ENDO = {\n    beta: BigInt(\"0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee\"),\n    basises: [\n      [BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\"), -BigInt(\"0xe4437ed6010e88286f547fa90abfe4c3\")],\n      [BigInt(\"0x114ca50f7a8e2f3f657c1108d9d44cfd8\"), BigInt(\"0x3086d221a7d46bcde86c90e49284eb15\")]\n    ]\n  };\n  var _2n6 = /* @__PURE__ */ BigInt(2);\n  function sqrtMod(y) {\n    const P = secp256k1_CURVE.p;\n    const _3n4 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n    const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n    const b2 = y * y * y % P;\n    const b3 = b2 * b2 * y % P;\n    const b6 = pow2(b3, _3n4, P) * b3 % P;\n    const b9 = pow2(b6, _3n4, P) * b3 % P;\n    const b11 = pow2(b9, _2n6, P) * b2 % P;\n    const b22 = pow2(b11, _11n, P) * b11 % P;\n    const b44 = pow2(b22, _22n, P) * b22 % P;\n    const b88 = pow2(b44, _44n, P) * b44 % P;\n    const b176 = pow2(b88, _88n, P) * b88 % P;\n    const b220 = pow2(b176, _44n, P) * b44 % P;\n    const b223 = pow2(b220, _3n4, P) * b3 % P;\n    const t1 = pow2(b223, _23n, P) * b22 % P;\n    const t2 = pow2(t1, _6n, P) * b2 % P;\n    const root = pow2(t2, _2n6, P);\n    if (!Fpk1.eql(Fpk1.sqr(root), y))\n      throw new Error(\"Cannot find square root\");\n    return root;\n  }\n  var Fpk1 = Field(secp256k1_CURVE.p, { sqrt: sqrtMod });\n  var secp256k1 = createCurve({ ...secp256k1_CURVE, Fp: Fpk1, lowS: true, endo: secp256k1_ENDO }, sha256);\n\n  // ../../../node_modules/.pnpm/@solana+web3.js@1.98.4_bufferutil@4.0.9_typescript@5.8.3_utf-8-validate@5.0.10/node_modules/@solana/web3.js/lib/index.browser.esm.js\n  var generatePrivateKey = ed25519.utils.randomPrivateKey;\n  var generateKeypair = () => {\n    const privateScalar = ed25519.utils.randomPrivateKey();\n    const publicKey2 = getPublicKey(privateScalar);\n    const secretKey = new Uint8Array(64);\n    secretKey.set(privateScalar);\n    secretKey.set(publicKey2, 32);\n    return {\n      publicKey: publicKey2,\n      secretKey\n    };\n  };\n  var getPublicKey = ed25519.getPublicKey;\n  function isOnCurve(publicKey2) {\n    try {\n      ed25519.ExtendedPoint.fromHex(publicKey2);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n  var sign = (message, secretKey) => ed25519.sign(message, secretKey.slice(0, 32));\n  var verify = ed25519.verify;\n  var toBuffer = (arr) => {\n    if (Buffer2.isBuffer(arr)) {\n      return arr;\n    } else if (arr instanceof Uint8Array) {\n      return Buffer2.from(arr.buffer, arr.byteOffset, arr.byteLength);\n    } else {\n      return Buffer2.from(arr);\n    }\n  };\n  var Struct2 = class {\n    constructor(properties) {\n      Object.assign(this, properties);\n    }\n    encode() {\n      return Buffer2.from((0, import_borsh.serialize)(SOLANA_SCHEMA, this));\n    }\n    static decode(data) {\n      return (0, import_borsh.deserialize)(SOLANA_SCHEMA, this, data);\n    }\n    static decodeUnchecked(data) {\n      return (0, import_borsh.deserializeUnchecked)(SOLANA_SCHEMA, this, data);\n    }\n  };\n  var SOLANA_SCHEMA = /* @__PURE__ */ new Map();\n  var _PublicKey;\n  var MAX_SEED_LENGTH = 32;\n  var PUBLIC_KEY_LENGTH = 32;\n  function isPublicKeyData(value) {\n    return value._bn !== void 0;\n  }\n  var uniquePublicKeyCounter = 1;\n  var PublicKey = class _PublicKey2 extends Struct2 {\n    /**\n     * Create a new PublicKey object\n     * @param value ed25519 public key as buffer or base-58 encoded string\n     */\n    constructor(value) {\n      super({});\n      this._bn = void 0;\n      if (isPublicKeyData(value)) {\n        this._bn = value._bn;\n      } else {\n        if (typeof value === \"string\") {\n          const decoded = import_bs58.default.decode(value);\n          if (decoded.length != PUBLIC_KEY_LENGTH) {\n            throw new Error(`Invalid public key input`);\n          }\n          this._bn = new import_bn.default(decoded);\n        } else {\n          this._bn = new import_bn.default(value);\n        }\n        if (this._bn.byteLength() > PUBLIC_KEY_LENGTH) {\n          throw new Error(`Invalid public key input`);\n        }\n      }\n    }\n    /**\n     * Returns a unique PublicKey for tests and benchmarks using a counter\n     */\n    static unique() {\n      const key = new _PublicKey2(uniquePublicKeyCounter);\n      uniquePublicKeyCounter += 1;\n      return new _PublicKey2(key.toBuffer());\n    }\n    /**\n     * Default public key value. The base58-encoded string representation is all ones (as seen below)\n     * The underlying BN number is 32 bytes that are all zeros\n     */\n    /**\n     * Checks if two publicKeys are equal\n     */\n    equals(publicKey2) {\n      return this._bn.eq(publicKey2._bn);\n    }\n    /**\n     * Return the base-58 representation of the public key\n     */\n    toBase58() {\n      return import_bs58.default.encode(this.toBytes());\n    }\n    toJSON() {\n      return this.toBase58();\n    }\n    /**\n     * Return the byte array representation of the public key in big endian\n     */\n    toBytes() {\n      const buf = this.toBuffer();\n      return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);\n    }\n    /**\n     * Return the Buffer representation of the public key in big endian\n     */\n    toBuffer() {\n      const b = this._bn.toArrayLike(Buffer2);\n      if (b.length === PUBLIC_KEY_LENGTH) {\n        return b;\n      }\n      const zeroPad = Buffer2.alloc(32);\n      b.copy(zeroPad, 32 - b.length);\n      return zeroPad;\n    }\n    get [Symbol.toStringTag]() {\n      return `PublicKey(${this.toString()})`;\n    }\n    /**\n     * Return the base-58 representation of the public key\n     */\n    toString() {\n      return this.toBase58();\n    }\n    /**\n     * Derive a public key from another key, a seed, and a program ID.\n     * The program ID will also serve as the owner of the public key, giving\n     * it permission to write data to the account.\n     */\n    /* eslint-disable require-await */\n    static async createWithSeed(fromPublicKey, seed, programId) {\n      const buffer = Buffer2.concat([fromPublicKey.toBuffer(), Buffer2.from(seed), programId.toBuffer()]);\n      const publicKeyBytes = sha2562(buffer);\n      return new _PublicKey2(publicKeyBytes);\n    }\n    /**\n     * Derive a program address from seeds and a program ID.\n     */\n    /* eslint-disable require-await */\n    static createProgramAddressSync(seeds, programId) {\n      let buffer = Buffer2.alloc(0);\n      seeds.forEach(function(seed) {\n        if (seed.length > MAX_SEED_LENGTH) {\n          throw new TypeError(`Max seed length exceeded`);\n        }\n        buffer = Buffer2.concat([buffer, toBuffer(seed)]);\n      });\n      buffer = Buffer2.concat([buffer, programId.toBuffer(), Buffer2.from(\"ProgramDerivedAddress\")]);\n      const publicKeyBytes = sha2562(buffer);\n      if (isOnCurve(publicKeyBytes)) {\n        throw new Error(`Invalid seeds, address must fall off the curve`);\n      }\n      return new _PublicKey2(publicKeyBytes);\n    }\n    /**\n     * Async version of createProgramAddressSync\n     * For backwards compatibility\n     *\n     * @deprecated Use {@link createProgramAddressSync} instead\n     */\n    /* eslint-disable require-await */\n    static async createProgramAddress(seeds, programId) {\n      return this.createProgramAddressSync(seeds, programId);\n    }\n    /**\n     * Find a valid program address\n     *\n     * Valid program addresses must fall off the ed25519 curve.  This function\n     * iterates a nonce until it finds one that when combined with the seeds\n     * results in a valid program address.\n     */\n    static findProgramAddressSync(seeds, programId) {\n      let nonce = 255;\n      let address;\n      while (nonce != 0) {\n        try {\n          const seedsWithNonce = seeds.concat(Buffer2.from([nonce]));\n          address = this.createProgramAddressSync(seedsWithNonce, programId);\n        } catch (err) {\n          if (err instanceof TypeError) {\n            throw err;\n          }\n          nonce--;\n          continue;\n        }\n        return [address, nonce];\n      }\n      throw new Error(`Unable to find a viable program address nonce`);\n    }\n    /**\n     * Async version of findProgramAddressSync\n     * For backwards compatibility\n     *\n     * @deprecated Use {@link findProgramAddressSync} instead\n     */\n    static async findProgramAddress(seeds, programId) {\n      return this.findProgramAddressSync(seeds, programId);\n    }\n    /**\n     * Check that a pubkey is on the ed25519 curve.\n     */\n    static isOnCurve(pubkeyData) {\n      const pubkey = new _PublicKey2(pubkeyData);\n      return isOnCurve(pubkey.toBytes());\n    }\n  };\n  _PublicKey = PublicKey;\n  PublicKey.default = new _PublicKey(\"11111111111111111111111111111111\");\n  SOLANA_SCHEMA.set(PublicKey, {\n    kind: \"struct\",\n    fields: [[\"_bn\", \"u256\"]]\n  });\n  var BPF_LOADER_DEPRECATED_PROGRAM_ID = new PublicKey(\"BPFLoader1111111111111111111111111111111111\");\n  var PACKET_DATA_SIZE = 1280 - 40 - 8;\n  var VERSION_PREFIX_MASK = 127;\n  var SIGNATURE_LENGTH_IN_BYTES = 64;\n  var TransactionExpiredBlockheightExceededError = class extends Error {\n    constructor(signature) {\n      super(`Signature ${signature} has expired: block height exceeded.`);\n      this.signature = void 0;\n      this.signature = signature;\n    }\n  };\n  Object.defineProperty(TransactionExpiredBlockheightExceededError.prototype, \"name\", {\n    value: \"TransactionExpiredBlockheightExceededError\"\n  });\n  var TransactionExpiredTimeoutError = class extends Error {\n    constructor(signature, timeoutSeconds) {\n      super(`Transaction was not confirmed in ${timeoutSeconds.toFixed(2)} seconds. It is unknown if it succeeded or failed. Check signature ${signature} using the Solana Explorer or CLI tools.`);\n      this.signature = void 0;\n      this.signature = signature;\n    }\n  };\n  Object.defineProperty(TransactionExpiredTimeoutError.prototype, \"name\", {\n    value: \"TransactionExpiredTimeoutError\"\n  });\n  var TransactionExpiredNonceInvalidError = class extends Error {\n    constructor(signature) {\n      super(`Signature ${signature} has expired: the nonce is no longer valid.`);\n      this.signature = void 0;\n      this.signature = signature;\n    }\n  };\n  Object.defineProperty(TransactionExpiredNonceInvalidError.prototype, \"name\", {\n    value: \"TransactionExpiredNonceInvalidError\"\n  });\n  var MessageAccountKeys = class {\n    constructor(staticAccountKeys, accountKeysFromLookups) {\n      this.staticAccountKeys = void 0;\n      this.accountKeysFromLookups = void 0;\n      this.staticAccountKeys = staticAccountKeys;\n      this.accountKeysFromLookups = accountKeysFromLookups;\n    }\n    keySegments() {\n      const keySegments = [this.staticAccountKeys];\n      if (this.accountKeysFromLookups) {\n        keySegments.push(this.accountKeysFromLookups.writable);\n        keySegments.push(this.accountKeysFromLookups.readonly);\n      }\n      return keySegments;\n    }\n    get(index) {\n      for (const keySegment of this.keySegments()) {\n        if (index < keySegment.length) {\n          return keySegment[index];\n        } else {\n          index -= keySegment.length;\n        }\n      }\n      return;\n    }\n    get length() {\n      return this.keySegments().flat().length;\n    }\n    compileInstructions(instructions) {\n      const U8_MAX = 255;\n      if (this.length > U8_MAX + 1) {\n        throw new Error(\"Account index overflow encountered during compilation\");\n      }\n      const keyIndexMap = /* @__PURE__ */ new Map();\n      this.keySegments().flat().forEach((key, index) => {\n        keyIndexMap.set(key.toBase58(), index);\n      });\n      const findKeyIndex = (key) => {\n        const keyIndex = keyIndexMap.get(key.toBase58());\n        if (keyIndex === void 0)\n          throw new Error(\"Encountered an unknown instruction account key during compilation\");\n        return keyIndex;\n      };\n      return instructions.map((instruction) => {\n        return {\n          programIdIndex: findKeyIndex(instruction.programId),\n          accountKeyIndexes: instruction.keys.map((meta) => findKeyIndex(meta.pubkey)),\n          data: instruction.data\n        };\n      });\n    }\n  };\n  var publicKey = (property = \"publicKey\") => {\n    return BufferLayout.blob(32, property);\n  };\n  var rustString = (property = \"string\") => {\n    const rsl = BufferLayout.struct([BufferLayout.u32(\"length\"), BufferLayout.u32(\"lengthPadding\"), BufferLayout.blob(BufferLayout.offset(BufferLayout.u32(), -8), \"chars\")], property);\n    const _decode = rsl.decode.bind(rsl);\n    const _encode = rsl.encode.bind(rsl);\n    const rslShim = rsl;\n    rslShim.decode = (b, offset2) => {\n      const data = _decode(b, offset2);\n      return data[\"chars\"].toString();\n    };\n    rslShim.encode = (str, b, offset2) => {\n      const data = {\n        chars: Buffer2.from(str, \"utf8\")\n      };\n      return _encode(data, b, offset2);\n    };\n    rslShim.alloc = (str) => {\n      return BufferLayout.u32().span + BufferLayout.u32().span + Buffer2.from(str, \"utf8\").length;\n    };\n    return rslShim;\n  };\n  var authorized = (property = \"authorized\") => {\n    return BufferLayout.struct([publicKey(\"staker\"), publicKey(\"withdrawer\")], property);\n  };\n  var lockup = (property = \"lockup\") => {\n    return BufferLayout.struct([BufferLayout.ns64(\"unixTimestamp\"), BufferLayout.ns64(\"epoch\"), publicKey(\"custodian\")], property);\n  };\n  var voteInit = (property = \"voteInit\") => {\n    return BufferLayout.struct([publicKey(\"nodePubkey\"), publicKey(\"authorizedVoter\"), publicKey(\"authorizedWithdrawer\"), BufferLayout.u8(\"commission\")], property);\n  };\n  var voteAuthorizeWithSeedArgs = (property = \"voteAuthorizeWithSeedArgs\") => {\n    return BufferLayout.struct([BufferLayout.u32(\"voteAuthorizationType\"), publicKey(\"currentAuthorityDerivedKeyOwnerPubkey\"), rustString(\"currentAuthorityDerivedKeySeed\"), publicKey(\"newAuthorized\")], property);\n  };\n  function getAlloc(type2, fields) {\n    const getItemAlloc = (item) => {\n      if (item.span >= 0) {\n        return item.span;\n      } else if (typeof item.alloc === \"function\") {\n        return item.alloc(fields[item.property]);\n      } else if (\"count\" in item && \"elementLayout\" in item) {\n        const field = fields[item.property];\n        if (Array.isArray(field)) {\n          return field.length * getItemAlloc(item.elementLayout);\n        }\n      } else if (\"fields\" in item) {\n        return getAlloc({\n          layout: item\n        }, fields[item.property]);\n      }\n      return 0;\n    };\n    let alloc = 0;\n    type2.layout.fields.forEach((item) => {\n      alloc += getItemAlloc(item);\n    });\n    return alloc;\n  }\n  function decodeLength(bytes) {\n    let len = 0;\n    let size = 0;\n    for (; ; ) {\n      let elem = bytes.shift();\n      len |= (elem & 127) << size * 7;\n      size += 1;\n      if ((elem & 128) === 0) {\n        break;\n      }\n    }\n    return len;\n  }\n  function encodeLength(bytes, len) {\n    let rem_len = len;\n    for (; ; ) {\n      let elem = rem_len & 127;\n      rem_len >>= 7;\n      if (rem_len == 0) {\n        bytes.push(elem);\n        break;\n      } else {\n        elem |= 128;\n        bytes.push(elem);\n      }\n    }\n  }\n  function assert2(condition, message) {\n    if (!condition) {\n      throw new Error(message || \"Assertion failed\");\n    }\n  }\n  var CompiledKeys = class _CompiledKeys {\n    constructor(payer, keyMetaMap) {\n      this.payer = void 0;\n      this.keyMetaMap = void 0;\n      this.payer = payer;\n      this.keyMetaMap = keyMetaMap;\n    }\n    static compile(instructions, payer) {\n      const keyMetaMap = /* @__PURE__ */ new Map();\n      const getOrInsertDefault = (pubkey) => {\n        const address = pubkey.toBase58();\n        let keyMeta = keyMetaMap.get(address);\n        if (keyMeta === void 0) {\n          keyMeta = {\n            isSigner: false,\n            isWritable: false,\n            isInvoked: false\n          };\n          keyMetaMap.set(address, keyMeta);\n        }\n        return keyMeta;\n      };\n      const payerKeyMeta = getOrInsertDefault(payer);\n      payerKeyMeta.isSigner = true;\n      payerKeyMeta.isWritable = true;\n      for (const ix of instructions) {\n        getOrInsertDefault(ix.programId).isInvoked = true;\n        for (const accountMeta of ix.keys) {\n          const keyMeta = getOrInsertDefault(accountMeta.pubkey);\n          keyMeta.isSigner ||= accountMeta.isSigner;\n          keyMeta.isWritable ||= accountMeta.isWritable;\n        }\n      }\n      return new _CompiledKeys(payer, keyMetaMap);\n    }\n    getMessageComponents() {\n      const mapEntries = [...this.keyMetaMap.entries()];\n      assert2(mapEntries.length <= 256, \"Max static account keys length exceeded\");\n      const writableSigners = mapEntries.filter(([, meta]) => meta.isSigner && meta.isWritable);\n      const readonlySigners = mapEntries.filter(([, meta]) => meta.isSigner && !meta.isWritable);\n      const writableNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && meta.isWritable);\n      const readonlyNonSigners = mapEntries.filter(([, meta]) => !meta.isSigner && !meta.isWritable);\n      const header = {\n        numRequiredSignatures: writableSigners.length + readonlySigners.length,\n        numReadonlySignedAccounts: readonlySigners.length,\n        numReadonlyUnsignedAccounts: readonlyNonSigners.length\n      };\n      {\n        assert2(writableSigners.length > 0, \"Expected at least one writable signer key\");\n        const [payerAddress] = writableSigners[0];\n        assert2(payerAddress === this.payer.toBase58(), \"Expected first writable signer key to be the fee payer\");\n      }\n      const staticAccountKeys = [...writableSigners.map(([address]) => new PublicKey(address)), ...readonlySigners.map(([address]) => new PublicKey(address)), ...writableNonSigners.map(([address]) => new PublicKey(address)), ...readonlyNonSigners.map(([address]) => new PublicKey(address))];\n      return [header, staticAccountKeys];\n    }\n    extractTableLookup(lookupTable) {\n      const [writableIndexes, drainedWritableKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && keyMeta.isWritable);\n      const [readonlyIndexes, drainedReadonlyKeys] = this.drainKeysFoundInLookupTable(lookupTable.state.addresses, (keyMeta) => !keyMeta.isSigner && !keyMeta.isInvoked && !keyMeta.isWritable);\n      if (writableIndexes.length === 0 && readonlyIndexes.length === 0) {\n        return;\n      }\n      return [{\n        accountKey: lookupTable.key,\n        writableIndexes,\n        readonlyIndexes\n      }, {\n        writable: drainedWritableKeys,\n        readonly: drainedReadonlyKeys\n      }];\n    }\n    /** @internal */\n    drainKeysFoundInLookupTable(lookupTableEntries, keyMetaFilter) {\n      const lookupTableIndexes = new Array();\n      const drainedKeys = new Array();\n      for (const [address, keyMeta] of this.keyMetaMap.entries()) {\n        if (keyMetaFilter(keyMeta)) {\n          const key = new PublicKey(address);\n          const lookupTableIndex = lookupTableEntries.findIndex((entry) => entry.equals(key));\n          if (lookupTableIndex >= 0) {\n            assert2(lookupTableIndex < 256, \"Max lookup table index exceeded\");\n            lookupTableIndexes.push(lookupTableIndex);\n            drainedKeys.push(key);\n            this.keyMetaMap.delete(address);\n          }\n        }\n      }\n      return [lookupTableIndexes, drainedKeys];\n    }\n  };\n  var END_OF_BUFFER_ERROR_MESSAGE = \"Reached end of buffer unexpectedly\";\n  function guardedShift(byteArray) {\n    if (byteArray.length === 0) {\n      throw new Error(END_OF_BUFFER_ERROR_MESSAGE);\n    }\n    return byteArray.shift();\n  }\n  function guardedSplice(byteArray, ...args) {\n    const [start] = args;\n    if (args.length === 2 ? start + (args[1] ?? 0) > byteArray.length : start >= byteArray.length) {\n      throw new Error(END_OF_BUFFER_ERROR_MESSAGE);\n    }\n    return byteArray.splice(...args);\n  }\n  var Message = class _Message {\n    constructor(args) {\n      this.header = void 0;\n      this.accountKeys = void 0;\n      this.recentBlockhash = void 0;\n      this.instructions = void 0;\n      this.indexToProgramIds = /* @__PURE__ */ new Map();\n      this.header = args.header;\n      this.accountKeys = args.accountKeys.map((account) => new PublicKey(account));\n      this.recentBlockhash = args.recentBlockhash;\n      this.instructions = args.instructions;\n      this.instructions.forEach((ix) => this.indexToProgramIds.set(ix.programIdIndex, this.accountKeys[ix.programIdIndex]));\n    }\n    get version() {\n      return \"legacy\";\n    }\n    get staticAccountKeys() {\n      return this.accountKeys;\n    }\n    get compiledInstructions() {\n      return this.instructions.map((ix) => ({\n        programIdIndex: ix.programIdIndex,\n        accountKeyIndexes: ix.accounts,\n        data: import_bs58.default.decode(ix.data)\n      }));\n    }\n    get addressTableLookups() {\n      return [];\n    }\n    getAccountKeys() {\n      return new MessageAccountKeys(this.staticAccountKeys);\n    }\n    static compile(args) {\n      const compiledKeys = CompiledKeys.compile(args.instructions, args.payerKey);\n      const [header, staticAccountKeys] = compiledKeys.getMessageComponents();\n      const accountKeys = new MessageAccountKeys(staticAccountKeys);\n      const instructions = accountKeys.compileInstructions(args.instructions).map((ix) => ({\n        programIdIndex: ix.programIdIndex,\n        accounts: ix.accountKeyIndexes,\n        data: import_bs58.default.encode(ix.data)\n      }));\n      return new _Message({\n        header,\n        accountKeys: staticAccountKeys,\n        recentBlockhash: args.recentBlockhash,\n        instructions\n      });\n    }\n    isAccountSigner(index) {\n      return index < this.header.numRequiredSignatures;\n    }\n    isAccountWritable(index) {\n      const numSignedAccounts = this.header.numRequiredSignatures;\n      if (index >= this.header.numRequiredSignatures) {\n        const unsignedAccountIndex = index - numSignedAccounts;\n        const numUnsignedAccounts = this.accountKeys.length - numSignedAccounts;\n        const numWritableUnsignedAccounts = numUnsignedAccounts - this.header.numReadonlyUnsignedAccounts;\n        return unsignedAccountIndex < numWritableUnsignedAccounts;\n      } else {\n        const numWritableSignedAccounts = numSignedAccounts - this.header.numReadonlySignedAccounts;\n        return index < numWritableSignedAccounts;\n      }\n    }\n    isProgramId(index) {\n      return this.indexToProgramIds.has(index);\n    }\n    programIds() {\n      return [...this.indexToProgramIds.values()];\n    }\n    nonProgramIds() {\n      return this.accountKeys.filter((_, index) => !this.isProgramId(index));\n    }\n    serialize() {\n      const numKeys = this.accountKeys.length;\n      let keyCount = [];\n      encodeLength(keyCount, numKeys);\n      const instructions = this.instructions.map((instruction) => {\n        const {\n          accounts,\n          programIdIndex\n        } = instruction;\n        const data = Array.from(import_bs58.default.decode(instruction.data));\n        let keyIndicesCount = [];\n        encodeLength(keyIndicesCount, accounts.length);\n        let dataCount = [];\n        encodeLength(dataCount, data.length);\n        return {\n          programIdIndex,\n          keyIndicesCount: Buffer2.from(keyIndicesCount),\n          keyIndices: accounts,\n          dataLength: Buffer2.from(dataCount),\n          data\n        };\n      });\n      let instructionCount = [];\n      encodeLength(instructionCount, instructions.length);\n      let instructionBuffer = Buffer2.alloc(PACKET_DATA_SIZE);\n      Buffer2.from(instructionCount).copy(instructionBuffer);\n      let instructionBufferLength = instructionCount.length;\n      instructions.forEach((instruction) => {\n        const instructionLayout = BufferLayout.struct([BufferLayout.u8(\"programIdIndex\"), BufferLayout.blob(instruction.keyIndicesCount.length, \"keyIndicesCount\"), BufferLayout.seq(BufferLayout.u8(\"keyIndex\"), instruction.keyIndices.length, \"keyIndices\"), BufferLayout.blob(instruction.dataLength.length, \"dataLength\"), BufferLayout.seq(BufferLayout.u8(\"userdatum\"), instruction.data.length, \"data\")]);\n        const length2 = instructionLayout.encode(instruction, instructionBuffer, instructionBufferLength);\n        instructionBufferLength += length2;\n      });\n      instructionBuffer = instructionBuffer.slice(0, instructionBufferLength);\n      const signDataLayout = BufferLayout.struct([BufferLayout.blob(1, \"numRequiredSignatures\"), BufferLayout.blob(1, \"numReadonlySignedAccounts\"), BufferLayout.blob(1, \"numReadonlyUnsignedAccounts\"), BufferLayout.blob(keyCount.length, \"keyCount\"), BufferLayout.seq(publicKey(\"key\"), numKeys, \"keys\"), publicKey(\"recentBlockhash\")]);\n      const transaction = {\n        numRequiredSignatures: Buffer2.from([this.header.numRequiredSignatures]),\n        numReadonlySignedAccounts: Buffer2.from([this.header.numReadonlySignedAccounts]),\n        numReadonlyUnsignedAccounts: Buffer2.from([this.header.numReadonlyUnsignedAccounts]),\n        keyCount: Buffer2.from(keyCount),\n        keys: this.accountKeys.map((key) => toBuffer(key.toBytes())),\n        recentBlockhash: import_bs58.default.decode(this.recentBlockhash)\n      };\n      let signData = Buffer2.alloc(2048);\n      const length = signDataLayout.encode(transaction, signData);\n      instructionBuffer.copy(signData, length);\n      return signData.slice(0, length + instructionBuffer.length);\n    }\n    /**\n     * Decode a compiled message into a Message object.\n     */\n    static from(buffer) {\n      let byteArray = [...buffer];\n      const numRequiredSignatures = guardedShift(byteArray);\n      if (numRequiredSignatures !== (numRequiredSignatures & VERSION_PREFIX_MASK)) {\n        throw new Error(\"Versioned messages must be deserialized with VersionedMessage.deserialize()\");\n      }\n      const numReadonlySignedAccounts = guardedShift(byteArray);\n      const numReadonlyUnsignedAccounts = guardedShift(byteArray);\n      const accountCount = decodeLength(byteArray);\n      let accountKeys = [];\n      for (let i = 0; i < accountCount; i++) {\n        const account = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);\n        accountKeys.push(new PublicKey(Buffer2.from(account)));\n      }\n      const recentBlockhash = guardedSplice(byteArray, 0, PUBLIC_KEY_LENGTH);\n      const instructionCount = decodeLength(byteArray);\n      let instructions = [];\n      for (let i = 0; i < instructionCount; i++) {\n        const programIdIndex = guardedShift(byteArray);\n        const accountCount2 = decodeLength(byteArray);\n        const accounts = guardedSplice(byteArray, 0, accountCount2);\n        const dataLength = decodeLength(byteArray);\n        const dataSlice = guardedSplice(byteArray, 0, dataLength);\n        const data = import_bs58.default.encode(Buffer2.from(dataSlice));\n        instructions.push({\n          programIdIndex,\n          accounts,\n          data\n        });\n      }\n      const messageArgs = {\n        header: {\n          numRequiredSignatures,\n          numReadonlySignedAccounts,\n          numReadonlyUnsignedAccounts\n        },\n        recentBlockhash: import_bs58.default.encode(Buffer2.from(recentBlockhash)),\n        accountKeys,\n        instructions\n      };\n      return new _Message(messageArgs);\n    }\n  };\n  var DEFAULT_SIGNATURE = Buffer2.alloc(SIGNATURE_LENGTH_IN_BYTES).fill(0);\n  var TransactionInstruction = class {\n    constructor(opts) {\n      this.keys = void 0;\n      this.programId = void 0;\n      this.data = Buffer2.alloc(0);\n      this.programId = opts.programId;\n      this.keys = opts.keys;\n      if (opts.data) {\n        this.data = opts.data;\n      }\n    }\n    /**\n     * @internal\n     */\n    toJSON() {\n      return {\n        keys: this.keys.map(({\n          pubkey,\n          isSigner,\n          isWritable\n        }) => ({\n          pubkey: pubkey.toJSON(),\n          isSigner,\n          isWritable\n        })),\n        programId: this.programId.toJSON(),\n        data: [...this.data]\n      };\n    }\n  };\n  var Transaction = class _Transaction {\n    /**\n     * The first (payer) Transaction signature\n     *\n     * @returns {Buffer | null} Buffer of payer's signature\n     */\n    get signature() {\n      if (this.signatures.length > 0) {\n        return this.signatures[0].signature;\n      }\n      return null;\n    }\n    /**\n     * The transaction fee payer\n     */\n    // Construct a transaction with a blockhash and lastValidBlockHeight\n    // Construct a transaction using a durable nonce\n    /**\n     * @deprecated `TransactionCtorFields` has been deprecated and will be removed in a future version.\n     * Please supply a `TransactionBlockhashCtor` instead.\n     */\n    /**\n     * Construct an empty Transaction\n     */\n    constructor(opts) {\n      this.signatures = [];\n      this.feePayer = void 0;\n      this.instructions = [];\n      this.recentBlockhash = void 0;\n      this.lastValidBlockHeight = void 0;\n      this.nonceInfo = void 0;\n      this.minNonceContextSlot = void 0;\n      this._message = void 0;\n      this._json = void 0;\n      if (!opts) {\n        return;\n      }\n      if (opts.feePayer) {\n        this.feePayer = opts.feePayer;\n      }\n      if (opts.signatures) {\n        this.signatures = opts.signatures;\n      }\n      if (Object.prototype.hasOwnProperty.call(opts, \"nonceInfo\")) {\n        const {\n          minContextSlot,\n          nonceInfo\n        } = opts;\n        this.minNonceContextSlot = minContextSlot;\n        this.nonceInfo = nonceInfo;\n      } else if (Object.prototype.hasOwnProperty.call(opts, \"lastValidBlockHeight\")) {\n        const {\n          blockhash,\n          lastValidBlockHeight\n        } = opts;\n        this.recentBlockhash = blockhash;\n        this.lastValidBlockHeight = lastValidBlockHeight;\n      } else {\n        const {\n          recentBlockhash,\n          nonceInfo\n        } = opts;\n        if (nonceInfo) {\n          this.nonceInfo = nonceInfo;\n        }\n        this.recentBlockhash = recentBlockhash;\n      }\n    }\n    /**\n     * @internal\n     */\n    toJSON() {\n      return {\n        recentBlockhash: this.recentBlockhash || null,\n        feePayer: this.feePayer ? this.feePayer.toJSON() : null,\n        nonceInfo: this.nonceInfo ? {\n          nonce: this.nonceInfo.nonce,\n          nonceInstruction: this.nonceInfo.nonceInstruction.toJSON()\n        } : null,\n        instructions: this.instructions.map((instruction) => instruction.toJSON()),\n        signers: this.signatures.map(({\n          publicKey: publicKey2\n        }) => {\n          return publicKey2.toJSON();\n        })\n      };\n    }\n    /**\n     * Add one or more instructions to this Transaction\n     *\n     * @param {Array< Transaction | TransactionInstruction | TransactionInstructionCtorFields >} items - Instructions to add to the Transaction\n     */\n    add(...items) {\n      if (items.length === 0) {\n        throw new Error(\"No instructions\");\n      }\n      items.forEach((item) => {\n        if (\"instructions\" in item) {\n          this.instructions = this.instructions.concat(item.instructions);\n        } else if (\"data\" in item && \"programId\" in item && \"keys\" in item) {\n          this.instructions.push(item);\n        } else {\n          this.instructions.push(new TransactionInstruction(item));\n        }\n      });\n      return this;\n    }\n    /**\n     * Compile transaction data\n     */\n    compileMessage() {\n      if (this._message && JSON.stringify(this.toJSON()) === JSON.stringify(this._json)) {\n        return this._message;\n      }\n      let recentBlockhash;\n      let instructions;\n      if (this.nonceInfo) {\n        recentBlockhash = this.nonceInfo.nonce;\n        if (this.instructions[0] != this.nonceInfo.nonceInstruction) {\n          instructions = [this.nonceInfo.nonceInstruction, ...this.instructions];\n        } else {\n          instructions = this.instructions;\n        }\n      } else {\n        recentBlockhash = this.recentBlockhash;\n        instructions = this.instructions;\n      }\n      if (!recentBlockhash) {\n        throw new Error(\"Transaction recentBlockhash required\");\n      }\n      if (instructions.length < 1) {\n        console.warn(\"No instructions provided\");\n      }\n      let feePayer;\n      if (this.feePayer) {\n        feePayer = this.feePayer;\n      } else if (this.signatures.length > 0 && this.signatures[0].publicKey) {\n        feePayer = this.signatures[0].publicKey;\n      } else {\n        throw new Error(\"Transaction fee payer required\");\n      }\n      for (let i = 0; i < instructions.length; i++) {\n        if (instructions[i].programId === void 0) {\n          throw new Error(`Transaction instruction index ${i} has undefined program id`);\n        }\n      }\n      const programIds = [];\n      const accountMetas = [];\n      instructions.forEach((instruction) => {\n        instruction.keys.forEach((accountMeta) => {\n          accountMetas.push({\n            ...accountMeta\n          });\n        });\n        const programId = instruction.programId.toString();\n        if (!programIds.includes(programId)) {\n          programIds.push(programId);\n        }\n      });\n      programIds.forEach((programId) => {\n        accountMetas.push({\n          pubkey: new PublicKey(programId),\n          isSigner: false,\n          isWritable: false\n        });\n      });\n      const uniqueMetas = [];\n      accountMetas.forEach((accountMeta) => {\n        const pubkeyString = accountMeta.pubkey.toString();\n        const uniqueIndex = uniqueMetas.findIndex((x) => {\n          return x.pubkey.toString() === pubkeyString;\n        });\n        if (uniqueIndex > -1) {\n          uniqueMetas[uniqueIndex].isWritable = uniqueMetas[uniqueIndex].isWritable || accountMeta.isWritable;\n          uniqueMetas[uniqueIndex].isSigner = uniqueMetas[uniqueIndex].isSigner || accountMeta.isSigner;\n        } else {\n          uniqueMetas.push(accountMeta);\n        }\n      });\n      uniqueMetas.sort(function(x, y) {\n        if (x.isSigner !== y.isSigner) {\n          return x.isSigner ? -1 : 1;\n        }\n        if (x.isWritable !== y.isWritable) {\n          return x.isWritable ? -1 : 1;\n        }\n        const options = {\n          localeMatcher: \"best fit\",\n          usage: \"sort\",\n          sensitivity: \"variant\",\n          ignorePunctuation: false,\n          numeric: false,\n          caseFirst: \"lower\"\n        };\n        return x.pubkey.toBase58().localeCompare(y.pubkey.toBase58(), \"en\", options);\n      });\n      const feePayerIndex = uniqueMetas.findIndex((x) => {\n        return x.pubkey.equals(feePayer);\n      });\n      if (feePayerIndex > -1) {\n        const [payerMeta] = uniqueMetas.splice(feePayerIndex, 1);\n        payerMeta.isSigner = true;\n        payerMeta.isWritable = true;\n        uniqueMetas.unshift(payerMeta);\n      } else {\n        uniqueMetas.unshift({\n          pubkey: feePayer,\n          isSigner: true,\n          isWritable: true\n        });\n      }\n      for (const signature of this.signatures) {\n        const uniqueIndex = uniqueMetas.findIndex((x) => {\n          return x.pubkey.equals(signature.publicKey);\n        });\n        if (uniqueIndex > -1) {\n          if (!uniqueMetas[uniqueIndex].isSigner) {\n            uniqueMetas[uniqueIndex].isSigner = true;\n            console.warn(\"Transaction references a signature that is unnecessary, only the fee payer and instruction signer accounts should sign a transaction. This behavior is deprecated and will throw an error in the next major version release.\");\n          }\n        } else {\n          throw new Error(`unknown signer: ${signature.publicKey.toString()}`);\n        }\n      }\n      let numRequiredSignatures = 0;\n      let numReadonlySignedAccounts = 0;\n      let numReadonlyUnsignedAccounts = 0;\n      const signedKeys = [];\n      const unsignedKeys = [];\n      uniqueMetas.forEach(({\n        pubkey,\n        isSigner,\n        isWritable\n      }) => {\n        if (isSigner) {\n          signedKeys.push(pubkey.toString());\n          numRequiredSignatures += 1;\n          if (!isWritable) {\n            numReadonlySignedAccounts += 1;\n          }\n        } else {\n          unsignedKeys.push(pubkey.toString());\n          if (!isWritable) {\n            numReadonlyUnsignedAccounts += 1;\n          }\n        }\n      });\n      const accountKeys = signedKeys.concat(unsignedKeys);\n      const compiledInstructions = instructions.map((instruction) => {\n        const {\n          data,\n          programId\n        } = instruction;\n        return {\n          programIdIndex: accountKeys.indexOf(programId.toString()),\n          accounts: instruction.keys.map((meta) => accountKeys.indexOf(meta.pubkey.toString())),\n          data: import_bs58.default.encode(data)\n        };\n      });\n      compiledInstructions.forEach((instruction) => {\n        assert2(instruction.programIdIndex >= 0);\n        instruction.accounts.forEach((keyIndex) => assert2(keyIndex >= 0));\n      });\n      return new Message({\n        header: {\n          numRequiredSignatures,\n          numReadonlySignedAccounts,\n          numReadonlyUnsignedAccounts\n        },\n        accountKeys,\n        recentBlockhash,\n        instructions: compiledInstructions\n      });\n    }\n    /**\n     * @internal\n     */\n    _compile() {\n      const message = this.compileMessage();\n      const signedKeys = message.accountKeys.slice(0, message.header.numRequiredSignatures);\n      if (this.signatures.length === signedKeys.length) {\n        const valid = this.signatures.every((pair, index) => {\n          return signedKeys[index].equals(pair.publicKey);\n        });\n        if (valid)\n          return message;\n      }\n      this.signatures = signedKeys.map((publicKey2) => ({\n        signature: null,\n        publicKey: publicKey2\n      }));\n      return message;\n    }\n    /**\n     * Get a buffer of the Transaction data that need to be covered by signatures\n     */\n    serializeMessage() {\n      return this._compile().serialize();\n    }\n    /**\n     * Get the estimated fee associated with a transaction\n     *\n     * @param {Connection} connection Connection to RPC Endpoint.\n     *\n     * @returns {Promise<number | null>} The estimated fee for the transaction\n     */\n    async getEstimatedFee(connection) {\n      return (await connection.getFeeForMessage(this.compileMessage())).value;\n    }\n    /**\n     * Specify the public keys which will be used to sign the Transaction.\n     * The first signer will be used as the transaction fee payer account.\n     *\n     * Signatures can be added with either `partialSign` or `addSignature`\n     *\n     * @deprecated Deprecated since v0.84.0. Only the fee payer needs to be\n     * specified and it can be set in the Transaction constructor or with the\n     * `feePayer` property.\n     */\n    setSigners(...signers) {\n      if (signers.length === 0) {\n        throw new Error(\"No signers\");\n      }\n      const seen = /* @__PURE__ */ new Set();\n      this.signatures = signers.filter((publicKey2) => {\n        const key = publicKey2.toString();\n        if (seen.has(key)) {\n          return false;\n        } else {\n          seen.add(key);\n          return true;\n        }\n      }).map((publicKey2) => ({\n        signature: null,\n        publicKey: publicKey2\n      }));\n    }\n    /**\n     * Sign the Transaction with the specified signers. Multiple signatures may\n     * be applied to a Transaction. The first signature is considered \"primary\"\n     * and is used identify and confirm transactions.\n     *\n     * If the Transaction `feePayer` is not set, the first signer will be used\n     * as the transaction fee payer account.\n     *\n     * Transaction fields should not be modified after the first call to `sign`,\n     * as doing so may invalidate the signature and cause the Transaction to be\n     * rejected.\n     *\n     * The Transaction must be assigned a valid `recentBlockhash` before invoking this method\n     *\n     * @param {Array<Signer>} signers Array of signers that will sign the transaction\n     */\n    sign(...signers) {\n      if (signers.length === 0) {\n        throw new Error(\"No signers\");\n      }\n      const seen = /* @__PURE__ */ new Set();\n      const uniqueSigners = [];\n      for (const signer of signers) {\n        const key = signer.publicKey.toString();\n        if (seen.has(key)) {\n          continue;\n        } else {\n          seen.add(key);\n          uniqueSigners.push(signer);\n        }\n      }\n      this.signatures = uniqueSigners.map((signer) => ({\n        signature: null,\n        publicKey: signer.publicKey\n      }));\n      const message = this._compile();\n      this._partialSign(message, ...uniqueSigners);\n    }\n    /**\n     * Partially sign a transaction with the specified accounts. All accounts must\n     * correspond to either the fee payer or a signer account in the transaction\n     * instructions.\n     *\n     * All the caveats from the `sign` method apply to `partialSign`\n     *\n     * @param {Array<Signer>} signers Array of signers that will sign the transaction\n     */\n    partialSign(...signers) {\n      if (signers.length === 0) {\n        throw new Error(\"No signers\");\n      }\n      const seen = /* @__PURE__ */ new Set();\n      const uniqueSigners = [];\n      for (const signer of signers) {\n        const key = signer.publicKey.toString();\n        if (seen.has(key)) {\n          continue;\n        } else {\n          seen.add(key);\n          uniqueSigners.push(signer);\n        }\n      }\n      const message = this._compile();\n      this._partialSign(message, ...uniqueSigners);\n    }\n    /**\n     * @internal\n     */\n    _partialSign(message, ...signers) {\n      const signData = message.serialize();\n      signers.forEach((signer) => {\n        const signature = sign(signData, signer.secretKey);\n        this._addSignature(signer.publicKey, toBuffer(signature));\n      });\n    }\n    /**\n     * Add an externally created signature to a transaction. The public key\n     * must correspond to either the fee payer or a signer account in the transaction\n     * instructions.\n     *\n     * @param {PublicKey} pubkey Public key that will be added to the transaction.\n     * @param {Buffer} signature An externally created signature to add to the transaction.\n     */\n    addSignature(pubkey, signature) {\n      this._compile();\n      this._addSignature(pubkey, signature);\n    }\n    /**\n     * @internal\n     */\n    _addSignature(pubkey, signature) {\n      assert2(signature.length === 64);\n      const index = this.signatures.findIndex((sigpair) => pubkey.equals(sigpair.publicKey));\n      if (index < 0) {\n        throw new Error(`unknown signer: ${pubkey.toString()}`);\n      }\n      this.signatures[index].signature = Buffer2.from(signature);\n    }\n    /**\n     * Verify signatures of a Transaction\n     * Optional parameter specifies if we're expecting a fully signed Transaction or a partially signed one.\n     * If no boolean is provided, we expect a fully signed Transaction by default.\n     *\n     * @param {boolean} [requireAllSignatures=true] Require a fully signed Transaction\n     */\n    verifySignatures(requireAllSignatures = true) {\n      const signatureErrors = this._getMessageSignednessErrors(this.serializeMessage(), requireAllSignatures);\n      return !signatureErrors;\n    }\n    /**\n     * @internal\n     */\n    _getMessageSignednessErrors(message, requireAllSignatures) {\n      const errors = {};\n      for (const {\n        signature,\n        publicKey: publicKey2\n      } of this.signatures) {\n        if (signature === null) {\n          if (requireAllSignatures) {\n            (errors.missing ||= []).push(publicKey2);\n          }\n        } else {\n          if (!verify(signature, message, publicKey2.toBytes())) {\n            (errors.invalid ||= []).push(publicKey2);\n          }\n        }\n      }\n      return errors.invalid || errors.missing ? errors : void 0;\n    }\n    /**\n     * Serialize the Transaction in the wire format.\n     *\n     * @param {Buffer} [config] Config of transaction.\n     *\n     * @returns {Buffer} Signature of transaction in wire format.\n     */\n    serialize(config) {\n      const {\n        requireAllSignatures,\n        verifySignatures\n      } = Object.assign({\n        requireAllSignatures: true,\n        verifySignatures: true\n      }, config);\n      const signData = this.serializeMessage();\n      if (verifySignatures) {\n        const sigErrors = this._getMessageSignednessErrors(signData, requireAllSignatures);\n        if (sigErrors) {\n          let errorMessage = \"Signature verification failed.\";\n          if (sigErrors.invalid) {\n            errorMessage += `\nInvalid signature for public key${sigErrors.invalid.length === 1 ? \"\" : \"(s)\"} [\\`${sigErrors.invalid.map((p) => p.toBase58()).join(\"`, `\")}\\`].`;\n          }\n          if (sigErrors.missing) {\n            errorMessage += `\nMissing signature for public key${sigErrors.missing.length === 1 ? \"\" : \"(s)\"} [\\`${sigErrors.missing.map((p) => p.toBase58()).join(\"`, `\")}\\`].`;\n          }\n          throw new Error(errorMessage);\n        }\n      }\n      return this._serialize(signData);\n    }\n    /**\n     * @internal\n     */\n    _serialize(signData) {\n      const {\n        signatures\n      } = this;\n      const signatureCount = [];\n      encodeLength(signatureCount, signatures.length);\n      const transactionLength = signatureCount.length + signatures.length * 64 + signData.length;\n      const wireTransaction = Buffer2.alloc(transactionLength);\n      assert2(signatures.length < 256);\n      Buffer2.from(signatureCount).copy(wireTransaction, 0);\n      signatures.forEach(({\n        signature\n      }, index) => {\n        if (signature !== null) {\n          assert2(signature.length === 64, `signature has invalid length`);\n          Buffer2.from(signature).copy(wireTransaction, signatureCount.length + index * 64);\n        }\n      });\n      signData.copy(wireTransaction, signatureCount.length + signatures.length * 64);\n      assert2(wireTransaction.length <= PACKET_DATA_SIZE, `Transaction too large: ${wireTransaction.length} > ${PACKET_DATA_SIZE}`);\n      return wireTransaction;\n    }\n    /**\n     * Deprecated method\n     * @internal\n     */\n    get keys() {\n      assert2(this.instructions.length === 1);\n      return this.instructions[0].keys.map((keyObj) => keyObj.pubkey);\n    }\n    /**\n     * Deprecated method\n     * @internal\n     */\n    get programId() {\n      assert2(this.instructions.length === 1);\n      return this.instructions[0].programId;\n    }\n    /**\n     * Deprecated method\n     * @internal\n     */\n    get data() {\n      assert2(this.instructions.length === 1);\n      return this.instructions[0].data;\n    }\n    /**\n     * Parse a wire transaction into a Transaction object.\n     *\n     * @param {Buffer | Uint8Array | Array<number>} buffer Signature of wire Transaction\n     *\n     * @returns {Transaction} Transaction associated with the signature\n     */\n    static from(buffer) {\n      let byteArray = [...buffer];\n      const signatureCount = decodeLength(byteArray);\n      let signatures = [];\n      for (let i = 0; i < signatureCount; i++) {\n        const signature = guardedSplice(byteArray, 0, SIGNATURE_LENGTH_IN_BYTES);\n        signatures.push(import_bs58.default.encode(Buffer2.from(signature)));\n      }\n      return _Transaction.populate(Message.from(byteArray), signatures);\n    }\n    /**\n     * Populate Transaction object from message and signatures\n     *\n     * @param {Message} message Message of transaction\n     * @param {Array<string>} signatures List of signatures to assign to the transaction\n     *\n     * @returns {Transaction} The populated Transaction\n     */\n    static populate(message, signatures = []) {\n      const transaction = new _Transaction();\n      transaction.recentBlockhash = message.recentBlockhash;\n      if (message.header.numRequiredSignatures > 0) {\n        transaction.feePayer = message.accountKeys[0];\n      }\n      signatures.forEach((signature, index) => {\n        const sigPubkeyPair = {\n          signature: signature == import_bs58.default.encode(DEFAULT_SIGNATURE) ? null : import_bs58.default.decode(signature),\n          publicKey: message.accountKeys[index]\n        };\n        transaction.signatures.push(sigPubkeyPair);\n      });\n      message.instructions.forEach((instruction) => {\n        const keys = instruction.accounts.map((account) => {\n          const pubkey = message.accountKeys[account];\n          return {\n            pubkey,\n            isSigner: transaction.signatures.some((keyObj) => keyObj.publicKey.toString() === pubkey.toString()) || message.isAccountSigner(account),\n            isWritable: message.isAccountWritable(account)\n          };\n        });\n        transaction.instructions.push(new TransactionInstruction({\n          keys,\n          programId: message.accountKeys[instruction.programIdIndex],\n          data: import_bs58.default.decode(instruction.data)\n        }));\n      });\n      transaction._message = message;\n      transaction._json = transaction.toJSON();\n      return transaction;\n    }\n  };\n  var NUM_TICKS_PER_SECOND = 160;\n  var DEFAULT_TICKS_PER_SLOT = 64;\n  var NUM_SLOTS_PER_SECOND = NUM_TICKS_PER_SECOND / DEFAULT_TICKS_PER_SLOT;\n  var MS_PER_SLOT = 1e3 / NUM_SLOTS_PER_SECOND;\n  var SYSVAR_CLOCK_PUBKEY = new PublicKey(\"SysvarC1ock11111111111111111111111111111111\");\n  var SYSVAR_EPOCH_SCHEDULE_PUBKEY = new PublicKey(\"SysvarEpochSchedu1e111111111111111111111111\");\n  var SYSVAR_INSTRUCTIONS_PUBKEY = new PublicKey(\"Sysvar1nstructions1111111111111111111111111\");\n  var SYSVAR_RECENT_BLOCKHASHES_PUBKEY = new PublicKey(\"SysvarRecentB1ockHashes11111111111111111111\");\n  var SYSVAR_RENT_PUBKEY = new PublicKey(\"SysvarRent111111111111111111111111111111111\");\n  var SYSVAR_REWARDS_PUBKEY = new PublicKey(\"SysvarRewards111111111111111111111111111111\");\n  var SYSVAR_SLOT_HASHES_PUBKEY = new PublicKey(\"SysvarS1otHashes111111111111111111111111111\");\n  var SYSVAR_SLOT_HISTORY_PUBKEY = new PublicKey(\"SysvarS1otHistory11111111111111111111111111\");\n  var SYSVAR_STAKE_HISTORY_PUBKEY = new PublicKey(\"SysvarStakeHistory1111111111111111111111111\");\n  var SendTransactionError = class extends Error {\n    constructor({\n      action,\n      signature,\n      transactionMessage,\n      logs\n    }) {\n      const maybeLogsOutput = logs ? `Logs: \n${JSON.stringify(logs.slice(-10), null, 2)}. ` : \"\";\n      const guideText = \"\\nCatch the `SendTransactionError` and call `getLogs()` on it for full details.\";\n      let message;\n      switch (action) {\n        case \"send\":\n          message = `Transaction ${signature} resulted in an error. \n${transactionMessage}. ` + maybeLogsOutput + guideText;\n          break;\n        case \"simulate\":\n          message = `Simulation failed. \nMessage: ${transactionMessage}. \n` + maybeLogsOutput + guideText;\n          break;\n        default: {\n          message = `Unknown action '${/* @__PURE__ */ ((a) => a)(action)}'`;\n        }\n      }\n      super(message);\n      this.signature = void 0;\n      this.transactionMessage = void 0;\n      this.transactionLogs = void 0;\n      this.signature = signature;\n      this.transactionMessage = transactionMessage;\n      this.transactionLogs = logs ? logs : void 0;\n    }\n    get transactionError() {\n      return {\n        message: this.transactionMessage,\n        logs: Array.isArray(this.transactionLogs) ? this.transactionLogs : void 0\n      };\n    }\n    /* @deprecated Use `await getLogs()` instead */\n    get logs() {\n      const cachedLogs = this.transactionLogs;\n      if (cachedLogs != null && typeof cachedLogs === \"object\" && \"then\" in cachedLogs) {\n        return void 0;\n      }\n      return cachedLogs;\n    }\n    async getLogs(connection) {\n      if (!Array.isArray(this.transactionLogs)) {\n        this.transactionLogs = new Promise((resolve, reject) => {\n          connection.getTransaction(this.signature).then((tx) => {\n            if (tx && tx.meta && tx.meta.logMessages) {\n              const logs = tx.meta.logMessages;\n              this.transactionLogs = logs;\n              resolve(logs);\n            } else {\n              reject(new Error(\"Log messages not found\"));\n            }\n          }).catch(reject);\n        });\n      }\n      return await this.transactionLogs;\n    }\n  };\n  async function sendAndConfirmTransaction(connection, transaction, signers, options) {\n    const sendOptions = options && {\n      skipPreflight: options.skipPreflight,\n      preflightCommitment: options.preflightCommitment || options.commitment,\n      maxRetries: options.maxRetries,\n      minContextSlot: options.minContextSlot\n    };\n    const signature = await connection.sendTransaction(transaction, signers, sendOptions);\n    let status;\n    if (transaction.recentBlockhash != null && transaction.lastValidBlockHeight != null) {\n      status = (await connection.confirmTransaction({\n        abortSignal: options?.abortSignal,\n        signature,\n        blockhash: transaction.recentBlockhash,\n        lastValidBlockHeight: transaction.lastValidBlockHeight\n      }, options && options.commitment)).value;\n    } else if (transaction.minNonceContextSlot != null && transaction.nonceInfo != null) {\n      const {\n        nonceInstruction\n      } = transaction.nonceInfo;\n      const nonceAccountPubkey = nonceInstruction.keys[0].pubkey;\n      status = (await connection.confirmTransaction({\n        abortSignal: options?.abortSignal,\n        minContextSlot: transaction.minNonceContextSlot,\n        nonceAccountPubkey,\n        nonceValue: transaction.nonceInfo.nonce,\n        signature\n      }, options && options.commitment)).value;\n    } else {\n      if (options?.abortSignal != null) {\n        console.warn(\"sendAndConfirmTransaction(): A transaction with a deprecated confirmation strategy was supplied along with an `abortSignal`. Only transactions having `lastValidBlockHeight` or a combination of `nonceInfo` and `minNonceContextSlot` are abortable.\");\n      }\n      status = (await connection.confirmTransaction(signature, options && options.commitment)).value;\n    }\n    if (status.err) {\n      if (signature != null) {\n        throw new SendTransactionError({\n          action: \"send\",\n          signature,\n          transactionMessage: `Status: (${JSON.stringify(status)})`\n        });\n      }\n      throw new Error(`Transaction ${signature} failed (${JSON.stringify(status)})`);\n    }\n    return signature;\n  }\n  function sleep(ms) {\n    return new Promise((resolve) => setTimeout(resolve, ms));\n  }\n  function encodeData(type2, fields) {\n    const allocLength = type2.layout.span >= 0 ? type2.layout.span : getAlloc(type2, fields);\n    const data = Buffer2.alloc(allocLength);\n    const layoutFields = Object.assign({\n      instruction: type2.index\n    }, fields);\n    type2.layout.encode(layoutFields, data);\n    return data;\n  }\n  var FeeCalculatorLayout = BufferLayout.nu64(\"lamportsPerSignature\");\n  var NonceAccountLayout = BufferLayout.struct([BufferLayout.u32(\"version\"), BufferLayout.u32(\"state\"), publicKey(\"authorizedPubkey\"), publicKey(\"nonce\"), BufferLayout.struct([FeeCalculatorLayout], \"feeCalculator\")]);\n  var NONCE_ACCOUNT_LENGTH = NonceAccountLayout.span;\n  function u64(property) {\n    const layout = (0, import_buffer_layout.blob)(8, property);\n    const decode = layout.decode.bind(layout);\n    const encode = layout.encode.bind(layout);\n    const bigIntLayout = layout;\n    const codec = getU64Codec();\n    bigIntLayout.decode = (buffer, offset2) => {\n      const src = decode(buffer, offset2);\n      return codec.decode(src);\n    };\n    bigIntLayout.encode = (bigInt, buffer, offset2) => {\n      const src = codec.encode(bigInt);\n      return encode(src, buffer, offset2);\n    };\n    return bigIntLayout;\n  }\n  var SYSTEM_INSTRUCTION_LAYOUTS = Object.freeze({\n    Create: {\n      index: 0,\n      layout: BufferLayout.struct([BufferLayout.u32(\"instruction\"), BufferLayout.ns64(\"lamports\"), BufferLayout.ns64(\"space\"), publicKey(\"programId\")])\n    },\n    Assign: {\n      index: 1,\n      layout: BufferLayout.struct([BufferLayout.u32(\"instruction\"), publicKey(\"programId\")])\n    },\n    Transfer: {\n      index: 2,\n      layout: BufferLayout.struct([BufferLayout.u32(\"instruction\"), u64(\"lamports\")])\n    },\n    CreateWithSeed: {\n      index: 3,\n      layout: BufferLayout.struct([BufferLayout.u32(\"instruction\"), publicKey(\"base\"), rustString(\"seed\"), BufferLayout.ns64(\"lamports\"), BufferLayout.ns64(\"space\"), publicKey(\"programId\")])\n    },\n    AdvanceNonceAccount: {\n      index: 4,\n      layout: BufferLayout.struct([BufferLayout.u32(\"instruction\")])\n    },\n    WithdrawNonceAccount: {\n      index: 5,\n      layout: BufferLayout.struct([BufferLayout.u32(\"instruction\"), BufferLayout.ns64(\"lamports\")])\n    },\n    InitializeNonceAccount: {\n      index: 6,\n      layout: BufferLayout.struct([BufferLayout.u32(\"instruction\"), publicKey(\"authorized\")])\n    },\n    AuthorizeNonceAccount: {\n      index: 7,\n      layout: BufferLayout.struct([BufferLayout.u32(\"instruction\"), publicKey(\"authorized\")])\n    },\n    Allocate: {\n      index: 8,\n      layout: BufferLayout.struct([BufferLayout.u32(\"instruction\"), BufferLayout.ns64(\"space\")])\n    },\n    AllocateWithSeed: {\n      index: 9,\n      layout: BufferLayout.struct([BufferLayout.u32(\"instruction\"), publicKey(\"base\"), rustString(\"seed\"), BufferLayout.ns64(\"space\"), publicKey(\"programId\")])\n    },\n    AssignWithSeed: {\n      index: 10,\n      layout: BufferLayout.struct([BufferLayout.u32(\"instruction\"), publicKey(\"base\"), rustString(\"seed\"), publicKey(\"programId\")])\n    },\n    TransferWithSeed: {\n      index: 11,\n      layout: BufferLayout.struct([BufferLayout.u32(\"instruction\"), u64(\"lamports\"), rustString(\"seed\"), publicKey(\"programId\")])\n    },\n    UpgradeNonceAccount: {\n      index: 12,\n      layout: BufferLayout.struct([BufferLayout.u32(\"instruction\")])\n    }\n  });\n  var SystemProgram = class _SystemProgram {\n    /**\n     * @internal\n     */\n    constructor() {\n    }\n    /**\n     * Public key that identifies the System program\n     */\n    /**\n     * Generate a transaction instruction that creates a new account\n     */\n    static createAccount(params) {\n      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.Create;\n      const data = encodeData(type2, {\n        lamports: params.lamports,\n        space: params.space,\n        programId: toBuffer(params.programId.toBuffer())\n      });\n      return new TransactionInstruction({\n        keys: [{\n          pubkey: params.fromPubkey,\n          isSigner: true,\n          isWritable: true\n        }, {\n          pubkey: params.newAccountPubkey,\n          isSigner: true,\n          isWritable: true\n        }],\n        programId: this.programId,\n        data\n      });\n    }\n    /**\n     * Generate a transaction instruction that transfers lamports from one account to another\n     */\n    static transfer(params) {\n      let data;\n      let keys;\n      if (\"basePubkey\" in params) {\n        const type2 = SYSTEM_INSTRUCTION_LAYOUTS.TransferWithSeed;\n        data = encodeData(type2, {\n          lamports: BigInt(params.lamports),\n          seed: params.seed,\n          programId: toBuffer(params.programId.toBuffer())\n        });\n        keys = [{\n          pubkey: params.fromPubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: params.basePubkey,\n          isSigner: true,\n          isWritable: false\n        }, {\n          pubkey: params.toPubkey,\n          isSigner: false,\n          isWritable: true\n        }];\n      } else {\n        const type2 = SYSTEM_INSTRUCTION_LAYOUTS.Transfer;\n        data = encodeData(type2, {\n          lamports: BigInt(params.lamports)\n        });\n        keys = [{\n          pubkey: params.fromPubkey,\n          isSigner: true,\n          isWritable: true\n        }, {\n          pubkey: params.toPubkey,\n          isSigner: false,\n          isWritable: true\n        }];\n      }\n      return new TransactionInstruction({\n        keys,\n        programId: this.programId,\n        data\n      });\n    }\n    /**\n     * Generate a transaction instruction that assigns an account to a program\n     */\n    static assign(params) {\n      let data;\n      let keys;\n      if (\"basePubkey\" in params) {\n        const type2 = SYSTEM_INSTRUCTION_LAYOUTS.AssignWithSeed;\n        data = encodeData(type2, {\n          base: toBuffer(params.basePubkey.toBuffer()),\n          seed: params.seed,\n          programId: toBuffer(params.programId.toBuffer())\n        });\n        keys = [{\n          pubkey: params.accountPubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: params.basePubkey,\n          isSigner: true,\n          isWritable: false\n        }];\n      } else {\n        const type2 = SYSTEM_INSTRUCTION_LAYOUTS.Assign;\n        data = encodeData(type2, {\n          programId: toBuffer(params.programId.toBuffer())\n        });\n        keys = [{\n          pubkey: params.accountPubkey,\n          isSigner: true,\n          isWritable: true\n        }];\n      }\n      return new TransactionInstruction({\n        keys,\n        programId: this.programId,\n        data\n      });\n    }\n    /**\n     * Generate a transaction instruction that creates a new account at\n     *   an address generated with `from`, a seed, and programId\n     */\n    static createAccountWithSeed(params) {\n      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.CreateWithSeed;\n      const data = encodeData(type2, {\n        base: toBuffer(params.basePubkey.toBuffer()),\n        seed: params.seed,\n        lamports: params.lamports,\n        space: params.space,\n        programId: toBuffer(params.programId.toBuffer())\n      });\n      let keys = [{\n        pubkey: params.fromPubkey,\n        isSigner: true,\n        isWritable: true\n      }, {\n        pubkey: params.newAccountPubkey,\n        isSigner: false,\n        isWritable: true\n      }];\n      if (!params.basePubkey.equals(params.fromPubkey)) {\n        keys.push({\n          pubkey: params.basePubkey,\n          isSigner: true,\n          isWritable: false\n        });\n      }\n      return new TransactionInstruction({\n        keys,\n        programId: this.programId,\n        data\n      });\n    }\n    /**\n     * Generate a transaction that creates a new Nonce account\n     */\n    static createNonceAccount(params) {\n      const transaction = new Transaction();\n      if (\"basePubkey\" in params && \"seed\" in params) {\n        transaction.add(_SystemProgram.createAccountWithSeed({\n          fromPubkey: params.fromPubkey,\n          newAccountPubkey: params.noncePubkey,\n          basePubkey: params.basePubkey,\n          seed: params.seed,\n          lamports: params.lamports,\n          space: NONCE_ACCOUNT_LENGTH,\n          programId: this.programId\n        }));\n      } else {\n        transaction.add(_SystemProgram.createAccount({\n          fromPubkey: params.fromPubkey,\n          newAccountPubkey: params.noncePubkey,\n          lamports: params.lamports,\n          space: NONCE_ACCOUNT_LENGTH,\n          programId: this.programId\n        }));\n      }\n      const initParams = {\n        noncePubkey: params.noncePubkey,\n        authorizedPubkey: params.authorizedPubkey\n      };\n      transaction.add(this.nonceInitialize(initParams));\n      return transaction;\n    }\n    /**\n     * Generate an instruction to initialize a Nonce account\n     */\n    static nonceInitialize(params) {\n      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.InitializeNonceAccount;\n      const data = encodeData(type2, {\n        authorized: toBuffer(params.authorizedPubkey.toBuffer())\n      });\n      const instructionData = {\n        keys: [{\n          pubkey: params.noncePubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: SYSVAR_RENT_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data\n      };\n      return new TransactionInstruction(instructionData);\n    }\n    /**\n     * Generate an instruction to advance the nonce in a Nonce account\n     */\n    static nonceAdvance(params) {\n      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.AdvanceNonceAccount;\n      const data = encodeData(type2);\n      const instructionData = {\n        keys: [{\n          pubkey: params.noncePubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: params.authorizedPubkey,\n          isSigner: true,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data\n      };\n      return new TransactionInstruction(instructionData);\n    }\n    /**\n     * Generate a transaction instruction that withdraws lamports from a Nonce account\n     */\n    static nonceWithdraw(params) {\n      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.WithdrawNonceAccount;\n      const data = encodeData(type2, {\n        lamports: params.lamports\n      });\n      return new TransactionInstruction({\n        keys: [{\n          pubkey: params.noncePubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: params.toPubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: SYSVAR_RECENT_BLOCKHASHES_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: SYSVAR_RENT_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: params.authorizedPubkey,\n          isSigner: true,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data\n      });\n    }\n    /**\n     * Generate a transaction instruction that authorizes a new PublicKey as the authority\n     * on a Nonce account.\n     */\n    static nonceAuthorize(params) {\n      const type2 = SYSTEM_INSTRUCTION_LAYOUTS.AuthorizeNonceAccount;\n      const data = encodeData(type2, {\n        authorized: toBuffer(params.newAuthorizedPubkey.toBuffer())\n      });\n      return new TransactionInstruction({\n        keys: [{\n          pubkey: params.noncePubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: params.authorizedPubkey,\n          isSigner: true,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data\n      });\n    }\n    /**\n     * Generate a transaction instruction that allocates space in an account without funding\n     */\n    static allocate(params) {\n      let data;\n      let keys;\n      if (\"basePubkey\" in params) {\n        const type2 = SYSTEM_INSTRUCTION_LAYOUTS.AllocateWithSeed;\n        data = encodeData(type2, {\n          base: toBuffer(params.basePubkey.toBuffer()),\n          seed: params.seed,\n          space: params.space,\n          programId: toBuffer(params.programId.toBuffer())\n        });\n        keys = [{\n          pubkey: params.accountPubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: params.basePubkey,\n          isSigner: true,\n          isWritable: false\n        }];\n      } else {\n        const type2 = SYSTEM_INSTRUCTION_LAYOUTS.Allocate;\n        data = encodeData(type2, {\n          space: params.space\n        });\n        keys = [{\n          pubkey: params.accountPubkey,\n          isSigner: true,\n          isWritable: true\n        }];\n      }\n      return new TransactionInstruction({\n        keys,\n        programId: this.programId,\n        data\n      });\n    }\n  };\n  SystemProgram.programId = new PublicKey(\"11111111111111111111111111111111\");\n  var CHUNK_SIZE = PACKET_DATA_SIZE - 300;\n  var Loader = class _Loader {\n    /**\n     * @internal\n     */\n    constructor() {\n    }\n    /**\n     * Amount of program data placed in each load Transaction\n     */\n    /**\n     * Minimum number of signatures required to load a program not including\n     * retries\n     *\n     * Can be used to calculate transaction fees\n     */\n    static getMinNumSignatures(dataLength) {\n      return 2 * // Every transaction requires two signatures (payer + program)\n      (Math.ceil(dataLength / _Loader.chunkSize) + 1 + // Add one for Create transaction\n      1);\n    }\n    /**\n     * Loads a generic program\n     *\n     * @param connection The connection to use\n     * @param payer System account that pays to load the program\n     * @param program Account to load the program into\n     * @param programId Public key that identifies the loader\n     * @param data Program octets\n     * @return true if program was loaded successfully, false if program was already loaded\n     */\n    static async load(connection, payer, program, programId, data) {\n      {\n        const balanceNeeded = await connection.getMinimumBalanceForRentExemption(data.length);\n        const programInfo = await connection.getAccountInfo(program.publicKey, \"confirmed\");\n        let transaction = null;\n        if (programInfo !== null) {\n          if (programInfo.executable) {\n            console.error(\"Program load failed, account is already executable\");\n            return false;\n          }\n          if (programInfo.data.length !== data.length) {\n            transaction = transaction || new Transaction();\n            transaction.add(SystemProgram.allocate({\n              accountPubkey: program.publicKey,\n              space: data.length\n            }));\n          }\n          if (!programInfo.owner.equals(programId)) {\n            transaction = transaction || new Transaction();\n            transaction.add(SystemProgram.assign({\n              accountPubkey: program.publicKey,\n              programId\n            }));\n          }\n          if (programInfo.lamports < balanceNeeded) {\n            transaction = transaction || new Transaction();\n            transaction.add(SystemProgram.transfer({\n              fromPubkey: payer.publicKey,\n              toPubkey: program.publicKey,\n              lamports: balanceNeeded - programInfo.lamports\n            }));\n          }\n        } else {\n          transaction = new Transaction().add(SystemProgram.createAccount({\n            fromPubkey: payer.publicKey,\n            newAccountPubkey: program.publicKey,\n            lamports: balanceNeeded > 0 ? balanceNeeded : 1,\n            space: data.length,\n            programId\n          }));\n        }\n        if (transaction !== null) {\n          await sendAndConfirmTransaction(connection, transaction, [payer, program], {\n            commitment: \"confirmed\"\n          });\n        }\n      }\n      const dataLayout = BufferLayout.struct([BufferLayout.u32(\"instruction\"), BufferLayout.u32(\"offset\"), BufferLayout.u32(\"bytesLength\"), BufferLayout.u32(\"bytesLengthPadding\"), BufferLayout.seq(BufferLayout.u8(\"byte\"), BufferLayout.offset(BufferLayout.u32(), -8), \"bytes\")]);\n      const chunkSize = _Loader.chunkSize;\n      let offset2 = 0;\n      let array2 = data;\n      let transactions = [];\n      while (array2.length > 0) {\n        const bytes = array2.slice(0, chunkSize);\n        const data2 = Buffer2.alloc(chunkSize + 16);\n        dataLayout.encode({\n          instruction: 0,\n          // Load instruction\n          offset: offset2,\n          bytes,\n          bytesLength: 0,\n          bytesLengthPadding: 0\n        }, data2);\n        const transaction = new Transaction().add({\n          keys: [{\n            pubkey: program.publicKey,\n            isSigner: true,\n            isWritable: true\n          }],\n          programId,\n          data: data2\n        });\n        transactions.push(sendAndConfirmTransaction(connection, transaction, [payer, program], {\n          commitment: \"confirmed\"\n        }));\n        if (connection._rpcEndpoint.includes(\"solana.com\")) {\n          const REQUESTS_PER_SECOND = 4;\n          await sleep(1e3 / REQUESTS_PER_SECOND);\n        }\n        offset2 += chunkSize;\n        array2 = array2.slice(chunkSize);\n      }\n      await Promise.all(transactions);\n      {\n        const dataLayout2 = BufferLayout.struct([BufferLayout.u32(\"instruction\")]);\n        const data2 = Buffer2.alloc(dataLayout2.span);\n        dataLayout2.encode({\n          instruction: 1\n          // Finalize instruction\n        }, data2);\n        const transaction = new Transaction().add({\n          keys: [{\n            pubkey: program.publicKey,\n            isSigner: true,\n            isWritable: true\n          }, {\n            pubkey: SYSVAR_RENT_PUBKEY,\n            isSigner: false,\n            isWritable: false\n          }],\n          programId,\n          data: data2\n        });\n        const deployCommitment = \"processed\";\n        const finalizeSignature = await connection.sendTransaction(transaction, [payer, program], {\n          preflightCommitment: deployCommitment\n        });\n        const {\n          context,\n          value\n        } = await connection.confirmTransaction({\n          signature: finalizeSignature,\n          lastValidBlockHeight: transaction.lastValidBlockHeight,\n          blockhash: transaction.recentBlockhash\n        }, deployCommitment);\n        if (value.err) {\n          throw new Error(`Transaction ${finalizeSignature} failed (${JSON.stringify(value)})`);\n        }\n        while (true) {\n          try {\n            const currentSlot = await connection.getSlot({\n              commitment: deployCommitment\n            });\n            if (currentSlot > context.slot) {\n              break;\n            }\n          } catch {\n          }\n          await new Promise((resolve) => setTimeout(resolve, Math.round(MS_PER_SLOT / 2)));\n        }\n      }\n      return true;\n    }\n  };\n  Loader.chunkSize = CHUNK_SIZE;\n  var BPF_LOADER_PROGRAM_ID = new PublicKey(\"BPFLoader2111111111111111111111111111111111\");\n  var fetchImpl = globalThis.fetch;\n  var LookupTableMetaLayout = {\n    index: 1,\n    layout: BufferLayout.struct([\n      BufferLayout.u32(\"typeIndex\"),\n      u64(\"deactivationSlot\"),\n      BufferLayout.nu64(\"lastExtendedSlot\"),\n      BufferLayout.u8(\"lastExtendedStartIndex\"),\n      BufferLayout.u8(),\n      // option\n      BufferLayout.seq(publicKey(), BufferLayout.offset(BufferLayout.u8(), -1), \"authority\")\n    ])\n  };\n  var PublicKeyFromString = coerce(instance(PublicKey), string(), (value) => new PublicKey(value));\n  var RawAccountDataResult = tuple([string(), literal(\"base64\")]);\n  var BufferFromRawAccountData = coerce(instance(Buffer2), RawAccountDataResult, (value) => Buffer2.from(value[0], \"base64\"));\n  var BLOCKHASH_CACHE_TIMEOUT_MS = 30 * 1e3;\n  function createRpcResult(result) {\n    return union([type({\n      jsonrpc: literal(\"2.0\"),\n      id: string(),\n      result\n    }), type({\n      jsonrpc: literal(\"2.0\"),\n      id: string(),\n      error: type({\n        code: unknown(),\n        message: string(),\n        data: optional(any())\n      })\n    })]);\n  }\n  var UnknownRpcResult = createRpcResult(unknown());\n  function jsonRpcResult(schema) {\n    return coerce(createRpcResult(schema), UnknownRpcResult, (value) => {\n      if (\"error\" in value) {\n        return value;\n      } else {\n        return {\n          ...value,\n          result: create(value.result, schema)\n        };\n      }\n    });\n  }\n  function jsonRpcResultAndContext(value) {\n    return jsonRpcResult(type({\n      context: type({\n        slot: number()\n      }),\n      value\n    }));\n  }\n  function notificationResultAndContext(value) {\n    return type({\n      context: type({\n        slot: number()\n      }),\n      value\n    });\n  }\n  var GetInflationGovernorResult = type({\n    foundation: number(),\n    foundationTerm: number(),\n    initial: number(),\n    taper: number(),\n    terminal: number()\n  });\n  var GetInflationRewardResult = jsonRpcResult(array(nullable(type({\n    epoch: number(),\n    effectiveSlot: number(),\n    amount: number(),\n    postBalance: number(),\n    commission: optional(nullable(number()))\n  }))));\n  var GetRecentPrioritizationFeesResult = array(type({\n    slot: number(),\n    prioritizationFee: number()\n  }));\n  var GetInflationRateResult = type({\n    total: number(),\n    validator: number(),\n    foundation: number(),\n    epoch: number()\n  });\n  var GetEpochInfoResult = type({\n    epoch: number(),\n    slotIndex: number(),\n    slotsInEpoch: number(),\n    absoluteSlot: number(),\n    blockHeight: optional(number()),\n    transactionCount: optional(number())\n  });\n  var GetEpochScheduleResult = type({\n    slotsPerEpoch: number(),\n    leaderScheduleSlotOffset: number(),\n    warmup: boolean(),\n    firstNormalEpoch: number(),\n    firstNormalSlot: number()\n  });\n  var GetLeaderScheduleResult = record(string(), array(number()));\n  var TransactionErrorResult = nullable(union([type({}), string()]));\n  var SignatureStatusResult = type({\n    err: TransactionErrorResult\n  });\n  var SignatureReceivedResult = literal(\"receivedSignature\");\n  var VersionResult = type({\n    \"solana-core\": string(),\n    \"feature-set\": optional(number())\n  });\n  var ParsedInstructionStruct = type({\n    program: string(),\n    programId: PublicKeyFromString,\n    parsed: unknown()\n  });\n  var PartiallyDecodedInstructionStruct = type({\n    programId: PublicKeyFromString,\n    accounts: array(PublicKeyFromString),\n    data: string()\n  });\n  var SimulatedTransactionResponseStruct = jsonRpcResultAndContext(type({\n    err: nullable(union([type({}), string()])),\n    logs: nullable(array(string())),\n    accounts: optional(nullable(array(nullable(type({\n      executable: boolean(),\n      owner: string(),\n      lamports: number(),\n      data: array(string()),\n      rentEpoch: optional(number())\n    }))))),\n    unitsConsumed: optional(number()),\n    returnData: optional(nullable(type({\n      programId: string(),\n      data: tuple([string(), literal(\"base64\")])\n    }))),\n    innerInstructions: optional(nullable(array(type({\n      index: number(),\n      instructions: array(union([ParsedInstructionStruct, PartiallyDecodedInstructionStruct]))\n    }))))\n  }));\n  var BlockProductionResponseStruct = jsonRpcResultAndContext(type({\n    byIdentity: record(string(), array(number())),\n    range: type({\n      firstSlot: number(),\n      lastSlot: number()\n    })\n  }));\n  var GetInflationGovernorRpcResult = jsonRpcResult(GetInflationGovernorResult);\n  var GetInflationRateRpcResult = jsonRpcResult(GetInflationRateResult);\n  var GetRecentPrioritizationFeesRpcResult = jsonRpcResult(GetRecentPrioritizationFeesResult);\n  var GetEpochInfoRpcResult = jsonRpcResult(GetEpochInfoResult);\n  var GetEpochScheduleRpcResult = jsonRpcResult(GetEpochScheduleResult);\n  var GetLeaderScheduleRpcResult = jsonRpcResult(GetLeaderScheduleResult);\n  var SlotRpcResult = jsonRpcResult(number());\n  var GetSupplyRpcResult = jsonRpcResultAndContext(type({\n    total: number(),\n    circulating: number(),\n    nonCirculating: number(),\n    nonCirculatingAccounts: array(PublicKeyFromString)\n  }));\n  var TokenAmountResult = type({\n    amount: string(),\n    uiAmount: nullable(number()),\n    decimals: number(),\n    uiAmountString: optional(string())\n  });\n  var GetTokenLargestAccountsResult = jsonRpcResultAndContext(array(type({\n    address: PublicKeyFromString,\n    amount: string(),\n    uiAmount: nullable(number()),\n    decimals: number(),\n    uiAmountString: optional(string())\n  })));\n  var GetTokenAccountsByOwner = jsonRpcResultAndContext(array(type({\n    pubkey: PublicKeyFromString,\n    account: type({\n      executable: boolean(),\n      owner: PublicKeyFromString,\n      lamports: number(),\n      data: BufferFromRawAccountData,\n      rentEpoch: number()\n    })\n  })));\n  var ParsedAccountDataResult = type({\n    program: string(),\n    parsed: unknown(),\n    space: number()\n  });\n  var GetParsedTokenAccountsByOwner = jsonRpcResultAndContext(array(type({\n    pubkey: PublicKeyFromString,\n    account: type({\n      executable: boolean(),\n      owner: PublicKeyFromString,\n      lamports: number(),\n      data: ParsedAccountDataResult,\n      rentEpoch: number()\n    })\n  })));\n  var GetLargestAccountsRpcResult = jsonRpcResultAndContext(array(type({\n    lamports: number(),\n    address: PublicKeyFromString\n  })));\n  var AccountInfoResult = type({\n    executable: boolean(),\n    owner: PublicKeyFromString,\n    lamports: number(),\n    data: BufferFromRawAccountData,\n    rentEpoch: number()\n  });\n  var KeyedAccountInfoResult = type({\n    pubkey: PublicKeyFromString,\n    account: AccountInfoResult\n  });\n  var ParsedOrRawAccountData = coerce(union([instance(Buffer2), ParsedAccountDataResult]), union([RawAccountDataResult, ParsedAccountDataResult]), (value) => {\n    if (Array.isArray(value)) {\n      return create(value, BufferFromRawAccountData);\n    } else {\n      return value;\n    }\n  });\n  var ParsedAccountInfoResult = type({\n    executable: boolean(),\n    owner: PublicKeyFromString,\n    lamports: number(),\n    data: ParsedOrRawAccountData,\n    rentEpoch: number()\n  });\n  var KeyedParsedAccountInfoResult = type({\n    pubkey: PublicKeyFromString,\n    account: ParsedAccountInfoResult\n  });\n  var StakeActivationResult = type({\n    state: union([literal(\"active\"), literal(\"inactive\"), literal(\"activating\"), literal(\"deactivating\")]),\n    active: number(),\n    inactive: number()\n  });\n  var GetConfirmedSignaturesForAddress2RpcResult = jsonRpcResult(array(type({\n    signature: string(),\n    slot: number(),\n    err: TransactionErrorResult,\n    memo: nullable(string()),\n    blockTime: optional(nullable(number()))\n  })));\n  var GetSignaturesForAddressRpcResult = jsonRpcResult(array(type({\n    signature: string(),\n    slot: number(),\n    err: TransactionErrorResult,\n    memo: nullable(string()),\n    blockTime: optional(nullable(number()))\n  })));\n  var AccountNotificationResult = type({\n    subscription: number(),\n    result: notificationResultAndContext(AccountInfoResult)\n  });\n  var ProgramAccountInfoResult = type({\n    pubkey: PublicKeyFromString,\n    account: AccountInfoResult\n  });\n  var ProgramAccountNotificationResult = type({\n    subscription: number(),\n    result: notificationResultAndContext(ProgramAccountInfoResult)\n  });\n  var SlotInfoResult = type({\n    parent: number(),\n    slot: number(),\n    root: number()\n  });\n  var SlotNotificationResult = type({\n    subscription: number(),\n    result: SlotInfoResult\n  });\n  var SlotUpdateResult = union([type({\n    type: union([literal(\"firstShredReceived\"), literal(\"completed\"), literal(\"optimisticConfirmation\"), literal(\"root\")]),\n    slot: number(),\n    timestamp: number()\n  }), type({\n    type: literal(\"createdBank\"),\n    parent: number(),\n    slot: number(),\n    timestamp: number()\n  }), type({\n    type: literal(\"frozen\"),\n    slot: number(),\n    timestamp: number(),\n    stats: type({\n      numTransactionEntries: number(),\n      numSuccessfulTransactions: number(),\n      numFailedTransactions: number(),\n      maxTransactionsPerEntry: number()\n    })\n  }), type({\n    type: literal(\"dead\"),\n    slot: number(),\n    timestamp: number(),\n    err: string()\n  })]);\n  var SlotUpdateNotificationResult = type({\n    subscription: number(),\n    result: SlotUpdateResult\n  });\n  var SignatureNotificationResult = type({\n    subscription: number(),\n    result: notificationResultAndContext(union([SignatureStatusResult, SignatureReceivedResult]))\n  });\n  var RootNotificationResult = type({\n    subscription: number(),\n    result: number()\n  });\n  var ContactInfoResult = type({\n    pubkey: string(),\n    gossip: nullable(string()),\n    tpu: nullable(string()),\n    rpc: nullable(string()),\n    version: nullable(string())\n  });\n  var VoteAccountInfoResult = type({\n    votePubkey: string(),\n    nodePubkey: string(),\n    activatedStake: number(),\n    epochVoteAccount: boolean(),\n    epochCredits: array(tuple([number(), number(), number()])),\n    commission: number(),\n    lastVote: number(),\n    rootSlot: nullable(number())\n  });\n  var GetVoteAccounts = jsonRpcResult(type({\n    current: array(VoteAccountInfoResult),\n    delinquent: array(VoteAccountInfoResult)\n  }));\n  var ConfirmationStatus = union([literal(\"processed\"), literal(\"confirmed\"), literal(\"finalized\")]);\n  var SignatureStatusResponse = type({\n    slot: number(),\n    confirmations: nullable(number()),\n    err: TransactionErrorResult,\n    confirmationStatus: optional(ConfirmationStatus)\n  });\n  var GetSignatureStatusesRpcResult = jsonRpcResultAndContext(array(nullable(SignatureStatusResponse)));\n  var GetMinimumBalanceForRentExemptionRpcResult = jsonRpcResult(number());\n  var AddressTableLookupStruct = type({\n    accountKey: PublicKeyFromString,\n    writableIndexes: array(number()),\n    readonlyIndexes: array(number())\n  });\n  var ConfirmedTransactionResult = type({\n    signatures: array(string()),\n    message: type({\n      accountKeys: array(string()),\n      header: type({\n        numRequiredSignatures: number(),\n        numReadonlySignedAccounts: number(),\n        numReadonlyUnsignedAccounts: number()\n      }),\n      instructions: array(type({\n        accounts: array(number()),\n        data: string(),\n        programIdIndex: number()\n      })),\n      recentBlockhash: string(),\n      addressTableLookups: optional(array(AddressTableLookupStruct))\n    })\n  });\n  var AnnotatedAccountKey = type({\n    pubkey: PublicKeyFromString,\n    signer: boolean(),\n    writable: boolean(),\n    source: optional(union([literal(\"transaction\"), literal(\"lookupTable\")]))\n  });\n  var ConfirmedTransactionAccountsModeResult = type({\n    accountKeys: array(AnnotatedAccountKey),\n    signatures: array(string())\n  });\n  var ParsedInstructionResult = type({\n    parsed: unknown(),\n    program: string(),\n    programId: PublicKeyFromString\n  });\n  var RawInstructionResult = type({\n    accounts: array(PublicKeyFromString),\n    data: string(),\n    programId: PublicKeyFromString\n  });\n  var InstructionResult = union([RawInstructionResult, ParsedInstructionResult]);\n  var UnknownInstructionResult = union([type({\n    parsed: unknown(),\n    program: string(),\n    programId: string()\n  }), type({\n    accounts: array(string()),\n    data: string(),\n    programId: string()\n  })]);\n  var ParsedOrRawInstruction = coerce(InstructionResult, UnknownInstructionResult, (value) => {\n    if (\"accounts\" in value) {\n      return create(value, RawInstructionResult);\n    } else {\n      return create(value, ParsedInstructionResult);\n    }\n  });\n  var ParsedConfirmedTransactionResult = type({\n    signatures: array(string()),\n    message: type({\n      accountKeys: array(AnnotatedAccountKey),\n      instructions: array(ParsedOrRawInstruction),\n      recentBlockhash: string(),\n      addressTableLookups: optional(nullable(array(AddressTableLookupStruct)))\n    })\n  });\n  var TokenBalanceResult = type({\n    accountIndex: number(),\n    mint: string(),\n    owner: optional(string()),\n    programId: optional(string()),\n    uiTokenAmount: TokenAmountResult\n  });\n  var LoadedAddressesResult = type({\n    writable: array(PublicKeyFromString),\n    readonly: array(PublicKeyFromString)\n  });\n  var ConfirmedTransactionMetaResult = type({\n    err: TransactionErrorResult,\n    fee: number(),\n    innerInstructions: optional(nullable(array(type({\n      index: number(),\n      instructions: array(type({\n        accounts: array(number()),\n        data: string(),\n        programIdIndex: number()\n      }))\n    })))),\n    preBalances: array(number()),\n    postBalances: array(number()),\n    logMessages: optional(nullable(array(string()))),\n    preTokenBalances: optional(nullable(array(TokenBalanceResult))),\n    postTokenBalances: optional(nullable(array(TokenBalanceResult))),\n    loadedAddresses: optional(LoadedAddressesResult),\n    computeUnitsConsumed: optional(number()),\n    costUnits: optional(number())\n  });\n  var ParsedConfirmedTransactionMetaResult = type({\n    err: TransactionErrorResult,\n    fee: number(),\n    innerInstructions: optional(nullable(array(type({\n      index: number(),\n      instructions: array(ParsedOrRawInstruction)\n    })))),\n    preBalances: array(number()),\n    postBalances: array(number()),\n    logMessages: optional(nullable(array(string()))),\n    preTokenBalances: optional(nullable(array(TokenBalanceResult))),\n    postTokenBalances: optional(nullable(array(TokenBalanceResult))),\n    loadedAddresses: optional(LoadedAddressesResult),\n    computeUnitsConsumed: optional(number()),\n    costUnits: optional(number())\n  });\n  var TransactionVersionStruct = union([literal(0), literal(\"legacy\")]);\n  var RewardsResult = type({\n    pubkey: string(),\n    lamports: number(),\n    postBalance: nullable(number()),\n    rewardType: nullable(string()),\n    commission: optional(nullable(number()))\n  });\n  var GetBlockRpcResult = jsonRpcResult(nullable(type({\n    blockhash: string(),\n    previousBlockhash: string(),\n    parentSlot: number(),\n    transactions: array(type({\n      transaction: ConfirmedTransactionResult,\n      meta: nullable(ConfirmedTransactionMetaResult),\n      version: optional(TransactionVersionStruct)\n    })),\n    rewards: optional(array(RewardsResult)),\n    blockTime: nullable(number()),\n    blockHeight: nullable(number())\n  })));\n  var GetNoneModeBlockRpcResult = jsonRpcResult(nullable(type({\n    blockhash: string(),\n    previousBlockhash: string(),\n    parentSlot: number(),\n    rewards: optional(array(RewardsResult)),\n    blockTime: nullable(number()),\n    blockHeight: nullable(number())\n  })));\n  var GetAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({\n    blockhash: string(),\n    previousBlockhash: string(),\n    parentSlot: number(),\n    transactions: array(type({\n      transaction: ConfirmedTransactionAccountsModeResult,\n      meta: nullable(ConfirmedTransactionMetaResult),\n      version: optional(TransactionVersionStruct)\n    })),\n    rewards: optional(array(RewardsResult)),\n    blockTime: nullable(number()),\n    blockHeight: nullable(number())\n  })));\n  var GetParsedBlockRpcResult = jsonRpcResult(nullable(type({\n    blockhash: string(),\n    previousBlockhash: string(),\n    parentSlot: number(),\n    transactions: array(type({\n      transaction: ParsedConfirmedTransactionResult,\n      meta: nullable(ParsedConfirmedTransactionMetaResult),\n      version: optional(TransactionVersionStruct)\n    })),\n    rewards: optional(array(RewardsResult)),\n    blockTime: nullable(number()),\n    blockHeight: nullable(number())\n  })));\n  var GetParsedAccountsModeBlockRpcResult = jsonRpcResult(nullable(type({\n    blockhash: string(),\n    previousBlockhash: string(),\n    parentSlot: number(),\n    transactions: array(type({\n      transaction: ConfirmedTransactionAccountsModeResult,\n      meta: nullable(ParsedConfirmedTransactionMetaResult),\n      version: optional(TransactionVersionStruct)\n    })),\n    rewards: optional(array(RewardsResult)),\n    blockTime: nullable(number()),\n    blockHeight: nullable(number())\n  })));\n  var GetParsedNoneModeBlockRpcResult = jsonRpcResult(nullable(type({\n    blockhash: string(),\n    previousBlockhash: string(),\n    parentSlot: number(),\n    rewards: optional(array(RewardsResult)),\n    blockTime: nullable(number()),\n    blockHeight: nullable(number())\n  })));\n  var GetConfirmedBlockRpcResult = jsonRpcResult(nullable(type({\n    blockhash: string(),\n    previousBlockhash: string(),\n    parentSlot: number(),\n    transactions: array(type({\n      transaction: ConfirmedTransactionResult,\n      meta: nullable(ConfirmedTransactionMetaResult)\n    })),\n    rewards: optional(array(RewardsResult)),\n    blockTime: nullable(number())\n  })));\n  var GetBlockSignaturesRpcResult = jsonRpcResult(nullable(type({\n    blockhash: string(),\n    previousBlockhash: string(),\n    parentSlot: number(),\n    signatures: array(string()),\n    blockTime: nullable(number())\n  })));\n  var GetTransactionRpcResult = jsonRpcResult(nullable(type({\n    slot: number(),\n    meta: nullable(ConfirmedTransactionMetaResult),\n    blockTime: optional(nullable(number())),\n    transaction: ConfirmedTransactionResult,\n    version: optional(TransactionVersionStruct)\n  })));\n  var GetParsedTransactionRpcResult = jsonRpcResult(nullable(type({\n    slot: number(),\n    transaction: ParsedConfirmedTransactionResult,\n    meta: nullable(ParsedConfirmedTransactionMetaResult),\n    blockTime: optional(nullable(number())),\n    version: optional(TransactionVersionStruct)\n  })));\n  var GetLatestBlockhashRpcResult = jsonRpcResultAndContext(type({\n    blockhash: string(),\n    lastValidBlockHeight: number()\n  }));\n  var IsBlockhashValidRpcResult = jsonRpcResultAndContext(boolean());\n  var PerfSampleResult = type({\n    slot: number(),\n    numTransactions: number(),\n    numSlots: number(),\n    samplePeriodSecs: number()\n  });\n  var GetRecentPerformanceSamplesRpcResult = jsonRpcResult(array(PerfSampleResult));\n  var GetFeeCalculatorRpcResult = jsonRpcResultAndContext(nullable(type({\n    feeCalculator: type({\n      lamportsPerSignature: number()\n    })\n  })));\n  var RequestAirdropRpcResult = jsonRpcResult(string());\n  var SendTransactionRpcResult = jsonRpcResult(string());\n  var LogsResult = type({\n    err: TransactionErrorResult,\n    logs: array(string()),\n    signature: string()\n  });\n  var LogsNotificationResult = type({\n    result: notificationResultAndContext(LogsResult),\n    subscription: number()\n  });\n  var Keypair = class _Keypair {\n    /**\n     * Create a new keypair instance.\n     * Generate random keypair if no {@link Ed25519Keypair} is provided.\n     *\n     * @param {Ed25519Keypair} keypair ed25519 keypair\n     */\n    constructor(keypair) {\n      this._keypair = void 0;\n      this._keypair = keypair ?? generateKeypair();\n    }\n    /**\n     * Generate a new random keypair\n     *\n     * @returns {Keypair} Keypair\n     */\n    static generate() {\n      return new _Keypair(generateKeypair());\n    }\n    /**\n     * Create a keypair from a raw secret key byte array.\n     *\n     * This method should only be used to recreate a keypair from a previously\n     * generated secret key. Generating keypairs from a random seed should be done\n     * with the {@link Keypair.fromSeed} method.\n     *\n     * @throws error if the provided secret key is invalid and validation is not skipped.\n     *\n     * @param secretKey secret key byte array\n     * @param options skip secret key validation\n     *\n     * @returns {Keypair} Keypair\n     */\n    static fromSecretKey(secretKey, options) {\n      if (secretKey.byteLength !== 64) {\n        throw new Error(\"bad secret key size\");\n      }\n      const publicKey2 = secretKey.slice(32, 64);\n      if (!options || !options.skipValidation) {\n        const privateScalar = secretKey.slice(0, 32);\n        const computedPublicKey = getPublicKey(privateScalar);\n        for (let ii = 0; ii < 32; ii++) {\n          if (publicKey2[ii] !== computedPublicKey[ii]) {\n            throw new Error(\"provided secretKey is invalid\");\n          }\n        }\n      }\n      return new _Keypair({\n        publicKey: publicKey2,\n        secretKey\n      });\n    }\n    /**\n     * Generate a keypair from a 32 byte seed.\n     *\n     * @param seed seed byte array\n     *\n     * @returns {Keypair} Keypair\n     */\n    static fromSeed(seed) {\n      const publicKey2 = getPublicKey(seed);\n      const secretKey = new Uint8Array(64);\n      secretKey.set(seed);\n      secretKey.set(publicKey2, 32);\n      return new _Keypair({\n        publicKey: publicKey2,\n        secretKey\n      });\n    }\n    /**\n     * The public key for this keypair\n     *\n     * @returns {PublicKey} PublicKey\n     */\n    get publicKey() {\n      return new PublicKey(this._keypair.publicKey);\n    }\n    /**\n     * The raw secret key for this keypair\n     * @returns {Uint8Array} Secret key in an array of Uint8 bytes\n     */\n    get secretKey() {\n      return new Uint8Array(this._keypair.secretKey);\n    }\n  };\n  var LOOKUP_TABLE_INSTRUCTION_LAYOUTS = Object.freeze({\n    CreateLookupTable: {\n      index: 0,\n      layout: BufferLayout.struct([BufferLayout.u32(\"instruction\"), u64(\"recentSlot\"), BufferLayout.u8(\"bumpSeed\")])\n    },\n    FreezeLookupTable: {\n      index: 1,\n      layout: BufferLayout.struct([BufferLayout.u32(\"instruction\")])\n    },\n    ExtendLookupTable: {\n      index: 2,\n      layout: BufferLayout.struct([BufferLayout.u32(\"instruction\"), u64(), BufferLayout.seq(publicKey(), BufferLayout.offset(BufferLayout.u32(), -8), \"addresses\")])\n    },\n    DeactivateLookupTable: {\n      index: 3,\n      layout: BufferLayout.struct([BufferLayout.u32(\"instruction\")])\n    },\n    CloseLookupTable: {\n      index: 4,\n      layout: BufferLayout.struct([BufferLayout.u32(\"instruction\")])\n    }\n  });\n  var AddressLookupTableProgram = class {\n    /**\n     * @internal\n     */\n    constructor() {\n    }\n    static createLookupTable(params) {\n      const [lookupTableAddress, bumpSeed] = PublicKey.findProgramAddressSync([params.authority.toBuffer(), getU64Encoder().encode(params.recentSlot)], this.programId);\n      const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CreateLookupTable;\n      const data = encodeData(type2, {\n        recentSlot: BigInt(params.recentSlot),\n        bumpSeed\n      });\n      const keys = [{\n        pubkey: lookupTableAddress,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: params.authority,\n        isSigner: true,\n        isWritable: false\n      }, {\n        pubkey: params.payer,\n        isSigner: true,\n        isWritable: true\n      }, {\n        pubkey: SystemProgram.programId,\n        isSigner: false,\n        isWritable: false\n      }];\n      return [new TransactionInstruction({\n        programId: this.programId,\n        keys,\n        data\n      }), lookupTableAddress];\n    }\n    static freezeLookupTable(params) {\n      const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.FreezeLookupTable;\n      const data = encodeData(type2);\n      const keys = [{\n        pubkey: params.lookupTable,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: params.authority,\n        isSigner: true,\n        isWritable: false\n      }];\n      return new TransactionInstruction({\n        programId: this.programId,\n        keys,\n        data\n      });\n    }\n    static extendLookupTable(params) {\n      const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.ExtendLookupTable;\n      const data = encodeData(type2, {\n        addresses: params.addresses.map((addr) => addr.toBytes())\n      });\n      const keys = [{\n        pubkey: params.lookupTable,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: params.authority,\n        isSigner: true,\n        isWritable: false\n      }];\n      if (params.payer) {\n        keys.push({\n          pubkey: params.payer,\n          isSigner: true,\n          isWritable: true\n        }, {\n          pubkey: SystemProgram.programId,\n          isSigner: false,\n          isWritable: false\n        });\n      }\n      return new TransactionInstruction({\n        programId: this.programId,\n        keys,\n        data\n      });\n    }\n    static deactivateLookupTable(params) {\n      const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.DeactivateLookupTable;\n      const data = encodeData(type2);\n      const keys = [{\n        pubkey: params.lookupTable,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: params.authority,\n        isSigner: true,\n        isWritable: false\n      }];\n      return new TransactionInstruction({\n        programId: this.programId,\n        keys,\n        data\n      });\n    }\n    static closeLookupTable(params) {\n      const type2 = LOOKUP_TABLE_INSTRUCTION_LAYOUTS.CloseLookupTable;\n      const data = encodeData(type2);\n      const keys = [{\n        pubkey: params.lookupTable,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: params.authority,\n        isSigner: true,\n        isWritable: false\n      }, {\n        pubkey: params.recipient,\n        isSigner: false,\n        isWritable: true\n      }];\n      return new TransactionInstruction({\n        programId: this.programId,\n        keys,\n        data\n      });\n    }\n  };\n  AddressLookupTableProgram.programId = new PublicKey(\"AddressLookupTab1e1111111111111111111111111\");\n  var COMPUTE_BUDGET_INSTRUCTION_LAYOUTS = Object.freeze({\n    RequestUnits: {\n      index: 0,\n      layout: BufferLayout.struct([BufferLayout.u8(\"instruction\"), BufferLayout.u32(\"units\"), BufferLayout.u32(\"additionalFee\")])\n    },\n    RequestHeapFrame: {\n      index: 1,\n      layout: BufferLayout.struct([BufferLayout.u8(\"instruction\"), BufferLayout.u32(\"bytes\")])\n    },\n    SetComputeUnitLimit: {\n      index: 2,\n      layout: BufferLayout.struct([BufferLayout.u8(\"instruction\"), BufferLayout.u32(\"units\")])\n    },\n    SetComputeUnitPrice: {\n      index: 3,\n      layout: BufferLayout.struct([BufferLayout.u8(\"instruction\"), u64(\"microLamports\")])\n    }\n  });\n  var ComputeBudgetProgram = class {\n    /**\n     * @internal\n     */\n    constructor() {\n    }\n    /**\n     * Public key that identifies the Compute Budget program\n     */\n    /**\n     * @deprecated Instead, call {@link setComputeUnitLimit} and/or {@link setComputeUnitPrice}\n     */\n    static requestUnits(params) {\n      const type2 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestUnits;\n      const data = encodeData(type2, params);\n      return new TransactionInstruction({\n        keys: [],\n        programId: this.programId,\n        data\n      });\n    }\n    static requestHeapFrame(params) {\n      const type2 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.RequestHeapFrame;\n      const data = encodeData(type2, params);\n      return new TransactionInstruction({\n        keys: [],\n        programId: this.programId,\n        data\n      });\n    }\n    static setComputeUnitLimit(params) {\n      const type2 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitLimit;\n      const data = encodeData(type2, params);\n      return new TransactionInstruction({\n        keys: [],\n        programId: this.programId,\n        data\n      });\n    }\n    static setComputeUnitPrice(params) {\n      const type2 = COMPUTE_BUDGET_INSTRUCTION_LAYOUTS.SetComputeUnitPrice;\n      const data = encodeData(type2, {\n        microLamports: BigInt(params.microLamports)\n      });\n      return new TransactionInstruction({\n        keys: [],\n        programId: this.programId,\n        data\n      });\n    }\n  };\n  ComputeBudgetProgram.programId = new PublicKey(\"ComputeBudget111111111111111111111111111111\");\n  var PRIVATE_KEY_BYTES$1 = 64;\n  var PUBLIC_KEY_BYTES$1 = 32;\n  var SIGNATURE_BYTES = 64;\n  var ED25519_INSTRUCTION_LAYOUT = BufferLayout.struct([BufferLayout.u8(\"numSignatures\"), BufferLayout.u8(\"padding\"), BufferLayout.u16(\"signatureOffset\"), BufferLayout.u16(\"signatureInstructionIndex\"), BufferLayout.u16(\"publicKeyOffset\"), BufferLayout.u16(\"publicKeyInstructionIndex\"), BufferLayout.u16(\"messageDataOffset\"), BufferLayout.u16(\"messageDataSize\"), BufferLayout.u16(\"messageInstructionIndex\")]);\n  var Ed25519Program = class _Ed25519Program {\n    /**\n     * @internal\n     */\n    constructor() {\n    }\n    /**\n     * Public key that identifies the ed25519 program\n     */\n    /**\n     * Create an ed25519 instruction with a public key and signature. The\n     * public key must be a buffer that is 32 bytes long, and the signature\n     * must be a buffer of 64 bytes.\n     */\n    static createInstructionWithPublicKey(params) {\n      const {\n        publicKey: publicKey2,\n        message,\n        signature,\n        instructionIndex\n      } = params;\n      assert2(publicKey2.length === PUBLIC_KEY_BYTES$1, `Public Key must be ${PUBLIC_KEY_BYTES$1} bytes but received ${publicKey2.length} bytes`);\n      assert2(signature.length === SIGNATURE_BYTES, `Signature must be ${SIGNATURE_BYTES} bytes but received ${signature.length} bytes`);\n      const publicKeyOffset = ED25519_INSTRUCTION_LAYOUT.span;\n      const signatureOffset = publicKeyOffset + publicKey2.length;\n      const messageDataOffset = signatureOffset + signature.length;\n      const numSignatures = 1;\n      const instructionData = Buffer2.alloc(messageDataOffset + message.length);\n      const index = instructionIndex == null ? 65535 : instructionIndex;\n      ED25519_INSTRUCTION_LAYOUT.encode({\n        numSignatures,\n        padding: 0,\n        signatureOffset,\n        signatureInstructionIndex: index,\n        publicKeyOffset,\n        publicKeyInstructionIndex: index,\n        messageDataOffset,\n        messageDataSize: message.length,\n        messageInstructionIndex: index\n      }, instructionData);\n      instructionData.fill(publicKey2, publicKeyOffset);\n      instructionData.fill(signature, signatureOffset);\n      instructionData.fill(message, messageDataOffset);\n      return new TransactionInstruction({\n        keys: [],\n        programId: _Ed25519Program.programId,\n        data: instructionData\n      });\n    }\n    /**\n     * Create an ed25519 instruction with a private key. The private key\n     * must be a buffer that is 64 bytes long.\n     */\n    static createInstructionWithPrivateKey(params) {\n      const {\n        privateKey,\n        message,\n        instructionIndex\n      } = params;\n      assert2(privateKey.length === PRIVATE_KEY_BYTES$1, `Private key must be ${PRIVATE_KEY_BYTES$1} bytes but received ${privateKey.length} bytes`);\n      try {\n        const keypair = Keypair.fromSecretKey(privateKey);\n        const publicKey2 = keypair.publicKey.toBytes();\n        const signature = sign(message, keypair.secretKey);\n        return this.createInstructionWithPublicKey({\n          publicKey: publicKey2,\n          message,\n          signature,\n          instructionIndex\n        });\n      } catch (error) {\n        throw new Error(`Error creating instruction; ${error}`);\n      }\n    }\n  };\n  Ed25519Program.programId = new PublicKey(\"Ed25519SigVerify111111111111111111111111111\");\n  var ecdsaSign = (msgHash, privKey) => {\n    const signature = secp256k1.sign(msgHash, privKey);\n    return [signature.toCompactRawBytes(), signature.recovery];\n  };\n  secp256k1.utils.isValidPrivateKey;\n  var publicKeyCreate = secp256k1.getPublicKey;\n  var PRIVATE_KEY_BYTES = 32;\n  var ETHEREUM_ADDRESS_BYTES = 20;\n  var PUBLIC_KEY_BYTES = 64;\n  var SIGNATURE_OFFSETS_SERIALIZED_SIZE = 11;\n  var SECP256K1_INSTRUCTION_LAYOUT = BufferLayout.struct([BufferLayout.u8(\"numSignatures\"), BufferLayout.u16(\"signatureOffset\"), BufferLayout.u8(\"signatureInstructionIndex\"), BufferLayout.u16(\"ethAddressOffset\"), BufferLayout.u8(\"ethAddressInstructionIndex\"), BufferLayout.u16(\"messageDataOffset\"), BufferLayout.u16(\"messageDataSize\"), BufferLayout.u8(\"messageInstructionIndex\"), BufferLayout.blob(20, \"ethAddress\"), BufferLayout.blob(64, \"signature\"), BufferLayout.u8(\"recoveryId\")]);\n  var Secp256k1Program = class _Secp256k1Program {\n    /**\n     * @internal\n     */\n    constructor() {\n    }\n    /**\n     * Public key that identifies the secp256k1 program\n     */\n    /**\n     * Construct an Ethereum address from a secp256k1 public key buffer.\n     * @param {Buffer} publicKey a 64 byte secp256k1 public key buffer\n     */\n    static publicKeyToEthAddress(publicKey2) {\n      assert2(publicKey2.length === PUBLIC_KEY_BYTES, `Public key must be ${PUBLIC_KEY_BYTES} bytes but received ${publicKey2.length} bytes`);\n      try {\n        return Buffer2.from(keccak_256(toBuffer(publicKey2))).slice(-ETHEREUM_ADDRESS_BYTES);\n      } catch (error) {\n        throw new Error(`Error constructing Ethereum address: ${error}`);\n      }\n    }\n    /**\n     * Create an secp256k1 instruction with a public key. The public key\n     * must be a buffer that is 64 bytes long.\n     */\n    static createInstructionWithPublicKey(params) {\n      const {\n        publicKey: publicKey2,\n        message,\n        signature,\n        recoveryId,\n        instructionIndex\n      } = params;\n      return _Secp256k1Program.createInstructionWithEthAddress({\n        ethAddress: _Secp256k1Program.publicKeyToEthAddress(publicKey2),\n        message,\n        signature,\n        recoveryId,\n        instructionIndex\n      });\n    }\n    /**\n     * Create an secp256k1 instruction with an Ethereum address. The address\n     * must be a hex string or a buffer that is 20 bytes long.\n     */\n    static createInstructionWithEthAddress(params) {\n      const {\n        ethAddress: rawAddress,\n        message,\n        signature,\n        recoveryId,\n        instructionIndex = 0\n      } = params;\n      let ethAddress;\n      if (typeof rawAddress === \"string\") {\n        if (rawAddress.startsWith(\"0x\")) {\n          ethAddress = Buffer2.from(rawAddress.substr(2), \"hex\");\n        } else {\n          ethAddress = Buffer2.from(rawAddress, \"hex\");\n        }\n      } else {\n        ethAddress = rawAddress;\n      }\n      assert2(ethAddress.length === ETHEREUM_ADDRESS_BYTES, `Address must be ${ETHEREUM_ADDRESS_BYTES} bytes but received ${ethAddress.length} bytes`);\n      const dataStart = 1 + SIGNATURE_OFFSETS_SERIALIZED_SIZE;\n      const ethAddressOffset = dataStart;\n      const signatureOffset = dataStart + ethAddress.length;\n      const messageDataOffset = signatureOffset + signature.length + 1;\n      const numSignatures = 1;\n      const instructionData = Buffer2.alloc(SECP256K1_INSTRUCTION_LAYOUT.span + message.length);\n      SECP256K1_INSTRUCTION_LAYOUT.encode({\n        numSignatures,\n        signatureOffset,\n        signatureInstructionIndex: instructionIndex,\n        ethAddressOffset,\n        ethAddressInstructionIndex: instructionIndex,\n        messageDataOffset,\n        messageDataSize: message.length,\n        messageInstructionIndex: instructionIndex,\n        signature: toBuffer(signature),\n        ethAddress: toBuffer(ethAddress),\n        recoveryId\n      }, instructionData);\n      instructionData.fill(toBuffer(message), SECP256K1_INSTRUCTION_LAYOUT.span);\n      return new TransactionInstruction({\n        keys: [],\n        programId: _Secp256k1Program.programId,\n        data: instructionData\n      });\n    }\n    /**\n     * Create an secp256k1 instruction with a private key. The private key\n     * must be a buffer that is 32 bytes long.\n     */\n    static createInstructionWithPrivateKey(params) {\n      const {\n        privateKey: pkey,\n        message,\n        instructionIndex\n      } = params;\n      assert2(pkey.length === PRIVATE_KEY_BYTES, `Private key must be ${PRIVATE_KEY_BYTES} bytes but received ${pkey.length} bytes`);\n      try {\n        const privateKey = toBuffer(pkey);\n        const publicKey2 = publicKeyCreate(\n          privateKey,\n          false\n          /* isCompressed */\n        ).slice(1);\n        const messageHash = Buffer2.from(keccak_256(toBuffer(message)));\n        const [signature, recoveryId] = ecdsaSign(messageHash, privateKey);\n        return this.createInstructionWithPublicKey({\n          publicKey: publicKey2,\n          message,\n          signature,\n          recoveryId,\n          instructionIndex\n        });\n      } catch (error) {\n        throw new Error(`Error creating instruction; ${error}`);\n      }\n    }\n  };\n  Secp256k1Program.programId = new PublicKey(\"KeccakSecp256k11111111111111111111111111111\");\n  var _Lockup;\n  var STAKE_CONFIG_ID = new PublicKey(\"StakeConfig11111111111111111111111111111111\");\n  var Lockup = class {\n    /**\n     * Create a new Lockup object\n     */\n    constructor(unixTimestamp, epoch, custodian) {\n      this.unixTimestamp = void 0;\n      this.epoch = void 0;\n      this.custodian = void 0;\n      this.unixTimestamp = unixTimestamp;\n      this.epoch = epoch;\n      this.custodian = custodian;\n    }\n    /**\n     * Default, inactive Lockup value\n     */\n  };\n  _Lockup = Lockup;\n  Lockup.default = new _Lockup(0, 0, PublicKey.default);\n  var STAKE_INSTRUCTION_LAYOUTS = Object.freeze({\n    Initialize: {\n      index: 0,\n      layout: BufferLayout.struct([BufferLayout.u32(\"instruction\"), authorized(), lockup()])\n    },\n    Authorize: {\n      index: 1,\n      layout: BufferLayout.struct([BufferLayout.u32(\"instruction\"), publicKey(\"newAuthorized\"), BufferLayout.u32(\"stakeAuthorizationType\")])\n    },\n    Delegate: {\n      index: 2,\n      layout: BufferLayout.struct([BufferLayout.u32(\"instruction\")])\n    },\n    Split: {\n      index: 3,\n      layout: BufferLayout.struct([BufferLayout.u32(\"instruction\"), BufferLayout.ns64(\"lamports\")])\n    },\n    Withdraw: {\n      index: 4,\n      layout: BufferLayout.struct([BufferLayout.u32(\"instruction\"), BufferLayout.ns64(\"lamports\")])\n    },\n    Deactivate: {\n      index: 5,\n      layout: BufferLayout.struct([BufferLayout.u32(\"instruction\")])\n    },\n    Merge: {\n      index: 7,\n      layout: BufferLayout.struct([BufferLayout.u32(\"instruction\")])\n    },\n    AuthorizeWithSeed: {\n      index: 8,\n      layout: BufferLayout.struct([BufferLayout.u32(\"instruction\"), publicKey(\"newAuthorized\"), BufferLayout.u32(\"stakeAuthorizationType\"), rustString(\"authoritySeed\"), publicKey(\"authorityOwner\")])\n    }\n  });\n  var StakeAuthorizationLayout = Object.freeze({\n    Staker: {\n      index: 0\n    },\n    Withdrawer: {\n      index: 1\n    }\n  });\n  var StakeProgram = class {\n    /**\n     * @internal\n     */\n    constructor() {\n    }\n    /**\n     * Public key that identifies the Stake program\n     */\n    /**\n     * Generate an Initialize instruction to add to a Stake Create transaction\n     */\n    static initialize(params) {\n      const {\n        stakePubkey,\n        authorized: authorized2,\n        lockup: maybeLockup\n      } = params;\n      const lockup2 = maybeLockup || Lockup.default;\n      const type2 = STAKE_INSTRUCTION_LAYOUTS.Initialize;\n      const data = encodeData(type2, {\n        authorized: {\n          staker: toBuffer(authorized2.staker.toBuffer()),\n          withdrawer: toBuffer(authorized2.withdrawer.toBuffer())\n        },\n        lockup: {\n          unixTimestamp: lockup2.unixTimestamp,\n          epoch: lockup2.epoch,\n          custodian: toBuffer(lockup2.custodian.toBuffer())\n        }\n      });\n      const instructionData = {\n        keys: [{\n          pubkey: stakePubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: SYSVAR_RENT_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data\n      };\n      return new TransactionInstruction(instructionData);\n    }\n    /**\n     * Generate a Transaction that creates a new Stake account at\n     *   an address generated with `from`, a seed, and the Stake programId\n     */\n    static createAccountWithSeed(params) {\n      const transaction = new Transaction();\n      transaction.add(SystemProgram.createAccountWithSeed({\n        fromPubkey: params.fromPubkey,\n        newAccountPubkey: params.stakePubkey,\n        basePubkey: params.basePubkey,\n        seed: params.seed,\n        lamports: params.lamports,\n        space: this.space,\n        programId: this.programId\n      }));\n      const {\n        stakePubkey,\n        authorized: authorized2,\n        lockup: lockup2\n      } = params;\n      return transaction.add(this.initialize({\n        stakePubkey,\n        authorized: authorized2,\n        lockup: lockup2\n      }));\n    }\n    /**\n     * Generate a Transaction that creates a new Stake account\n     */\n    static createAccount(params) {\n      const transaction = new Transaction();\n      transaction.add(SystemProgram.createAccount({\n        fromPubkey: params.fromPubkey,\n        newAccountPubkey: params.stakePubkey,\n        lamports: params.lamports,\n        space: this.space,\n        programId: this.programId\n      }));\n      const {\n        stakePubkey,\n        authorized: authorized2,\n        lockup: lockup2\n      } = params;\n      return transaction.add(this.initialize({\n        stakePubkey,\n        authorized: authorized2,\n        lockup: lockup2\n      }));\n    }\n    /**\n     * Generate a Transaction that delegates Stake tokens to a validator\n     * Vote PublicKey. This transaction can also be used to redelegate Stake\n     * to a new validator Vote PublicKey.\n     */\n    static delegate(params) {\n      const {\n        stakePubkey,\n        authorizedPubkey,\n        votePubkey\n      } = params;\n      const type2 = STAKE_INSTRUCTION_LAYOUTS.Delegate;\n      const data = encodeData(type2);\n      return new Transaction().add({\n        keys: [{\n          pubkey: stakePubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: votePubkey,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: SYSVAR_CLOCK_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: STAKE_CONFIG_ID,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: authorizedPubkey,\n          isSigner: true,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data\n      });\n    }\n    /**\n     * Generate a Transaction that authorizes a new PublicKey as Staker\n     * or Withdrawer on the Stake account.\n     */\n    static authorize(params) {\n      const {\n        stakePubkey,\n        authorizedPubkey,\n        newAuthorizedPubkey,\n        stakeAuthorizationType,\n        custodianPubkey\n      } = params;\n      const type2 = STAKE_INSTRUCTION_LAYOUTS.Authorize;\n      const data = encodeData(type2, {\n        newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n        stakeAuthorizationType: stakeAuthorizationType.index\n      });\n      const keys = [{\n        pubkey: stakePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: SYSVAR_CLOCK_PUBKEY,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: authorizedPubkey,\n        isSigner: true,\n        isWritable: false\n      }];\n      if (custodianPubkey) {\n        keys.push({\n          pubkey: custodianPubkey,\n          isSigner: true,\n          isWritable: false\n        });\n      }\n      return new Transaction().add({\n        keys,\n        programId: this.programId,\n        data\n      });\n    }\n    /**\n     * Generate a Transaction that authorizes a new PublicKey as Staker\n     * or Withdrawer on the Stake account.\n     */\n    static authorizeWithSeed(params) {\n      const {\n        stakePubkey,\n        authorityBase,\n        authoritySeed,\n        authorityOwner,\n        newAuthorizedPubkey,\n        stakeAuthorizationType,\n        custodianPubkey\n      } = params;\n      const type2 = STAKE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;\n      const data = encodeData(type2, {\n        newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n        stakeAuthorizationType: stakeAuthorizationType.index,\n        authoritySeed,\n        authorityOwner: toBuffer(authorityOwner.toBuffer())\n      });\n      const keys = [{\n        pubkey: stakePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: authorityBase,\n        isSigner: true,\n        isWritable: false\n      }, {\n        pubkey: SYSVAR_CLOCK_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }];\n      if (custodianPubkey) {\n        keys.push({\n          pubkey: custodianPubkey,\n          isSigner: true,\n          isWritable: false\n        });\n      }\n      return new Transaction().add({\n        keys,\n        programId: this.programId,\n        data\n      });\n    }\n    /**\n     * @internal\n     */\n    static splitInstruction(params) {\n      const {\n        stakePubkey,\n        authorizedPubkey,\n        splitStakePubkey,\n        lamports\n      } = params;\n      const type2 = STAKE_INSTRUCTION_LAYOUTS.Split;\n      const data = encodeData(type2, {\n        lamports\n      });\n      return new TransactionInstruction({\n        keys: [{\n          pubkey: stakePubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: splitStakePubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: authorizedPubkey,\n          isSigner: true,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data\n      });\n    }\n    /**\n     * Generate a Transaction that splits Stake tokens into another stake account\n     */\n    static split(params, rentExemptReserve) {\n      const transaction = new Transaction();\n      transaction.add(SystemProgram.createAccount({\n        fromPubkey: params.authorizedPubkey,\n        newAccountPubkey: params.splitStakePubkey,\n        lamports: rentExemptReserve,\n        space: this.space,\n        programId: this.programId\n      }));\n      return transaction.add(this.splitInstruction(params));\n    }\n    /**\n     * Generate a Transaction that splits Stake tokens into another account\n     * derived from a base public key and seed\n     */\n    static splitWithSeed(params, rentExemptReserve) {\n      const {\n        stakePubkey,\n        authorizedPubkey,\n        splitStakePubkey,\n        basePubkey,\n        seed,\n        lamports\n      } = params;\n      const transaction = new Transaction();\n      transaction.add(SystemProgram.allocate({\n        accountPubkey: splitStakePubkey,\n        basePubkey,\n        seed,\n        space: this.space,\n        programId: this.programId\n      }));\n      if (rentExemptReserve && rentExemptReserve > 0) {\n        transaction.add(SystemProgram.transfer({\n          fromPubkey: params.authorizedPubkey,\n          toPubkey: splitStakePubkey,\n          lamports: rentExemptReserve\n        }));\n      }\n      return transaction.add(this.splitInstruction({\n        stakePubkey,\n        authorizedPubkey,\n        splitStakePubkey,\n        lamports\n      }));\n    }\n    /**\n     * Generate a Transaction that merges Stake accounts.\n     */\n    static merge(params) {\n      const {\n        stakePubkey,\n        sourceStakePubKey,\n        authorizedPubkey\n      } = params;\n      const type2 = STAKE_INSTRUCTION_LAYOUTS.Merge;\n      const data = encodeData(type2);\n      return new Transaction().add({\n        keys: [{\n          pubkey: stakePubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: sourceStakePubKey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: SYSVAR_CLOCK_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: authorizedPubkey,\n          isSigner: true,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data\n      });\n    }\n    /**\n     * Generate a Transaction that withdraws deactivated Stake tokens.\n     */\n    static withdraw(params) {\n      const {\n        stakePubkey,\n        authorizedPubkey,\n        toPubkey,\n        lamports,\n        custodianPubkey\n      } = params;\n      const type2 = STAKE_INSTRUCTION_LAYOUTS.Withdraw;\n      const data = encodeData(type2, {\n        lamports\n      });\n      const keys = [{\n        pubkey: stakePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: toPubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: SYSVAR_CLOCK_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: SYSVAR_STAKE_HISTORY_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: authorizedPubkey,\n        isSigner: true,\n        isWritable: false\n      }];\n      if (custodianPubkey) {\n        keys.push({\n          pubkey: custodianPubkey,\n          isSigner: true,\n          isWritable: false\n        });\n      }\n      return new Transaction().add({\n        keys,\n        programId: this.programId,\n        data\n      });\n    }\n    /**\n     * Generate a Transaction that deactivates Stake tokens.\n     */\n    static deactivate(params) {\n      const {\n        stakePubkey,\n        authorizedPubkey\n      } = params;\n      const type2 = STAKE_INSTRUCTION_LAYOUTS.Deactivate;\n      const data = encodeData(type2);\n      return new Transaction().add({\n        keys: [{\n          pubkey: stakePubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: SYSVAR_CLOCK_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: authorizedPubkey,\n          isSigner: true,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data\n      });\n    }\n  };\n  StakeProgram.programId = new PublicKey(\"Stake11111111111111111111111111111111111111\");\n  StakeProgram.space = 200;\n  var VOTE_INSTRUCTION_LAYOUTS = Object.freeze({\n    InitializeAccount: {\n      index: 0,\n      layout: BufferLayout.struct([BufferLayout.u32(\"instruction\"), voteInit()])\n    },\n    Authorize: {\n      index: 1,\n      layout: BufferLayout.struct([BufferLayout.u32(\"instruction\"), publicKey(\"newAuthorized\"), BufferLayout.u32(\"voteAuthorizationType\")])\n    },\n    Withdraw: {\n      index: 3,\n      layout: BufferLayout.struct([BufferLayout.u32(\"instruction\"), BufferLayout.ns64(\"lamports\")])\n    },\n    UpdateValidatorIdentity: {\n      index: 4,\n      layout: BufferLayout.struct([BufferLayout.u32(\"instruction\")])\n    },\n    AuthorizeWithSeed: {\n      index: 10,\n      layout: BufferLayout.struct([BufferLayout.u32(\"instruction\"), voteAuthorizeWithSeedArgs()])\n    }\n  });\n  var VoteAuthorizationLayout = Object.freeze({\n    Voter: {\n      index: 0\n    },\n    Withdrawer: {\n      index: 1\n    }\n  });\n  var VoteProgram = class _VoteProgram {\n    /**\n     * @internal\n     */\n    constructor() {\n    }\n    /**\n     * Public key that identifies the Vote program\n     */\n    /**\n     * Generate an Initialize instruction.\n     */\n    static initializeAccount(params) {\n      const {\n        votePubkey,\n        nodePubkey,\n        voteInit: voteInit2\n      } = params;\n      const type2 = VOTE_INSTRUCTION_LAYOUTS.InitializeAccount;\n      const data = encodeData(type2, {\n        voteInit: {\n          nodePubkey: toBuffer(voteInit2.nodePubkey.toBuffer()),\n          authorizedVoter: toBuffer(voteInit2.authorizedVoter.toBuffer()),\n          authorizedWithdrawer: toBuffer(voteInit2.authorizedWithdrawer.toBuffer()),\n          commission: voteInit2.commission\n        }\n      });\n      const instructionData = {\n        keys: [{\n          pubkey: votePubkey,\n          isSigner: false,\n          isWritable: true\n        }, {\n          pubkey: SYSVAR_RENT_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: SYSVAR_CLOCK_PUBKEY,\n          isSigner: false,\n          isWritable: false\n        }, {\n          pubkey: nodePubkey,\n          isSigner: true,\n          isWritable: false\n        }],\n        programId: this.programId,\n        data\n      };\n      return new TransactionInstruction(instructionData);\n    }\n    /**\n     * Generate a transaction that creates a new Vote account.\n     */\n    static createAccount(params) {\n      const transaction = new Transaction();\n      transaction.add(SystemProgram.createAccount({\n        fromPubkey: params.fromPubkey,\n        newAccountPubkey: params.votePubkey,\n        lamports: params.lamports,\n        space: this.space,\n        programId: this.programId\n      }));\n      return transaction.add(this.initializeAccount({\n        votePubkey: params.votePubkey,\n        nodePubkey: params.voteInit.nodePubkey,\n        voteInit: params.voteInit\n      }));\n    }\n    /**\n     * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account.\n     */\n    static authorize(params) {\n      const {\n        votePubkey,\n        authorizedPubkey,\n        newAuthorizedPubkey,\n        voteAuthorizationType\n      } = params;\n      const type2 = VOTE_INSTRUCTION_LAYOUTS.Authorize;\n      const data = encodeData(type2, {\n        newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n        voteAuthorizationType: voteAuthorizationType.index\n      });\n      const keys = [{\n        pubkey: votePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: SYSVAR_CLOCK_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: authorizedPubkey,\n        isSigner: true,\n        isWritable: false\n      }];\n      return new Transaction().add({\n        keys,\n        programId: this.programId,\n        data\n      });\n    }\n    /**\n     * Generate a transaction that authorizes a new Voter or Withdrawer on the Vote account\n     * where the current Voter or Withdrawer authority is a derived key.\n     */\n    static authorizeWithSeed(params) {\n      const {\n        currentAuthorityDerivedKeyBasePubkey,\n        currentAuthorityDerivedKeyOwnerPubkey,\n        currentAuthorityDerivedKeySeed,\n        newAuthorizedPubkey,\n        voteAuthorizationType,\n        votePubkey\n      } = params;\n      const type2 = VOTE_INSTRUCTION_LAYOUTS.AuthorizeWithSeed;\n      const data = encodeData(type2, {\n        voteAuthorizeWithSeedArgs: {\n          currentAuthorityDerivedKeyOwnerPubkey: toBuffer(currentAuthorityDerivedKeyOwnerPubkey.toBuffer()),\n          currentAuthorityDerivedKeySeed,\n          newAuthorized: toBuffer(newAuthorizedPubkey.toBuffer()),\n          voteAuthorizationType: voteAuthorizationType.index\n        }\n      });\n      const keys = [{\n        pubkey: votePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: SYSVAR_CLOCK_PUBKEY,\n        isSigner: false,\n        isWritable: false\n      }, {\n        pubkey: currentAuthorityDerivedKeyBasePubkey,\n        isSigner: true,\n        isWritable: false\n      }];\n      return new Transaction().add({\n        keys,\n        programId: this.programId,\n        data\n      });\n    }\n    /**\n     * Generate a transaction to withdraw from a Vote account.\n     */\n    static withdraw(params) {\n      const {\n        votePubkey,\n        authorizedWithdrawerPubkey,\n        lamports,\n        toPubkey\n      } = params;\n      const type2 = VOTE_INSTRUCTION_LAYOUTS.Withdraw;\n      const data = encodeData(type2, {\n        lamports\n      });\n      const keys = [{\n        pubkey: votePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: toPubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: authorizedWithdrawerPubkey,\n        isSigner: true,\n        isWritable: false\n      }];\n      return new Transaction().add({\n        keys,\n        programId: this.programId,\n        data\n      });\n    }\n    /**\n     * Generate a transaction to withdraw safely from a Vote account.\n     *\n     * This function was created as a safeguard for vote accounts running validators, `safeWithdraw`\n     * checks that the withdraw amount will not exceed the specified balance while leaving enough left\n     * to cover rent. If you wish to close the vote account by withdrawing the full amount, call the\n     * `withdraw` method directly.\n     */\n    static safeWithdraw(params, currentVoteAccountBalance, rentExemptMinimum) {\n      if (params.lamports > currentVoteAccountBalance - rentExemptMinimum) {\n        throw new Error(\"Withdraw will leave vote account with insufficient funds.\");\n      }\n      return _VoteProgram.withdraw(params);\n    }\n    /**\n     * Generate a transaction to update the validator identity (node pubkey) of a Vote account.\n     */\n    static updateValidatorIdentity(params) {\n      const {\n        votePubkey,\n        authorizedWithdrawerPubkey,\n        nodePubkey\n      } = params;\n      const type2 = VOTE_INSTRUCTION_LAYOUTS.UpdateValidatorIdentity;\n      const data = encodeData(type2);\n      const keys = [{\n        pubkey: votePubkey,\n        isSigner: false,\n        isWritable: true\n      }, {\n        pubkey: nodePubkey,\n        isSigner: true,\n        isWritable: false\n      }, {\n        pubkey: authorizedWithdrawerPubkey,\n        isSigner: true,\n        isWritable: false\n      }];\n      return new Transaction().add({\n        keys,\n        programId: this.programId,\n        data\n      });\n    }\n  };\n  VoteProgram.programId = new PublicKey(\"Vote111111111111111111111111111111111111111\");\n  VoteProgram.space = 3762;\n  var VALIDATOR_INFO_KEY = new PublicKey(\"Va1idator1nfo111111111111111111111111111111\");\n  var InfoString = type({\n    name: string(),\n    website: optional(string()),\n    details: optional(string()),\n    iconUrl: optional(string()),\n    keybaseUsername: optional(string())\n  });\n  var VOTE_PROGRAM_ID = new PublicKey(\"Vote111111111111111111111111111111111111111\");\n  var VoteAccountLayout = BufferLayout.struct([\n    publicKey(\"nodePubkey\"),\n    publicKey(\"authorizedWithdrawer\"),\n    BufferLayout.u8(\"commission\"),\n    BufferLayout.nu64(),\n    // votes.length\n    BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64(\"slot\"), BufferLayout.u32(\"confirmationCount\")]), BufferLayout.offset(BufferLayout.u32(), -8), \"votes\"),\n    BufferLayout.u8(\"rootSlotValid\"),\n    BufferLayout.nu64(\"rootSlot\"),\n    BufferLayout.nu64(),\n    // authorizedVoters.length\n    BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64(\"epoch\"), publicKey(\"authorizedVoter\")]), BufferLayout.offset(BufferLayout.u32(), -8), \"authorizedVoters\"),\n    BufferLayout.struct([BufferLayout.seq(BufferLayout.struct([publicKey(\"authorizedPubkey\"), BufferLayout.nu64(\"epochOfLastAuthorizedSwitch\"), BufferLayout.nu64(\"targetEpoch\")]), 32, \"buf\"), BufferLayout.nu64(\"idx\"), BufferLayout.u8(\"isEmpty\")], \"priorVoters\"),\n    BufferLayout.nu64(),\n    // epochCredits.length\n    BufferLayout.seq(BufferLayout.struct([BufferLayout.nu64(\"epoch\"), BufferLayout.nu64(\"credits\"), BufferLayout.nu64(\"prevCredits\")]), BufferLayout.offset(BufferLayout.u32(), -8), \"epochCredits\"),\n    BufferLayout.struct([BufferLayout.nu64(\"slot\"), BufferLayout.nu64(\"timestamp\")], \"lastTimestamp\")\n  ]);\n\n  // src/lib/lit-actions/internal/solana/generatePrivateKey.ts\n  function generateSolanaPrivateKey() {\n    const solanaKeypair = Keypair.generate();\n    return {\n      privateKey: Buffer2.from(solanaKeypair.secretKey).toString(\"hex\"),\n      publicKey: solanaKeypair.publicKey.toString()\n    };\n  }\n\n  // src/lib/lit-actions/raw-action-functions/solana/generateEncryptedSolanaPrivateKey.ts\n  async function generateEncryptedSolanaPrivateKey({\n    accessControlConditions: accessControlConditions2\n  }) {\n    const { privateKey, publicKey: publicKey2 } = generateSolanaPrivateKey();\n    return encryptPrivateKey({\n      accessControlConditions: accessControlConditions2,\n      publicKey: publicKey2,\n      privateKey\n    });\n  }\n\n  // src/lib/lit-actions/self-executing-actions/solana/generateEncryptedSolanaPrivateKey.ts\n  (async () => litActionHandler(\n    async () => generateEncryptedSolanaPrivateKey({\n      accessControlConditions\n    })\n  ))();\n})();\n/*! Bundled license information:\n\n@jspm/core/nodelibs/browser/chunk-DtuTasat.js:\n  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)\n\nsafe-buffer/index.js:\n  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)\n\n@solana/buffer-layout/lib/Layout.js:\n  (**\n   * Support for translating between Uint8Array instances and JavaScript\n   * native types.\n   *\n   * {@link module:Layout~Layout|Layout} is the basis of a class\n   * hierarchy that associates property names with sequences of encoded\n   * bytes.\n   *\n   * Layouts are supported for these scalar (numeric) types:\n   * * {@link module:Layout~UInt|Unsigned integers in little-endian\n   *   format} with {@link module:Layout.u8|8-bit}, {@link\n   *   module:Layout.u16|16-bit}, {@link module:Layout.u24|24-bit},\n   *   {@link module:Layout.u32|32-bit}, {@link\n   *   module:Layout.u40|40-bit}, and {@link module:Layout.u48|48-bit}\n   *   representation ranges;\n   * * {@link module:Layout~UIntBE|Unsigned integers in big-endian\n   *   format} with {@link module:Layout.u16be|16-bit}, {@link\n   *   module:Layout.u24be|24-bit}, {@link module:Layout.u32be|32-bit},\n   *   {@link module:Layout.u40be|40-bit}, and {@link\n   *   module:Layout.u48be|48-bit} representation ranges;\n   * * {@link module:Layout~Int|Signed integers in little-endian\n   *   format} with {@link module:Layout.s8|8-bit}, {@link\n   *   module:Layout.s16|16-bit}, {@link module:Layout.s24|24-bit},\n   *   {@link module:Layout.s32|32-bit}, {@link\n   *   module:Layout.s40|40-bit}, and {@link module:Layout.s48|48-bit}\n   *   representation ranges;\n   * * {@link module:Layout~IntBE|Signed integers in big-endian format}\n   *   with {@link module:Layout.s16be|16-bit}, {@link\n   *   module:Layout.s24be|24-bit}, {@link module:Layout.s32be|32-bit},\n   *   {@link module:Layout.s40be|40-bit}, and {@link\n   *   module:Layout.s48be|48-bit} representation ranges;\n   * * 64-bit integral values that decode to an exact (if magnitude is\n   *   less than 2^53) or nearby integral Number in {@link\n   *   module:Layout.nu64|unsigned little-endian}, {@link\n   *   module:Layout.nu64be|unsigned big-endian}, {@link\n   *   module:Layout.ns64|signed little-endian}, and {@link\n   *   module:Layout.ns64be|unsigned big-endian} encodings;\n   * * 32-bit floating point values with {@link\n   *   module:Layout.f32|little-endian} and {@link\n   *   module:Layout.f32be|big-endian} representations;\n   * * 64-bit floating point values with {@link\n   *   module:Layout.f64|little-endian} and {@link\n   *   module:Layout.f64be|big-endian} representations;\n   * * {@link module:Layout.const|Constants} that take no space in the\n   *   encoded expression.\n   *\n   * and for these aggregate types:\n   * * {@link module:Layout.seq|Sequence}s of instances of a {@link\n   *   module:Layout~Layout|Layout}, with JavaScript representation as\n   *   an Array and constant or data-dependent {@link\n   *   module:Layout~Sequence#count|length};\n   * * {@link module:Layout.struct|Structure}s that aggregate a\n   *   heterogeneous sequence of {@link module:Layout~Layout|Layout}\n   *   instances, with JavaScript representation as an Object;\n   * * {@link module:Layout.union|Union}s that support multiple {@link\n   *   module:Layout~VariantLayout|variant layouts} over a fixed\n   *   (padded) or variable (not padded) span of bytes, using an\n   *   unsigned integer at the start of the data or a separate {@link\n   *   module:Layout.unionLayoutDiscriminator|layout element} to\n   *   determine which layout to use when interpreting the buffer\n   *   contents;\n   * * {@link module:Layout.bits|BitStructure}s that contain a sequence\n   *   of individual {@link\n   *   module:Layout~BitStructure#addField|BitField}s packed into an 8,\n   *   16, 24, or 32-bit unsigned integer starting at the least- or\n   *   most-significant bit;\n   * * {@link module:Layout.cstr|C strings} of varying length;\n   * * {@link module:Layout.blob|Blobs} of fixed- or variable-{@link\n   *   module:Layout~Blob#length|length} raw data.\n   *\n   * All {@link module:Layout~Layout|Layout} instances are immutable\n   * after construction, to prevent internal state from becoming\n   * inconsistent.\n   *\n   * @local Layout\n   * @local ExternalLayout\n   * @local GreedyCount\n   * @local OffsetLayout\n   * @local UInt\n   * @local UIntBE\n   * @local Int\n   * @local IntBE\n   * @local NearUInt64\n   * @local NearUInt64BE\n   * @local NearInt64\n   * @local NearInt64BE\n   * @local Float\n   * @local FloatBE\n   * @local Double\n   * @local DoubleBE\n   * @local Sequence\n   * @local Structure\n   * @local UnionDiscriminator\n   * @local UnionLayoutDiscriminator\n   * @local Union\n   * @local VariantLayout\n   * @local BitStructure\n   * @local BitField\n   * @local Boolean\n   * @local Blob\n   * @local CString\n   * @local Constant\n   * @local bindConstructorLayout\n   * @module Layout\n   * @license MIT\n   * @author Peter A. Bigot\n   * @see {@link https://github.com/pabigot/buffer-layout|buffer-layout on GitHub}\n   *)\n\n@noble/hashes/esm/utils.js:\n  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)\n\n@noble/curves/esm/utils.js:\n  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)\n\n@noble/curves/esm/abstract/modular.js:\n  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)\n\n@noble/curves/esm/abstract/curve.js:\n  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)\n\n@noble/curves/esm/abstract/edwards.js:\n  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)\n\n@noble/curves/esm/ed25519.js:\n  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)\n\n@noble/curves/esm/abstract/weierstrass.js:\n  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)\n\n@noble/curves/esm/_shortw_utils.js:\n  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)\n\n@noble/curves/esm/secp256k1.js:\n  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)\n*/\n";
module.exports = {
  "code": code,
  "ipfsCid": "QmRYETBcCUTtLThDhARpSKoq5Jo1EmgGXdyUQ6Zv7nm5sm",
};
